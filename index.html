<!DOCTYPE html>
<html>
  <head>
    <title>Adding Async Algorithms to std</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./fonts.css"/>
    <style>
        body { font-family: 'Droid Serif'; }
        h1, h2, h3 {
            font-family: 'Yanone Kaffeesatz';
            font-weight: normal;
        }
        .remark-code, .remark-inline-code { font-family: 'Droid Sans Mono'; }
        .remark-slide-content {
            padding-bottom: 4em;
        }
        div.footer {
            bottom: 12px;
            position: absolute;
            right: 100px;
            width: 100%;
            opacity: .6;
        }
        
        .border {
            border: 2px solid steelblue;
        }

        div.emscripten-output {
            font-family: 'Droid Sans Mono';
            font-size: 14pt;
            border: 2px solid steelblue;
            padding: 5px;
            background: black;
            color: lightgreen;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            padding: 5px;
            border: 1px solid steelblue;
        }
        td {
            color: #7f0000;
        }
        th {
            border-bottom: 3px solid steelblue;
            color: black;
        }
        
        .green {
            color: seagreen
        }

        .column:first-of-type {float:left}
        .column:last-of-type {float:right}

        .split-30 .column:first-of-type {width: 30%}
        .split-30 .column:last-of-type {width: 70%}
        .split-40 .column:first-of-type {width: 40%}
        .split-40 .column:last-of-type {width: 60%}
        .split-50 .column:first-of-type {width: 50%}
        .split-50 .column:last-of-type {width: 50%}
        .split-60 .column:first-of-type {width: 60%}
        .split-60 .column:last-of-type {width: 40%}
        .split-70 .column:first-of-type {width: 70%}
        .split-70 .column:last-of-type {width: 30%}

        blockquote {
            background: lightgray ;
            border-left: 10px solid deepskyblue;
            margin: 1.5em 0px;
            padding: 0.5em 10px;
            quotes: "\201C""\201D""\2018""\2019";
        }
        blockquote:before {
            color: #ccc;
            font-size: 4em;
            line-height: 0.1em;
            margin-right: 0.25em;
            vertical-align: -0.4em;
        }
        blockquote p {
            display: inline;
        }
    </style>
  </head>
  <body>
    <textarea id="source">

layout: true
<div class="footer"><span>.right[&copy; 2016 Kirk Shoop ([github](http://github.com/kirkshoop) [twitter](http://twitter.com/kirkshoop))]</span></div>

---

class: middle

.center[

# Adding Async Algorithms to std

]

<rx-marbles key="debounce"/>

???

> structure as interview (slide per question) with answer prompts in the notes

have you watched __sean parent's__ _avoid raw loops_ talk?

have you watched __eric neibler's__ _calendar printer_ talk using range-v3?

---

module: Context
function: intervalsv3
types: 
arguments: 
output: rxv3output

# ints distributed in time
.split-60[
.column[

__code__ (rxcppv3)

```cpp
auto threeeven = copy_if(even) | 
  take(3) |
  `delay`(makeStrand, 1s);

intervals(makeStrand, steady_clock::now(), 1s) | 
  threeeven |
  as_interface<long>() |
  finally([](){cout << "caller stopped" << endl;}) |
  printto(cout) |
  start<destruction>(subscription{}, destruction{});
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxv3output"/>
]

]

]

???
---
## delay
<rx-marbles key="delay"/>
???
> needs to schedule a function for later
---

# handling ux events
__code__ (coroutine algorithms)

```cpp
std::future<void> AddVisuals(CoreWindow window, VisualCollection visuals) 
{
  for co_await (auto move : window.co_PointerPressed() |
    transform([](auto press) -> float2 {return press.args.CurrentPoint().Position(); }) |
    `filter`([](auto point) {return !VisualAndOffsetFromPoint(visuals, point).first; })) 
  {
    AddVisual(visuals, point);
  }
}
```

???
---
## copy_if
<rx-marbles key="filter"/>
???
> needs to selectively pass to the next handler
---

# handling ux events
__code__ (coroutine algorithms)

```cpp
std::future<void> MoveVisuals(CoreWindow window, VisualCollection visuals) {
  for co_await (auto move : `window.co_PointerPressed()` |
    transform([](auto press) -> float2 {return press.args.CurrentPoint().Position(); }) |
    transform([=](auto point) {return VisualAndOffsetFromPoint(visuals, point); }) |
    filter([](auto selected) {return !!selected.first; }) |
    transform([=](auto selected) {
      MoveToTop(visuals, selected.first);
      return `window.co_PointerMoved()` |
        transform([](auto move) -> float2 {return move.args.CurrentPoint().Position(); }) |
        transform([=](auto point) {
          auto to = float2{ point.x + selected.second.x, point.y + selected.second.y };
          return std::make_pair(selected.first, to);
        }) |
        take_until(`window.co_PointerReleased()`);
    }) |
    `merge`()) {
    move.first.Offset({ move.second.x, move.second.y, 0.0f });
  }
}

```

???
---
## merge
<rx-marbles key="merge"/>
???
> needs to merge values from multiple sources
---

function: rxmousedrags
output: rxmousedragsoutput

# moves while mouse button down
.split-60[
.column[

__code__ (rxcpp)

```cpp
auto down$ = mousedown$("#window");
auto up$ = mouseup$("#window");
auto move$ = mousemove$("#window");

down$ |
  flat_map([=](MouseEvent){
    return move$ |
      `take_until`(up$) |
      map([](MouseEvent){return 1;}) |
      start_with(0) |
      sum();
  }) |
  map( 
    [](int c){
      return to_string(c) + " moves while mouse down";
    }) |
  subscribe(println(cout));
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxmousedragsoutput"/>
]

]

]

???
> * on each mouse up, print the number of mouse moves since mouse down.
> * shows how you can adapt existing sequences to async algorithms
> * the mouse event functions wrap HTML DOM addeventlistener access provided by emscripten.
---
## take_until
<rx-marbles key="takeUntil"/>
???
> needs to stop the source early when the trigger value arrives
---

function: rxlinesfrombytes
types: number,number,number
arguments: 1000, 4, 11
output: rxlinesfrombytesoutput

# lines from bytes
.split-60[
.column[

__code__ (rxcpp)

```cpp
asyncReadBytes() |
  tap(`printVectorOfBytes`) |
  concat_map(vectorOfStringsFromVectorOfBytes) |
  group_by(groupFromString) |
  flat_map(appendGroupStrings) |
  subscribe(`println(cout)`);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxlinesfrombytesoutput"/>
]

]

]

???
bytes arrive once a second. as each set of bytes arrives, it is split on `\r`, grouped into lines and then each group is appended into a line

> * highlighted lines __print__ the _bytes_ as they arrive and the _lines_ as they are emited
> * __$__ is used to indicate a source of values over time. Popularized by @stalz
> * the output is generated live on slide transition by the C++ code compiled by emscripten
---

function: rxhttp
types: string, number
arguments: https://raw.githubusercontent.com/Reactive-Extensions/RxCpp/master/README.md, 80
output: rxhttplocalhostoutput

# bytes from http GET
.split-60[
.column[

__code__ (rxcpp)

```cpp
struct data { int size; string firstLine;};
struct model {
    map<string, data> store;
};

httpGet("https://aka.ms/rxcppreadme") |
  flat_map([](response_t r) {
    return r.progress() |
      `combine_latest`(
        [=](progress_t p, vector<uint8_t> d){
          return make_tuple(r.url(), p, d);
        },
        r.load()) |
      `scan`(
        model{}, 
        updateModelFromTuple);
  }) |
  subscribe(println(cout));
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxhttplocalhostoutput"/>
]

]

]

???
> * a common pattern is to scan into a model. the result is a source of model updates
> * in the JS world, scan to a model is an implementation of the `flux` concept.
> * httpGet wraps `XmlHttpRequest` access provided by emscripten.
---
## scan
<rx-marbles key="scan"/>
???
> * scan holds x as state.
> * the function is called when a value arrives.
> * x is assigned the result of the function.
> * the result of the function is emitted.
---
name: whyalgo

#why alogrithms?

* ## .green[documented]
* ## .green[stable]
* ## .green[optimized]
* ## .green[descriptive]

???
* the __behavior__, __complexity__ and __tradeoffs__ selected are
documented and consistent across implementations
* the implementation is __well specified__, __tested__ and __actively maintained__
* the implementation is __minimal__ and __efficient__
* the usage __describes__ the steps clearly (transform and remove_if vs for loop and an if statement)

> after a while looking at a for-loop will become an excercise in finding the set of algorithms that it re-implements
---

##what do algorithms operate on?

???

algorithms deal with sequences of values

---

name: sequences

#sequences

???
What ways can a sequence be delivered?
---
template: sequences

.split-50[
.column[

## in space
* ## vector of mouse positions
* ## generator of mouse positions

]

.column[

`using mouseMoves = vector<tuple<int,int>>;`

`$$
\begin{array}{|c|c|c|c|c|}
\hline
0,0 & 100,100 & 200,200 & 300,300 & 400,400\\
\hline
\end{array}
$$`

```cpp
auto mouseMoves(int start, int end) 
    -> std::generator<tuple<int, int>> {
    for(;start != end; ++start){
        auto position = start * 100;
        co_yield make_tuple(position, position);
    }
}
```

]

]

???

values distributed in space

---
template: sequences

.split-50[
.column[

## in time
* ##mouse move events
* ##network packets

]

.column[

```cpp
auto window::mouseMoves()
    -> co_generator<tuple<int, int>> {
    for co_await(auto event : events()) {
        if (event.id == MOUSEMOVE) {
            co_yield mousePositionFrom(event);
        }
    }
}

auto socket::bytes()
    -> co_generator<vector<byte>> {
    vector<byte> out;
    while (out = co_await read(. . .)) {
        co_yield out;
    }
}
```

]

]

???

values distributed in time

---

## what algorithms will help define the concepts?
???
---
## copy_if
<rx-marbles key="filter"/>
???
> needs to selectively pass to the next handler
---
## last_or_default
<rx-marbles key="last"/>
???
> needs to know when the source is complete
---
## take
<rx-marbles key="take"/>
???
> take needs to be able to stop the source early.
---
## delay
<rx-marbles key="delay"/>
???
> needs to schedule a function to be called later
---
## resume_error
![rx catch marble diagram](content/marbles-catch.png)
???
> needs to handle errors by switching to a different source
---

## what features are required to build the desired algorithms?
???
---

## what is the minimum set of features?
.split-40[
.column[
####sequence concepts
```cpp
struct observable {
    void bind(observer);
};

struct observer {
    template<class T>
    void next(T);
};

struct lifter {
    observer lift(observer);
};
```

]

.column[

####sequence implementations
```cpp
const auto ints = [](auto first, auto last){
  return make_observable([=](auto r){
    for(auto i = first;; ++i){
      r.next(i);
      if (i == last) break;
    }
  });
};

const auto copy_if = [](auto pred){
  return make_lifter([=](auto r){
    return make_observer(r, [=](auto& r, auto v){
        if (pred(v)) r.next(v);
    });
  });
};
```

]
]

???
> Minimum 
> * a .green[source] of values
> * a .green[handler] for values
> * algorithms that .green[adapt sources]
> * algorithms that .green[lift handlers]
---

module: Context
function: pushv3
types: number,number
arguments: 0, 9
output: pushv3output

## push sequence

.split-60[
.column[

__code__

```cpp
ints(0, 9) | 
  copy_if(even) | 
  printto(cout) |
  start<destruction>(subscription{}, destruction{});
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="pushv3output"/>
]

]

]

???
now improve the contract.
---
## what needs to change to support last_or_default?

<rx-marbles key="last"/>
???
last needs to know when the source is complete
---

.split-60[
.column[

####sequence implementations
```cpp
const auto last_or_default = [](auto def){
  return make_lifter([=](auto scbr){
    return make_subscriber([=](auto ctx){
      auto r = scbr.create(ctx);
      using last_t = std::decay_t<decltype(def)>;
      auto last = make_state<last_t>(ctx.lifetime, def);
      return make_observer(r, r.lifetime,
        [last](auto& , auto v){
          last.get() = v;
        },
        [last](auto& r){
          r.next(last.get());
          r.`complete`();
        });
    });
  });
};
```
]
.column[
####sequence concepts
```cpp
struct observer {
    template<class T>
    void next(T);
    void `complete`();
};

```

]
]

???
---

module: Context
function: lastv3
types: number,number,number
arguments: 0, 100000, 42
output: lastv3output

## what needs to change to support last_or_default?

.split-60[
.column[

__code__

```cpp
ints(0, 100000) | 
  copy_if(even) | 
  last_or_default(42) |
  printto(cout) |
  start<destruction>(subscription{}, destruction{});
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="lastv3output"/>
]

]

]

???
1 million ints are filtered to 500 thousand even ints and then the last even int is printed.
---
## what needs to change to support take?

<rx-marbles key="take"/>
???
take needs to be able to stop the source.
---

## what features are needed to support asynchronous lifetime and cancellation?

* ## .green[make_shared<T>] for state
* ## .green[graph] of nested lifetimes
* ## .green[signal] for explicit cancellation of lifetime graph
* ## .green[registration] for cancellation signal

???
---
.split-50[
.column[
####sequence concepts
```cpp
struct subscription
{
  bool is_stopped();
  void stop(); // `signal`

  // `nested`
  void insert(const subscription& s);
  void erase(const subscription& s);

  // `registration`
  void insert(function<void()> stopper);

  // `make_shared<Payload>`
  template<class Payload, class... ArgN>
  state<Payload> make_state(
    ArgN... argn);
};

template<class Payload>
struct context {
    subscription lifetime;
    Payload& get();
};
```
]
.column[
####sequence concepts
```cpp
struct starter {
    template<class Payload>
    subscription start(context<Payload>);
};

struct subscriber {
    template<class Payload>
    observer create(context<Payload>);
};

struct observable {
    starter bind(subscriber);
};

struct lifter {
    subscriber lift(subscriber);
};

struct adaptor {
    observable adapt(observable);
};
```

]
]

???

> * subscription .green[owns] the lifetime of a subscribed expression.
> * subscription lifetimes can be .green[nested].
> * .green[stop] will call stop on all nested subscriptions then call all stoppers in the .green[inverse] order they were inserted.
> * .green[make_state] will allocate heap that is scoped by the subscription lifetime. all the state is destructed when the last copy of the subscription is destructed.

---

####push sequence implementations
```cpp
const auto take = [](int n){
  return make_adaptor([=](auto source){
    return make_observable([=](auto scrb){
        return source.bind(
          make_subscriber([=](auto ctx){
            auto r = scrb.create(ctx);
            auto remaining = `make_state<int>`(r.lifetime, n);
            auto lifted = make_observer(r, r.lifetime,
              [remaining](auto& r, auto v){
                r.next(v);
                if (--remaining.get() == 0) {
                    r.`complete`();
                }
              });
            if (n == 0) {
              lifted.`complete`();
            }
            return lifted;
          }));
    });
  });
};
```

???
> * expanded .green[make_observer], that can pass observer calls through by default and connect the lifetime.
> * use async state to store the last value.
> * use complete to stop the lifetime early
---

module: Context
function: takev3
types: number,number,number
arguments: 0, 9, 3
output: takev3output

## what needs to change to support take?

.split-60[
.column[

__code__

```cpp
ints(0, 9) | 
  copy_if(even) | 
  take(3) |
  printto(cout) |
  start<destruction>(subscription{}, destruction{});
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="takev3output"/>
]

]

]

???
output shows the expanded lifetime stages for a sender/receiver pair.

in the __construct__ phase new operators are constructed

in the __subscribe__ phase the lifetime is constructed and the dest for each operator is provided

in the __run__ phase the next notifications occur.

in the __complete__ phase complete is delievered followed by stop. or stop is called.

when the objects go out of scope the destructors are called. 

__flow__ construct from source to dest, subscribe from dest to source, run and complete flow from source to dest and stop from dest to source.

---

## what needs to change to support failure?

???
the exception must be caught and sent to the receiver and then stop the subscription. 
--

```cpp
struct receiver
{
  subscription lifetime;
  template<class V>
  void operator()(V);
  `void operator()(exception_ptr);`
  void operator()();
};
```

???
stop is already working. adding the method on the receiver is the only change to the contract.
---

function: designerror
types: number,number,number
arguments: 0, 9, 3
output: designerroroutput

## what needs to change to support failure?

.split-60[
.column[

__code__

```cpp
async_ints(0, 9) | 
  copy_if(always_throw) | 
  take(3) | 
  printto(cout);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="designerroroutput"/>
]

]

]

???
---


## what needs to change to support delay?

<rx-marbles key="delay"/>

???
need to schedule a function to be called later

switch to a more complete implementation - rxcpp
---

## what needs to change to support delay?

.split-50[
.column[
```cpp
struct `schedulable`
  : public worker
  , public subscription {
  void operator()();
};

struct `worker` {
  steady_clock::time_point now();

  void schedule(const schedulable& scbl);
  void schedule(
      steady_clock::time_point when, 
      const schedulable& scbl);
};

struct `scheduler` {
    worker create_worker(subscription);
};
```
]
.column[
```cpp
struct subscription {
  void unsubscribe();  
};

template<class T>
struct observer {
  on_next(T);
  on_error(exception_ptr);
  on_completed();
};

template<class T>
struct subscriber 
  : public observer<T>
  , public subscription {
};

template<class T>
struct observable {
  subscription subscribe(subscriber<T>);
};
```
]
]
???
a schedulable is a function that can be scheduled or stopped.

a worker is a strand of execution. 

only one schedulable is called at a time.

when a worker is stopped all pending schedulable are stopped.
---

function: rxdelay
types: number, number, number
arguments: 1000, 1500, 3
output: rxdelayoutput

## what needs to change to support delay?

.split-60[
.column[

__code__

```cpp
  interval(1s, scheduler) |
    tap(printproduced) |
    delay(1500ms, scheduler) |
    take(5) |
    subscribe(printemitted);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxdelayoutput"/>
]

]

]

???
---

## what needs to change to support testing?

???
need to virtualize time
---

## what needs to change to support testing?

.split-50[
.column[
```cpp
struct test_worker {
  steady_clock::time_point now();

  void schedule(const schedulable& scbl);
  void schedule(
      steady_clock::time_point when, 
      const schedulable& scbl);

  void advance_to(long time) const;
  void advance_by(long time) const;
  void sleep(long time) const;

  template<class T, class F>
  auto start(F createSource, long created, 
    long subscribed, long unsubscribed) const
    -> subscriber<T, testable_observer<T>>;
};
```
]
.column[
```cpp
struct recorded {
  steady_clock::time_point time() const;
  template<class Observer>
  virtual accept(const Observer& o) const;
};

struct test {
  using messages_t vector<recorded>;

  steady_clock::time_point now() const;
  test_worker create_worker(subscription cs) const;

  template<class T>
  auto make_hot_observable(messages_t m) const
    -> testable_observable<T>;
  template<class T>
  auto make_cold_observable(messages_t m) const;
    -> testable_observable<T>;
};
```
]
]
???
---

function: rxtestdelay
types: number, number
arguments: 1000, 1500
output: rxtestdelayoutput

## what needs to change to support testing?

.split-60[
.column[

__code__

```cpp
auto scheduler = make_test();
auto worker = scheduler.create_worker();

auto interval$ = scheduler.make_hot_observable({
    on.next(1000, 1),
    on.next(2000, 2),
    on.next(3000, 3),
    on.next(4000, 4)
});

auto `res` = worker.start([&]() {
  return interval$ |
    tap(printproduced) |
    delay(1500ms, scheduler) |
    take(3) | 
    tap(printemitted);
});
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxtestdelayoutput"/>
]

]

]

???
---

## what needs to change to support testing?

```cpp
auto required = rxu::to_vector({
  on.next(1000 + 1500, 1),
  on.next(2000 + 1500, 2),
  on.next(3000 + 1500, 3)
});
auto actual = `res`.get_observer().messages();
cout << "emitted value test";
if (required == actual) {
    cout << " - SUCCEEDED" << endl;
} else {
    cout << " - FAILED" << endl;
    cout << "REQUIRED: " << required << endl;
    cout << "ACTUAL  : " << actual << endl;
}
```
???
---

##what designs do other combinations produce?

???
---

name: asyncgenerator

## async_generator 

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
__sequence__ | __pull__ | trigger    | operator

---

template: asyncgenerator

## async_generator concepts

.split-50[
.column[
```cpp
template<class T>
struct await_iterator {
  bool await_ready();
  void await_suspend(coroutine_handle<>);
  async_iterator<T> await_resume();
};

template<class T>
struct async_iterator {
    T& operator*();
    await_iterator<T> operator++();
};
```
]
.column[
```cpp
template<class T>
struct async_generator {
    await_iterator<T> begin();
    async_iterator<T> end();
};
```
]
]
???
---
template: asyncgenerator

## implement filter operator

```cpp
  template<typename T, typename P>
  async_generator<T> filter(async_generator<T> s, P pred) {
    for co_await(auto&& v : s) {
      if (pred(v)) {
        co_yield v;
      }
    }
  }
```
???

---
template: asyncgenerator

##use operators to chain algorithms together

```cpp
auto fiveOddInts = tempSensor() |
  filter([](int n) { return n % 2 == 0; }) | // discard even
  take(5); // stop after 5

for co_await(auto n : fiveOddInts) {
  // . . . 
}
```

???

---

name: sfrp

## sfrp

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
__sequence__ | __pull__ | omission   | function

???
####Functional Reactive Programming (FRP)
Conal Elliot describes this as '**values over time**'. Conal specifies two principals that constrain the definition and 
implementation of an FRP system. 

1. **denotation** - .text[a precise language independent description of the 
whole system that can be verified without an implementation 
(one expression would be in the Lambda Calculus)]
2. **continuous time** - the system will have a valid value for any time value.

Conal continues to develop a very precise denotation that can be resolved precisely into a specification and 
various implementations. Conal vociferously defends the term FRP when applied to libraries that are not precisely 
derived from the denotation.

####The Essence and Origins of Functional Reactive Programming
Conal Elliot @ Lambda Jam [YouTube](https://www.youtube.com/watch?v=j3Q32brCUAI)

####sfrp (c++)
David Sankel @ CppNow [YouTube](https://www.youtube.com/watch?v=tyaYLGQSr4g),[github](https://github.com/camio/sbase)
---

template: sfrp

####example

```cpp
template <typename R, typename Args...>
Behavior<R>
map(function<R(Args...)> func, Behavior<Args>... behaviors);

Behavior<Drawing> 
circleFollowsMouse(Behavior<Point2D> mousePos) {
  return map(circleAt, mousePos);
}
```
???
---
##complete.
questions?

<rx-marbles key="merge"/>

???
---
name: rangev3

##range-v3

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
sequence     | pull     | omission   | operator

???
adds operator chaining to the stl

---
template: rangev3

##the range concept

```cpp
template<class Iterator, class EndIterator = Iterator>
struct range {
    Iterator begin();
    EndIterator end();
};
```

???
EndIterator may be a different type than Iterator to facilitate sentinel EndIterators

---

## range-v3 - implement the transform view 

```cpp
// A class that adapts an existing range with a function
template<class Rng, class Fun>
class transform_view : public view_adaptor<transform_view<Rng, Fun>, Rng>
{
    class adaptor : public adaptor_base
    {
        // . . .
        auto get(range_iterator_t<Rng> it) const -> decltype(fun_(*it)) {
            return `fun_(*it)`;
        }
    };
    adaptor begin_adaptor() const { return {fun_}; }
    adaptor end_adaptor() const { return {fun_}; }
    // . . .
};
template<class Rng, class Fun>
transform_view<Rng, Fun> transform(Rng && rng, Fun fun) {
    return {std::forward<Rng>(rng), std::move(fun)};
}
```
???
---
template: rangev3

##use operators to chain algorithms together

```cpp
auto fiveOddInts = view::ints(0) | //generates next int when asked 
  view::remove_if([](int n) { return n % 2 == 0; }) | // discard even ints
  view::take(5); // stop after 5
  
auto result = fiveOddInts | view::to_vector;
```
???
---

name: transducers

##Transducers

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
algorithm    | push     | omission   | function

???
---

template: transducers

##the step function

```cpp
struct transducer {
    template<class NextStep>
    struct step {
        template<class State, class T>
        auto operator()(State state, T v);
        template<class State>
        auto operator()(State state);
    };
    template<class NextStep>
    auto operator()(NextStep nextstep) {
        return step<NextStep>(nextstep);
    }
};
```

???
`step::operator()` is where a call to nextstep would pass the value along.

---
template: transducers

##implement the filterer transducer

```cpp
  auto filterer = [](auto pred) {
    return [=](auto step) {
      return stateless(
        [=](auto s, auto v) {
          if (`pred(v)`) {return step(s, v);}
          return s;
        },
        [=](auto s){
          return step(s);
        });
    };
  };
```
???
---
template: transducers

##use function nesting to chain algorithms together

```cpp
auto fiveOddInts = comp(
  filter([](int n) { return n % 2 == 0; }), // discard even
  take(5)); // stop after 5
  
auto result = into(vector<int> {}, fiveOddInts, range(0, 10));
```
???
---

name: rxcpp

## rxcpp 

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
sequence     | push     | trigger    | operator

---

## concepts in rxcpp

.split-50[
.column[
```cpp
struct schedulable
  : public worker
  , public subscription {
  void operator()();
};

struct worker {
  steady_clock::time_point now();

  void schedule(const schedulable& scbl);
  void schedule(
      steady_clock::time_point when, 
      const schedulable& scbl);
};

struct scheduler {
    worker create_worker(subscription);
};
```
]
.column[
```cpp
struct subscription {
  void unsubscribe();  
};

template<class T>
struct observer {
  on_next(T);
  on_error(std::exception_ptr);
  on_completed();
};

template<class T>
struct subscriber 
  : public observer<T>
  , public subscription {
};

template<class T>
struct observable {
  subscription subscribe(subscriber<T>);
};
```
]
]
???
* `subscription` controls the lifetime of the subscribe and is shared with the caller
* `observer` has the same aspects as an iterator pair but in reverse
* `observable` allows __hot__ sources to be shared and __cold__ sources to lazy start.
---
## rxcpp - implement the filter operator

```cpp
auto filter = [](auto pred) {
  return [=](auto subscriber) {
    return make_subscriber(
      [=](auto v) {
        if (`pred(v)`) {
          subscriber.on_next(v);
        }
      },
      [=](std::exception_ptr ep) {
        subscriber.on_error(ep);
      },
      [=]() {
        subscriber.on_completed();
      }
    );
  }
};
```
???
---

template: rxcpp

##use operators to chain algorithms together

```cpp
auto fiveOddInts = tempSensor() | 
  filter([](int n) { return n % 2 == 0; }) | // discard even
  take(5); // stop after 5

fiveOddInts.subscribe([](int n){. . .});
```

???
---

    </textarea>
    <!--script src="https://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript" >
    </script-->
    <script src="./remark-latest.min.js" type="text/javascript" >
    </script>
    <script src="./CustomElements.min.js" type="text/javascript" >
    </script>
    <script src="./element.js" type="text/javascript" >
    </script>
    <script>
        var Module = {noInitialRun: false};
        var printTo = function(output) {
            return function(text){
                if (output) {
                    text = text.replace(/&/g, "&amp;");
                    text = text.replace(/</g, "&lt;");
                    text = text.replace(/>/g, "&gt;");
                    text = text.replace('\n', '<br>', 'g');
                    output.innerHTML += text + "<br>";
                }
            };
        };
    </script>
    <script src="./examples.js" type="text/javascript" >
    </script>
    <script src="./rxcppv3/context.js" type="text/javascript" >
    </script>
    <!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured" type="text/javascript" >
    </script-->
    <script src="./MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured" type="text/javascript" >
    </script>
    <script>
        var slideshow = remark.create({
            ratio: "16:9",
            highlightLanguage: "cpp",
            highlightStyle: "tomorrow",
            highlightSpans: true
        });
        MathJax.Hub.Config({
            displayAlign: "left",
            tex2jax: {
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                inlineMath: [['$','$'], ['\\(','\\)']]
            }
        });
        MathJax.Hub.Configured();
        // mathjax examples 

        // `$$ x = (-b +- sqrt(b^2-4ac))/(2a) . $$`

        // `$$ \int_{V_1}^{V_2}mVdV =  \int_{s_1}^{s_2} F_s ds $$`

        // `$$
        // A \xrightarrow{send} B
        // $$`

        // `$$
        // \newcommand{\ra}[1]{\!\!\!\!\!\!\!\!\!\!\!\!\xrightarrow{\quad#1\quad}\!\!\!\!\!\!\!\!}
        // \newcommand{\da}[1]{\left\downarrow{\scriptstyle#1}\vphantom{\displaystyle\int_0^1}\right.}
        // %
        // \begin{array}{llllllllllll}
        // 0 & \ra{f_1} & A & \ra{f_2} & B & \ra{f_3} & C & \ra{f_4} & D & \ra{f_5} & 0 \\
        // \da{g_1} & & \da{g_2} & & \da{g_3} & & \da{g_4} & & \da{g_5} & & \da{g_6} \\
        // 0 & \ra{h_1} & 0 & \ra{h_2} & E & \ra{h_3} & F & \ra{h_4} & 0 & \ra{h_5} & 0 \\
        // \end{array}
        // $$`

        var Context = ContextLib();

        slideshow.on("showSlide", function(slide) {
            if (!!slide.properties.function){
                var output = document.getElementById(slide.properties.output);
                if (output) output.innerHTML = ''; // clear contents
                var module = Module;
                if (!!slide.properties.module) {
                  module = window[slide.properties.module];
                }
                module["print"] = printTo(output);
                module.ccall(
                    slide.properties.function, // C function
                    slide.properties.return || null, // return type
                    (slide.properties.types || "").split(','), // argument types
                    (slide.properties.arguments || "").split(',')); // arguments
            }
        });
        slideshow.on("hideSlide", function(slide) {
            Module.ccall('reset', null, [], []);
            Context.ccall('reset', null, [], []);
        });
    </script>
  </body>
</html>
