<!DOCTYPE html>
<html>
  <head>
    <title>Adding Async Algorithms to std</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./fonts.css"/>
    <style>
        body { font-family: 'Droid Serif'; }
        h1, h2, h3 {
            font-family: 'Yanone Kaffeesatz';
            font-weight: normal;
        }
        .remark-code, .remark-inline-code { font-family: 'Droid Sans Mono'; }
        .remark-slide-content {
            padding-bottom: 4em;
        }
        div.footer {
            bottom: 12px;
            position: absolute;
            right: 100px;
            width: 100%;
        }
        
        .border {
            border: 2px solid steelblue;
        }

        div.emscripten-output {
            font-family: 'Droid Sans Mono';
            font-size: 14pt;
            border: 2px solid steelblue;
            padding: 5px;
            background: black;
            color: lightgreen;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            padding: 5px;
            border: 1px solid steelblue;
        }
        td {
            color: #7f0000;
        }
        th {
            border-bottom: 3px solid steelblue;
            color: black;
        }
        
        .green {
            color: seagreen
        }

        .column:first-of-type {float:left}
        .column:last-of-type {float:right}

        .split-30 .column:first-of-type {width: 30%}
        .split-30 .column:last-of-type {width: 70%}
        .split-40 .column:first-of-type {width: 40%}
        .split-40 .column:last-of-type {width: 60%}
        .split-50 .column:first-of-type {width: 50%}
        .split-50 .column:last-of-type {width: 50%}
        .split-60 .column:first-of-type {width: 60%}
        .split-60 .column:last-of-type {width: 40%}
        .split-70 .column:first-of-type {width: 70%}
        .split-70 .column:last-of-type {width: 30%}

        blockquote {
            background: lightgray ;
            border-left: 10px solid deepskyblue;
            margin: 1.5em 0px;
            padding: 0.5em 10px;
            quotes: "\201C""\201D""\2018""\2019";
        }
        blockquote:before {
            color: #ccc;
            font-size: 4em;
            line-height: 0.1em;
            margin-right: 0.25em;
            vertical-align: -0.4em;
        }
        blockquote p {
            display: inline;
        }
    </style>
  </head>
  <body>
    <textarea id="source">

layout: true
<div class="footer"><span>.right[&copy; 2016 Kirk Shoop ([github](http://github.com/kirkshoop) [twitter](http://twitter.com/kirkshoop))]</span></div>

---

class: middle

.center[

# Adding Async Algorithms to std

]

<rx-marbles key="debounce"/>

???

> structure as interview (slide per question) with answer prompts in the notes

have you watched __sean parent's__ _avoid raw loops_ talk?

have you watched __eric neibler's__ _calendar printer_ talk using range-v3?

---

function: rxlinesfrombytes
types: number,number,number
arguments: 1000, 4, 11
output: rxlinesfrombytesoutput

# lines from bytes
.split-60[
.column[

__code__ (rxcpp)

```cpp
asyncReadBytes() |
  tap(`printVectorOfBytes`) |
  concat_map(vectorOfStringsFromVectorOfBytes) |
  group_by(groupFromString) |
  flat_map(appendGroupStrings) |
  subscribe(`println(cout)`);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxlinesfrombytesoutput"/>
]

]

]

???
bytes arrive once a second. as each set of bytes arrives, it is split on `\r`, grouped into lines and then each group is appended into a line

> * highlighted lines __print__ the _bytes_ as they arrive and the _lines_ as they are emited
> * __$__ is used to indicate a source of values over time. Popularized by @stalz
> * the output is generated live on slide transition by the C++ code compiled by emscripten
---

function: rxmousedrags
output: rxmousedragsoutput

# moves while mouse button down
.split-60[
.column[

__code__ (rxcpp)

```cpp
auto down$ = mousedown$("#window");
auto up$ = mouseup$("#window");
auto move$ = mousemove$("#window");

down$ |
  flat_map([=](MouseEvent){
    return move$ |
      take_until(up$) |
      map([](MouseEvent){return 1;}) |
      start_with(0) |
      sum();
  }) |
  subscribe( 
    [](int c){
      cout << c << " moves while mouse down" << endl;
    },
    [](exception_ptr ep){cout << what(ep) << endl;}));
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxmousedragsoutput"/>
]

]

]

???
---

function: rxhttp
types: string
arguments: http://localhost:8090/serve.js
argumentsd: https://raw.githubusercontent.com/Reactive-Extensions/RxCpp/master/AUTHORS.txt
output: rxhttplocalhostoutput

# bytes from http GET
.split-60[
.column[

__code__ (rxcpp)

```cpp
struct data { int size; string firstLine;};
struct model {
    map<string, data> store;
};

httpGet(url) |
  flat_map([](response_t r) {
    return r.progress() |
      combine_latest(
        [=](progress_t p, vector<uint8_t> d){
          return make_tuple(r.url(), p, d);
        },
        r.load()) |
      scan(
        model{}, 
        updateModelFromTuple);
  }) |
  subscribe(`println(cout)`);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="rxhttplocalhostoutput"/>
]

]

]

???
---
name: whyalgo

#why alogrithms?

* ## .green[documented]
* ## .green[stable]
* ## .green[optimized]
* ## .green[descriptive]

???
* the __behavior__, __complexity__ and __tradeoffs__ selected are
documented and consistent across implementations
* the implementation is __well specified__, __tested__ and __actively maintained__
* the implementation is __minimal__ and __efficient__
* the usage __describes__ the steps clearly (transform and remove_if vs for loop and an if statement)

> after a while looking at a for-loop will become an excercise in finding the set of algorithms that it re-implements
---

##what do algorithms operate on?

???

algorithms deal with sequences of values

---

name: sequences

#sequences

???
What ways can a sequence be delivered?
---
template: sequences

.split-50[
.column[

## in space
* ## vector of mouse positions
* ## generator of mouse positions

]

.column[

`using mouseMoves = vector<tuple<int,int>>;`

`$$
\begin{array}{|c|c|c|c|c|}
\hline
0,0 & 100,100 & 200,200 & 300,300 & 400,400\\
\hline
\end{array}
$$`

```cpp
auto mouseMoves(int start, int end) 
    -> std::generator<tuple<int, int>> {
    for(;start != end; ++start){
        auto position = start * 100;
        co_yield make_tuple(position, position);
    }
}
```

]

]

???

values distributed in space

---
template: sequences

.split-50[
.column[

## in time
* ##mouse move events
* ##network packets

]

.column[

```cpp
auto window::mouseMoves()
    -> async_generator<tuple<int, int>> {
    for co_await(auto event : events()) {
        if (event.id == MOUSEMOVE) {
            co_yield mousePositionFrom(event);
        }
    }
}

auto socket::bytes()
    -> async_generator<vector<byte>> {
    vector<byte> out;
    while (out = co_await read(. . .)) {
        co_yield out;
    }
}
```

]

]

???

values distributed in time

---

#what are the design options?

* ## .green[__abstract__] the sequence or algorithm?
* ## .green[__flow__] control using push or pull?
* ## .green[__cancel__] by ommission or trigger?
* ## .green[__chain__] algorithms using operator| or function nesting?

???
the shape is largly derived from a set choices about the __surface__ and __behavior__
* __sequence__ iterators, Range | __algorithm__ accumulator step function 
* __pull__ iterators, Enumerator | __push__ Callback, Observer
* __omission__ stop pulling | __trigger__ race between setting and checking a flag
* __operator chaining__ range-v3 | __function nesting__ transducer
---

name: design

# what is needed to build async algorithms?

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
sequence     | push     | trigger    | operator

???
push a sequence through operator-chained algorithms until a trigger or end of sequence.
---

.split-60[
.column[

####push sequence implementations
```cpp
const auto ints = [](auto first, auto last){
    return [=](auto r){
        for(auto i=first;i <= last; ++i){
            r(i);
        }
    };
};
const auto copy_if = [](auto pred){
    return [=](auto dest){
        return [=](auto v){
            if (pred(v)) dest(v);
        };
    };
};
const auto printto = [](auto& output){
    return [&](auto v) {
        output << v << endl;
    };
};
auto even = [](auto v){return (v % 2) == 0;};
```

]

.column[
####push sequence concepts
```cpp
template<class Receiver>
struct sender
{
    void operator()(Receiver r);
};

template<class ReceiverV>
struct algorithm
{
    ReceiverU operator()(ReceiverV r);
};

template<class V>
struct receiver
{
    void operator()(V v);
};
```

]
]

???
---

function: designpush
types: number,number
arguments: 0, 9
output: designpushoutput

## push sequence

.split-60[
.column[

__code__

```cpp
ints(0, 9)(copy_if(even)(printto(cout)));
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="designpushoutput"/>
]

]

]

???
looks like lisp!
obviously needs to chain with operator|
---

function: designoperator
types: number,number
arguments: 0, 9
output: designoperatoroutput

## push sequence

.split-60[
.column[

__code__

```cpp
ints(0, 9) | 
  copy_if(even) | 
  printto(cout);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="designoperatoroutput"/>
]

]

]

???
---

function: designlast
types: number,number,number
arguments: 0, 100000000, 42
output: designlastoutput

## push sequence

.split-60[
.column[

__code__

```cpp
ints(0, 100000000) | 
  copy_if(even) | 
  last_or_default(42) | 
  printto(cout);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="designlastoutput"/>
]

]

]

???
---

function: designtake
types: number,number,number
arguments: 0, 9, 3
output: designtakeoutput

## push sequence

.split-60[
.column[

__code__

```cpp
async_ints(0, 9) | 
  copy_if(even) | 
  take(3) | 
  printto(cout);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="designtakeoutput"/>
]

]

]

???
---

function: designerror
types: number,number,number
arguments: 0, 9, 3
output: designerroroutput

## push sequence

.split-60[
.column[

__code__

```cpp
async_ints(0, 9) | 
  copy_if(always_throw) | 
  take(3) | 
  printto(cout);
```

]

.column[

__output__ (emscripten)

.emscripten-output[
 <div id="designerroroutput"/>
]

]

]

???
---
name: rangev3

##range-v3

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
sequence     | pull     | omission   | operator

???
adds operator chaining to the stl

---
template: rangev3

##the range concept

```cpp
template<class Iterator, class EndIterator = Iterator>
struct range {
    Iterator begin();
    EndIterator end();
};
```

???
EndIterator may be a different type than Iterator to facilitate sentinel EndIterators

---

## range-v3 - implement the transform view 

```cpp
// A class that adapts an existing range with a function
template<class Rng, class Fun>
class transform_view : public view_adaptor<transform_view<Rng, Fun>, Rng>
{
    class adaptor : public adaptor_base
    {
        // . . .
        auto get(range_iterator_t<Rng> it) const -> decltype(fun_(*it)) {
            return `fun_(*it)`;
        }
    };
    adaptor begin_adaptor() const { return {fun_}; }
    adaptor end_adaptor() const { return {fun_}; }
    // . . .
};
template<class Rng, class Fun>
transform_view<Rng, Fun> transform(Rng && rng, Fun fun) {
    return {std::forward<Rng>(rng), std::move(fun)};
}
```
???
---
template: rangev3

##use operators to chain algorithms together

```cpp
auto fiveOddInts = view::ints(0) | //generates next int when asked 
  view::remove_if([](int n) { return n % 2 == 0; }) | // discard even ints
  view::take(5); // stop after 5
  
auto result = fiveOddInts | view::to_vector;
```
???
---

name: transducers

##Transducers

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
algorithm    | push     | omission   | function

???
---

template: transducers

##the step function

```cpp
struct transducer {
    template<class NextStep>
    struct step {
        template<class State, class T>
        auto operator()(State state, T v);
        template<class State>
        auto operator()(State state);
    };
    template<class NextStep>
    auto operator()(NextStep nextstep) {
        return step<NextStep>(nextstep);
    }
};
```

???
`step::operator()` is where a call to nextstep would pass the value along.

---
template: transducers

##implement the filterer transducer

```cpp
  auto filterer = [](auto pred) {
    return [=](auto step) {
      return stateless(
        [=](auto s, auto v) {
          if (`pred(v)`) {return step(s, v);}
          return s;
        },
        [=](auto s){
          return step(s);
        });
    };
  };
```
???
---
template: transducers

##use function nesting to chain algorithms together

```cpp
auto fiveOddInts = comp(
  filter([](int n) { return n % 2 == 0; }), // discard even
  take(5)); // stop after 5
  
auto result = into(vector<int> {}, fiveOddInts, range(0, 10));
```
???
---

name: shape

##What does an async algorithm need?
---

template: shape

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
__?__        | __?__    | trigger    | operator
???
---

name: rxcpp

## rxcpp 

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
__sequence__ | __push__ | trigger    | operator

---

template: rxcpp

## concepts in rxcpp

.split-50[
.column[
```cpp
struct subscription {
  void unsubscribe();  
};

template<class T>
struct observer {
  on_next(T);
  on_error(std::exception_ptr);
  on_completed();
};
```
]
.column[
```cpp
template<class T>
struct subscriber 
  : public observer<T>
  , public subscription {
};

template<class T>
struct observable {
  subscription subscribe(subscriber<T>);
};
```
]
]
???
* `subscription` controls the lifetime of the subscribe and is shared with the caller
* `observer` has the same aspects as an iterator pair but in reverse
* `observable` allows __hot__ sources to be shared and __cold__ sources to lazy start.
---

## rxcpp - implement the filter operator

```cpp
auto filter = [](auto pred) {
  return [=](auto subscriber) {
    return make_subscriber(
      [=](auto v) {
        if (`pred(v)`) {
          subscriber.on_next(v);
        }
      },
      [=](std::exception_ptr ep) {
        subscriber.on_error(ep);
      },
      [=]() {
        subscriber.on_completed();
      }
    );
  }
};
```
???
---

template: rxcpp

##use operators to chain algorithms together

```cpp
auto fiveOddInts = tempSensor() | 
  filter([](int n) { return n % 2 == 0; }) | // discard even
  take(5); // stop after 5

fiveOddInts.subscribe([](int n){. . .});
```

???

---

name: asyncgenerator

## async_generator 

__abstract__ | __flow__ | __cancel__ | __chain__
:----------- | :------- | :--------- | :--------
__sequence__ | __pull__ | trigger    | operator

---

template: asyncgenerator

## async_generator concepts

.split-50[
.column[
```cpp
template<class T>
struct await_iterator {
  bool await_ready();
  void await_suspend(coroutine_handle<>);
  async_iterator<T> await_resume();
};

template<class T>
struct async_iterator {
    T& operator*();
    await_iterator<T> operator++();
};
```
]
.column[
```cpp
template<class T>
struct async_generator {
    await_iterator<T> begin();
    async_iterator<T> end();
};
```
]
]
???
---
template: asyncgenerator

## implement filter operator

```cpp
  template<typename T, typename P>
  async_generator<T> filter(async_generator<T> s, P pred) {
    for co_await(auto&& v : s) {
      if (pred(v)) {
        co_yield v;
      }
    }
  }
```
???

---
template: asyncgenerator

##use operators to chain algorithms together

```cpp
auto fiveOddInts = tempSensor() |
  filter([](int n) { return n % 2 == 0; }) | // discard even
  take(5); // stop after 5

for co_await(auto n : fiveOddInts) {
  // . . . 
}
```

???

---

# repeatedly refresh content

```cpp
    rx::observable<>::interval(on_update.now(), seconds(5), on_update).
        map(as_string{"http://localhost"}).
        flat_map(
            [=](std::string url){
                return http.get(url);
            }).
        flat_map(
            [](ofxRx::HttpProgress p){
                return p.
                    body().
                    scan(
                        std::string{},
                        [](std::string response, ofxRx::BufferRef<char> br){
                            response.append(br.begin(), br.begin() + br.size());
                            return response;
                        }
                    );
            }).
```
???
---

# repeatedly refresh content

## error handling

```cpp
        on_error_resume_next(
            [=](std::exception_ptr ep){
                return rx::observable<>::timer(on_update.now() + seconds(5), on_update).
                    map(as_string{rx::util::what(ep)}).
                    start_with(rx::util::what(ep));
            }).
        repeat().
        finally([=](){response = "stopped!";}).
```
???
---
name: algo

#alogrithms
---

template: algo

<rx-marbles key="filter"/>

???
remove_if_not (range-v3) 
copy_if
---

template: algo

<rx-marbles key="map"/>

???
take (range-v3)
---

template: algo

<rx-marbles key="take"/>

???
transform (range-v3)
---

template: algo

<rx-marbles key="merge"/>

???
join (range-v3)
---

template: algo

<rx-marbles key="combineLatest"/>

???
---

template: algo

<rx-marbles key="amb"/>

???
---
template: algo

<rx-marbles key="scan"/>

???
---
template: algo

<rx-marbles key="reduce"/>

???
---
##range-v3 view namespace

```c++
auto fiveOddInts = view::ints(0) | //generates next int when asked 
  view::remove_if([](int n) { return n % 2 == 0; }) | // discard even
  view::take(5); // stop after 5
  
// when consumed, will emit:
// 13579|
```

The original STL has algorithms that take a value and return a value.
`pow(), log(), tolower(), itoa(), ...`

The original STL has algorithms that used iterators to abstract the storage of a sequence.
`copy_if, accumulate, transform, ...`

The range-v3 proposal redefines the iterator based STL algorithms so that they can also be composed.

The existing proposals for parallel computation are focused on consuming all available resources to compute a result.
`parallel_for, ...`

The existing STL has async values
`promise/future`

The asio proposal adds caller-selected future or callback

There are no algorithms for async sequences.

---
name: value

#
---
name: represent

#representing a sequence

---
template: represent

##time vs space

---
template: represent

##push vs pull

####pull
- auto v = *it;
- auto v = step(time);

####push
- o.subscribe([](auto v){});

---

template: represent

##lazy vs greedy

---

template: represent

##l

---

name: shapes

# shapes
---

template: shapes

##what is the shape of an implementation of an algorithm?

---

template: shapes

##what is the shape of the usage of an algorithm?

---
name: asio

# asio
---

template: asio

####supports multiple async contracts
- callback
- promise

**must support shape selected for algorithms.**
---

name: future

# promise/future
---

name: transducer

# transducer
---

template: transducer

####origin
Rich Hickey developed for Clojure. Very quickly other languages had implementations including JavaScript and C++.

####algorithmic interface

iterator and range provide interfaces for data traversal.

transducers use the reduce (`std::accumulate`) function `auto step(State, Value) -> State` as the interface that all algorithms implement.

---

template: transducer

####example
```cpp
auto xf = comp(
    filter([](int x) { return x > 0; }),
    map([](int x) { return std::to_string(x); }));

auto data = std::vector<int>{ ... };
auto xformed = sequence(xf, data);
```
---

template: transducer

####c++
- Juan Pedro Bolívar Puente @ cppcon 'atria::xform' [YouTube](https://www.youtube.com/watch?v=vohGJjGxtJQ), [github](https://github.com/Ableton/atria)
- my experiments [github](https://github.com/kirkshoop/transducer)

####Clojure
- Rich Hickey @ StrangeLoop [YouTube](https://www.youtube.com/watch?v=6mTbuzafcII)
- Rich Hickey [Blog](http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming)

####js
- James Long [Blog](http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data)

---

name: sfrp

# sfrp
---

template: sfrp

####Functional Reactive Programming (FRP)
Conal Elliot describes this as '**values over time**'. Conal specifies two principals that constrain the definition and 
implementation of an FRP system. 

1. **denotation** - .text[a precise language independent description of the 
whole system that can be verified without an implementation 
(one expression would be in the Lambda Calculus)]
2. **continuous time** - the system will have a valid value for any time value.

Conal continues to develop a very precise denotation that can be resolved precisely into a specification and 
various implementations. Conal vociferously defends the term FRP when applied to libraries that are not precisely 
derived from the denotation.

---

template: sfrp

####The Essence and Origins of Functional Reactive Programming
Conal Elliot @ Lambda Jam [YouTube](https://www.youtube.com/watch?v=j3Q32brCUAI)

####sfrp (c++)
David Sankel @ CppNow [YouTube](https://www.youtube.com/watch?v=tyaYLGQSr4g),[github](https://github.com/camio/sbase)
---

template: sfrp

####example

```cpp
template <typename R, typename Args...>
Behavior<R>
map(function<R(Args...)> func,
Behavior<Args>... behaviors);

Behavior<Drawing> circleFollowsMouse(
Behavior<Point2D> mousePos) {
return map(circleAt, mousePos);
}
```
---

name: rx

# Reactive Extensions
---

template: rx

Kirk Shoop

---

name: await

# async_generator and await
---

template: await

Kirk Shoop

---

# filter

```cpp
  auto filterer = [](auto pred){
    return `[=](auto step)` {
      return `stateless`(
        [=](auto s, auto v){
          if (pred(v)) {
            return step(s, v);
          }
          return s;
        },
        [=](auto s){
          return step(s);
        });
    };
  };
```

```cpp
  template<typename T, typename P>
  async_generator<T> filter(async_generator<T> s, P pred) {
    for __await(auto&& v : s) {
      if (pred(v)) {
        __yield_value v;
      }
    }
  }
```

---

# filter
```cpp
auto filter = [](auto pred) {
  return [=](auto subscriber) {
    return make_subscriber(
      [=](auto v) {
        if (pred(v)) {
          subscriber.on_next(v);
        }
      },
      [=](std::exception_ptr ep) {
        subscriber.on_error(ep);
      },
      [=]() {
        subscriber.on_completed();
      }
    );
  }
};
```
---
template: sequences

##how to represent a sequence in documentation or slides?

__values distributed__ |     __completed__  | __failed__
---------------------: |     ------------:  | ---------: 
            _in space_ |           `12467:` |         `1246#`
            _in time_  | `--1-2-4---6--7-:` | `--1-2-4---6-#`

> notation derived from the RxJS project on [github](https://github.com/ReactiveX/RxJS/blob/master/doc/writing-marble-tests.md)

???

vector and generator distribute values in space

async sources distribute values in time

* "-" time: a 'unit' of time
* ":" complete: The successful completion of a sequence
* "#" error: An error terminating the iteration of a sequence
* "1-9" number: represent that value in the sequence

    </textarea>
    <!--script src="https://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript" >
    </script-->
    <script src="./remark-latest.min.js" type="text/javascript" >
    </script>
    <script src="./CustomElements.min.js" type="text/javascript" >
    </script>
    <script src="./element.js" type="text/javascript" >
    </script>
    <script>
        var Module = {noInitialRun: false};
        var printTo = function(output) {
            return function(text){
                if (output) {
                    text = text.replace(/&/g, "&amp;");
                    text = text.replace(/</g, "&lt;");
                    text = text.replace(/>/g, "&gt;");
                    text = text.replace('\n', '<br>', 'g');
                    output.innerHTML += text + "<br>";
                }
            };
        };
    </script>
    <script src="./examples.js" type="text/javascript" >
    </script>
    <!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured" type="text/javascript" >
    </script-->
    <script src="./MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured" type="text/javascript" >
    </script>
    <script>
        var slideshow = remark.create({
            ratio: "16:9",
            highlightLanguage: "cpp",
            highlightStyle: "tomorrow",
            highlightSpans: true
        });
        MathJax.Hub.Config({
            displayAlign: "left",
            tex2jax: {
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                inlineMath: [['$','$'], ['\\(','\\)']]
            }
        });
        MathJax.Hub.Configured();
        // mathjax examples 

        // `$$ x = (-b +- sqrt(b^2-4ac))/(2a) . $$`

        // `$$ \int_{V_1}^{V_2}mVdV =  \int_{s_1}^{s_2} F_s ds $$`

        // `$$
        // A \xrightarrow{send} B
        // $$`

        // `$$
        // \newcommand{\ra}[1]{\!\!\!\!\!\!\!\!\!\!\!\!\xrightarrow{\quad#1\quad}\!\!\!\!\!\!\!\!}
        // \newcommand{\da}[1]{\left\downarrow{\scriptstyle#1}\vphantom{\displaystyle\int_0^1}\right.}
        // %
        // \begin{array}{llllllllllll}
        // 0 & \ra{f_1} & A & \ra{f_2} & B & \ra{f_3} & C & \ra{f_4} & D & \ra{f_5} & 0 \\
        // \da{g_1} & & \da{g_2} & & \da{g_3} & & \da{g_4} & & \da{g_5} & & \da{g_6} \\
        // 0 & \ra{h_1} & 0 & \ra{h_2} & E & \ra{h_3} & F & \ra{h_4} & 0 & \ra{h_5} & 0 \\
        // \end{array}
        // $$`

        slideshow.on("showSlide", function(slide) {
            if (!!slide.properties.function){
                var output = document.getElementById(slide.properties.output);
                if (output) output.innerHTML = ''; // clear contents
                Module["print"] = printTo(output);
                if (!!slide.properties.function) {
                    Module.ccall(
                        slide.properties.function, // C function
                        slide.properties.return || null, // return type
                        (slide.properties.types || "").split(','), // argument types
                        (slide.properties.arguments || "").split(',')) // arguments
                }
            }
        });
        slideshow.on("hideSlide", function(slide) {
            Module.ccall('reset', null, [], []);
        });
    </script>
  </body>
</html>
