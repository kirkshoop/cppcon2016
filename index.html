<!DOCTYPE html>
<html>
  <head>
    <title>Adding Async Algorithms to std</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      div.footer {
        position: absolute;
        bottom: 50px;
        right: 20px;
        height: 20px;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

layout: true
<div class="footer"><span>.right[&copy; 2015 Kirk Shoop ([github](http://github.com/kirkshoop) [twitter](http://twitter.com/kirkshoop))]</span></div>

---

class: center, middle

# Adding Async Algorithms to std

---
name: whyalgo

#why alogrithms?
---

template: whyalgo
## documented

the behavior, complexity and tradeoffs selected are
documented and consistent across implementations

---

template: whyalgo
## stable

the implementation is well specified and tested

---

template: whyalgo
## optimized

good tradeoffs have been selected

the implementation is minimal and efficient

the implementation was written well and tested
well by a few for the benefit of many

---
name: represent

#representing a sequence

---
template: represent

##time vs space

---
template: represent

##push vs pull

####pull
- auto v = *it;
- auto v = step(time);

####push
- o.subscribe([](auto v){});

---

template: represent

##lazy vs greedy

---

template: represent

##l

---
name: algo

#alogrithms
---

template: algo

##filter (copy_if)
---

template: algo

##transform (map)
---

template: algo

##merge
---

template: algo

##amb
---
template: algo

##withLatestFrom
---
template: algo

##scan
---
template: algo

##switch
---
template: algo

##window
---

name: shapes

# shapes
---

template: shapes

##what is the shape of an implementation of an algorithm?

---

template: shapes

##what is the shape of the usage of an algorithm?

---

name: transducer

# transducer
---

template: transducer

####origin
Rich Hickey developed for Clojure. Very quickly other languages had implementations including JavaScript and C++.

####algorithmic interface

iterator and range provide interfaces for data traversal.

transducers use the reduce (`std::accumulate`) function `auto step(State, Value) -> State` as the interface that all algorithms implement.

---

template: transducer

####example
```cpp
auto xf = comp(
    filter([](int x) { return x > 0; }),
    map([](int x) { return std::to_string(x); }));

auto data = std::vector<int>{ ... };
auto xformed = sequence(xf, data);
```
---

template: transducer

####c++
- Juan Pedro Bol√≠var Puente @ cppcon 'atria::xform' [YouTube](https://www.youtube.com/watch?v=vohGJjGxtJQ), [github](https://github.com/Ableton/atria)
- my experiments [github](https://github.com/kirkshoop/transducer)

####Clojure
- Rich Hickey @ StrangeLoop [YouTube](https://www.youtube.com/watch?v=6mTbuzafcII)
- Rich Hickey [Blog](http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming)

####js
- James Long [Blog](http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data)

---

name: sfrp

# sfrp
---

template: sfrp

David Sankel @ CppNow [YouTube](https://www.youtube.com/watch?v=tyaYLGQSr4g),[github](https://github.com/camio/sbase)
---

template: sfrp

####example

```cpp
template <typename R, typename Args...>
Behavior<R>
map(function<R(Args...)> func,
Behavior<Args>... behaviors);

Behavior<Drawing> circleFollowsMouse(
Behavior<Point2D> mousePos) {
return map(circleAt, mousePos);
}
```
---

name: rx

# Reactive Extensions
---

template: rx

Kirk Shoop

---

name: await

# async_generator and await
---

template: await

Kirk Shoop

---

# filter

```cpp
  auto filterer = [](auto pred){
    return `[=](auto step)` {
      return `stateless`(
        [=](auto s, auto v){
          if (pred(v)) {
            return step(s, v);
          }
          return s;
        },
        [=](auto s){
          return step(s);
        });
    };
  };
```

```cpp
  template<typename T, typename P>
  async_generator<T> filter(async_generator<T> s, P pred) {
    for __await(auto&& v : s) {
      if (pred(v)) {
        __yield_value v;
      }
    }
  }
```

---

# filter
```cpp
auto filter = [](auto pred) {
  return [=](auto subscriber) {
    return make_subscriber(
      [=](auto v) {
        if (pred(v)) {
          subscriber.on_next(v);
        }
      },
      [=](std::exception_ptr ep) {
        subscriber.on_error(ep);
      },
      [=]() {
        subscriber.on_completed();
      }
    );
  }
};
```
    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: "16:9",
        highlightLanguage: "cpp",
        highlightStyle: "tomorrow",
        highlightSpans: true
      });
    </script>
  </body>
</html>
