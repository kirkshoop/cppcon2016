{"version":3,"file":"context.js","sources":["./lifters/rx_delay.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/functional","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/memory","./rx_context.h","./observables/rx_intervals.h","./lifters/rx_copy_if.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/string","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/tuple","./rx_subscriber.h","./adaptors/rx_take.h","./rx_subscription.h","./rx_observer.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/atomic","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/chrono","./schedulers/rx_run_loop.h","./schedulers/rx_observe_at_queue.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__mutex_base","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/list","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/new","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__functional_base","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/typeinfo","./designcontext.h","./rx_test.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/vector","./rx_pipe_operator.h","./rx_observable.h","./rx_terminator.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/ostream","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/ios","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__locale","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/map","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__tree","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/algorithm","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/iterator","./subscribers/rx_printto.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/thread","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/iomanip","context.cpp","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/locale","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/streambuf","./rx_lifter.h","./rx_starter.h","./common.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/type_traits","./rx_start.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/set","./observables/rx_ints.h","./rx_strand.h","./lifters/rx_last_or_default.h","./lifters/rx_finally.h","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/utility","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/queue","/Users/kirk/source/emsdk_portable/emscripten/1.35.0/system/include/libcxx/__split_buffer"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;ACgqDA;AAAA;;;;;AAGA;ACmrFA;AAAA;;AAAA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;;;;;;ADrhGA;;;;;;;;;;AAgWA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;;;ACmrFA;;;;;;;AAAA;;AACA;;;;AADA;;AACA;;;;;AADA;AD3gGA;;;;;;;;;;;;;;;;;;;;AC2vFA;AACA;;;;;;;AADA;AACA;AAAA;AAAA;AAAA;;AAGA;ACthIA;AAAA;ADkhIA;AAAA;;;AACA;AAEA;;;;;;;;ADtkFA;AAAA;;;;;AAQA;AAAA;AACA;AAAA;;;AANA;AACA;;;;;;;;;;;;;;;;;AA0JA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;AAGA;;;AAqBA;AAAA;;AACA;;;AQ/jIA;AR8jIA;;;ASzkIA;;ATykIA;AACA;AAAA;;AAGA;AQlkIA;AAAA;;;;;AR+jIA;AAAA;AAAA;AAAA;AAGA;AC72HA;ADy2HA;AAAA;AACA;AAAA;AAAA;;;;AQ/jIA;AAAA;AAAA;;AR8jIA;AACA;AAAA;;;;;;;;;;AAAA;;AAGA;;AQlkIA;;AR+jIA;;AAAA;;AFhkIA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AEgkIA;AAEA;AACA;AAAA;;AAJA;AACA;AAAA;;AAAA;AAAA;AAEA;AAAA;;AC52HA;ADy2HA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AQjkIA;AAAA;AR8jIA;AAAA;AAAA;;AACA;AAEA;AAAA;;AQh0HA;AAAA;AAAA;AAAA;AAAA;AP5CA;ADy2HA;AACA;AAAA;AAAA;AAAA;;;AQ9zHA;AAAA;AAAA;;AV5PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AWhBA;AAAA;;;ATykIA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AQlkIA;AAAA;AR8jIA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;AAHA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AQlkIA;AAAA;;AR8jIA;AAAA;;;;;AAIA;;;AQj0HA;;;AP5CA;;;AD02HA;;;;;;AQ/jIA;AAAA;AR8jIA;AAAA;AAAA;;AACA;AAAA;AAEA;AACA;AAAA;;;AQj0HA;AVtPA;;;;;;;AAAA;AAAA;;AAAA;;;AEmjIA;;AACA;;;;AADA;;AACA;AAEA;ASr5HA;;ATk5HA;AACA;AAAA;AAAA;;AAGA;AAJA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AQh0HA;ACrFA;AAAA;AAAA;AAAA;;;ATkqIA;AACA;AAAA;;AADA;ADrrFA;AAAA;AAAA;AAAA;;AACA;;;;;;;AACA;AAAA;AAAA;AAAA;;ACmrFA;;;AAAA;;;AAAA;;AACA;;ADvrFA;AAAA;;;AACA;AAAA;;;;;AAEA;AAAA;AAAA;;ACmrFA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;;;AAA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;;;;;;;;ADtrFA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;;AAEA;;;;;;ACorFA;;AADA;AAAA;AACA;;;;;;;;;;;;;ADtrFA;;;;AAEA;;ACmrFA;AAAA;;;;AAAA;AAAA;;;AAAA;;;;;;;AACA;;;ACz1IA;AFkqDA;;;AACA;AAAA;AAAA;;AACA;;;ACorFA;;;;;;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;;;;;;;AADA;;AACA;;;;AADA;;;;AAAA;AAAA;AAAA;;AACA;;;;;;AAAA;;AADA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;AADA;;;AAAA;;;;;;;;;AAzSA;AAAA;;;AACA;AAAA;;;;;;AQtiIA;AAAA;;;;ARsiIA;;;;;;;;;;;AAySA;;;;;AAAA;;;ACx1HA;;ADw1HA;AAAA;;;;;;;;;;;AA1SA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;ACnjIA;AAAA;AAAA;;;ADgjIA;AAAA;;;;;AAGA;;;;;;AAJA;AAAA;AAAA;AACA;AAAA;AAEA;;AACA;AQxyHA;;AAAA;ARoyHA;;AACA;;AQtiIA;ARqiIA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;AQvyHA;;AP3QA;;;;;;;AQDA;;AAAA;ATgjIA;AACA;AAAA;AAAA;AAAA;;;;;;AQtiIA;AAAA;;ARqiIA;AACA;AAAA;AAAA;;;;;AAGA;;;ASpjIA;ATgjIA;;;AACA;;;;AAGA;;AQziIA;AAAA;;;;;;;;ARwiIA;AACA;AAAA;;AQxyHA;AAAA;;;AC5QA;AAAA;;;;ATgjIA;AACA;;;AAAA;AAEA;;;;AQxiIA;;ARqiIA;;;;;;AAGA;;ASnjIA;AAAA;AAAA;;;ATojIA;ASpjIA;AAAA;AAAA;;;;;;;;;;;;ATy1IA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;AACA;;AADA;AAAA;;;ASlqIA;AAAA;;;;;AAAA;;;;;;;;;;;;;AT03HA;;AAEA;;;AQxiIA;AAAA;ARqiIA;AAAA;;;AACA;AAEA;AAAA;;AACA;AAAA;AAAA;;AAJA;AACA;AAAA;AAAA;AAEA;AAAA;;;AQx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RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;AhBk5HA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;;ARwyHA;;;AAAA;;;AsBzgIA;;;;;;;;;AtBqgIA;AACA;;AAGA;;AAJA;AACA;;;;;AAGA;;;;AQxyHA;AV3QA;AAAA;AuBscA;AAixBA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AFtiCA;AAAA;AAAA;AAAA;Af+1DA;AAAA;AAAA;AArTA;AAAA;AAAA;AkBvsDA;AlB4/DA;AAAA;AAAA;AArTA;AAAA;AAAA;AJ02EA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AV3QA;AAAA;AsByNA;ADrCA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;;AMtIA;;;;;;;;;;AtBwhIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;AV3QA;AAAA;AAAA;;AwBuBA;;;;;;;;;AtBwhIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;AV3QA;AAAA;AAAA;ASEA;AAAA;;AeqBA;;;;;;AtBi0IA;;AACA;;AADA;;AACA;;AoBhoIA;ADrCA;AE0RA;;;;;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;;;;AhBk5HA;AACA;AAAA;;AAGA;;AAJA;AAAA;AACA;AAAA;;;;;AAGA;;;;AQxyHA;AAAA;AV3QA;AAAA;AAAA;AAAA;ASEA;AAAA;AcocA;AAixBA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AFtiCA;AAAA;AAAA;AAAA;Af+1DA;AAAA;AAAA;AArTA;AAAA;AAAA;AkBvsDA;AlB4/DA;AAAA;AAAA;AArTA;AAAA;AAAA;AJ02EA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AV3QA;AAAA;ASEA;AauNA;ADrCA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;AhB2rIA;;AACA;;AADA;;AACA;;AoBhoIA;ADrCA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;AhB2rIA;;AACA;;AADA;;AACA;;AoBhoIA;ADrCA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;;AZ6yDA;;;;;;;;AetxDA;AAAA;;AAIA;;;;;;;;AAJA;AAAA;AAAA;Af+1DA;AAAA;AAAA;AArTA;AAAA;AAAA;Ae1iDA;AZlLA;;AeqBA;;;;;;;;;;AtBwhIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;AV3QA;AAAA;AAAA;ASEA;AYkLA;AAAA;AAAA;;AAAA;;;;;;AnBoqIA;;AACA;;AADA;;AACA;;AoBhoIA;ADrCA;AE0RA;;;;;;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;;;;;AT3JA;AcqtCA;AACA;AACA;AACA;AAAA;AAAA;AFtiCA;AAAA;AAAA;Af+1DA;AAAA;AAAA;AArTA;AAAA;AAAA;AkBvsDA;AlB4/DA;AAAA;AAAA;AArTA;AAAA;AAAA;AJ02EA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AV3QA;AAAA;AAAA;ASEA;AYkLA;AAAA;Af+1DA;AAAA;AAAA;AArTA;AAAA;AAAA;AkBprDA;;AlBg6DA;;;;;;;;;AgB7uDA;;;;;;;;AhBszDA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBrgDA;;AE/KA;;;;;;;;;;;AAAA;;AF+KA;;;;;;AGhMA;;;;;;;AhBvBA;AcqtCA;AACA;AACA;AACA;AAAA;AAAA;AFtiCA;AAAA;AAAA;Af+1DA;AAAA;AAAA;AArTA;AAAA;AAAA;AkBvsDA;AlB4/DA;AAAA;AAAA;AArTA;AAAA;AAAA;AJ02EA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AV3QA;AAAA;AAAA;ASEA;AYkLA;AAAA;AAAA;Af+1DA;AAAA;AAAA;AArTA;AAAA;AAAA;AAqTA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBrgDA;AGhMA;AH+HA;AAAA;AAAA;AAAA;ADuDA;AAAA;AAAA;AAAA;AAAA;;AGxLA;;;;;;;;;;;AFkMA;;;;;;AGhMA;;;;;;;ADFA;;;;;;;;;;AFkMA;;;;;;AGhMA;;;;;;ACOA;;;;;;AJyLA;AGhMA;;;;;AHgMA;AGhMA;AHgMA;AGhMA;AHgOA;AAhCA;AGhMA;AHgMA;ADvBA;AIzKA;AJ2JA;AAcA;AnBspIA;;AACA;;AADA;;AACA;;AoBhoIA;ADrCA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;AhB2rIA;;AACA;;AADA;;AACA;;AoBhoIA;ADrCA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;;AhB4rIA;;;AAAA;;;AAAA;;;AAAA;;AoBhoIA;ADrCA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;AI4DA;ADvBA;AAdA;AE0RA;;AA1BA;;;;;;AACA;AtB6uCA;;;AACA;;;;;AAEA;;;AsBjvCA;;;;ALvRA;;AGuBA;AAcA;AE4QA;;AA1BA;;;;AtB8uCA;;;AACA;;;;;AAEA;;;AsBhvCA;;AAAA;;ALxRA;;AKiTA;;AA1BA;;;;AtB8uCA;;;AACA;;;;;AAEA;;;AsBhvCA;;AAAA;;ALxRA;;AjBqgDA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;;AoBp9CA;;;;;;;AAEA;AAAA;;AMoqBA;;;;;;;ACzaA;AAEA;AAkBA;AAkBA;AfsIA;AAnSA;;AQlIA;;;;;;;;AOkgBA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;AdtZA;AAAA;ASldA;AAAA;ArBw5CA;AAnSA;ACw3BA;AW3hDA;ASldA;AAAA;ArBw5CA;AAnSA;ACw3BA;AW3hDA;AAAA;ASldA;AAAA;ArBw5CA;AAnSA;ACw3BA;AoBn+DA;AAAA;ArB84CA;AAnSA;AsBr1BA;AACA;AAAA;ArBspDA;;AgB97DA;;;;;;;;;AK4wBA;AAAA;AACA;ADp3BA;AAAA;ArB47CA;;AACA;;;;;AqB77CA;AAAA;AAAA;ACm9BA;ADn9BA;AAAA;AAAA;ArBw7CA;;;AACA;;;AAGA;AACA;;AAAA;;;;;;;;;;AAGA;;;;;;AAAA;;;AqBh8CA;AAAA;AAAA;ACm9BA;AAAA;ADn9BA;AAAA;AAAA;ArBw7CA;;;AACA;;;AAGA;AACA;;AAAA;;;;;;;;;;AAGA;;;;;;AAAA;;;AqBh8CA;AAAA;AAAA;ACm9BA;ADn9BA;AAAA;AAAA;ArBw7CA;;;AACA;;;AAGA;AACA;;AAAA;;;;;;;;;;AAGA;;;;;;AAAA;;;AqBh8CA;AAAA;AAAA;ACyqCA;AAGA;AAAA;AAAA;AtBwcA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;AEp0CA;AAAA;;AGymDA;;;;;;;AwB/lBA;AACA;;;;AZvtCA;;;;;;;;;AZ83DA;AAAA;AAAA;AArTA;AAAA;AAAA;AiBlyCA;AACA;ArBspDA;A4BnuBA;ACwTA;AACA;AACA;AACA;AACA;;;;AACA;;;AACA;AACA;;;;;;;;;;ARziCA;AAAA;;;;;;;;;ASYA;;;;;;;;;;ACkgBA;;;;;;;;;;;;;AZt7BA;;AMypBA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;;;;;;AC7SA;;;;;;;;;;;APzfA;;AMypBA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;AA7IA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;AxBnqBA;;AGymDA;;;;;;;AwB/lBA;AACA;;;;AZvtCA;;;;;;;AZ83DA;AAAA;AAAA;AArTA;AAAA;AAAA;AiBlyCA;AACA;ArBspDA;A4BnuBA;ACwTA;AACA;AACA;AACA;AACA;;;;AACA;;;AACA;AACA;;;;;;;;;;;AJxzBA;;;;;;;AJ0kBA;AAgBA;;;;;;ADj1CA;;;;;;;AKuvBA;;;;;;AM6RA;;;;;;;;;;;;AN7RA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;ANjyBA;;AMopBA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;AA7IA;;;;;;;;;;;;ALvvBA;;;;;;;AKuvBA;;;;;;AM6RA;;;;;;;;;;;;;AN7RA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;;;;;;AC7SA;;;;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;;;;APpfA;;;;;;;;AOofA;;;;;;;;;AAAA;;;;;;;;;;;A3B28BA;;;AACA;;;;;AAEA;;;AsBhvCA;;;ALxRA;;AfoMA;;;;;;;;AwBshBA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;;;;;;AC7SA;;;;;;;;;;;;ADgKA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;AA7IA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;AxBnqBA;;AwBshBA;;;;;;;;AL90BA;;;;;;;;AK80BA;;;;;;;;AL90BA;;;;;;;;AK80BA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;AA7IA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;;AA7IA;;;;;;;;AL90BA;;;;;;;;AK80BA;;;;;;;;AL90BA;;;;;;;;AK80BA;;;;;;;;AChKA;;;;;;;AAAA;;ACziBA;;;;;;AAoZA;;;;;;ADqJA;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AEA;AACA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;AC22FA;;;AF50IA;AAAA;AAAA;AAAA;;AAAA;AE2jIA;AACA;AQ/jIA;AR8jIA;AAAA;AACA;AAEA;;AFzkIA;;;;ACs+CA;;AAEA;AAAA;AACA;AAAA;;;;;;AAGA;;;;;;;AC22FA;;AADA;AAAA;AACA;;ADvrFA;;;AACA;;;;;;AAEA;;;;;;;;;;;;;;;AqBx8CA;AhBszDA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBngDA;;AAAA;;;;;;;AAAA;;;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;;;;AAAA;ADtCA;AAAA;;ACsCA;;;;;;;;;AAAA;ADnCA;AAHA;;AAGA;;;;;;ACmCA;;;;;ADtCA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBngDA;ADtCA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AeziDA;ACsCA;AAAA;ADtCA;ACsCA;;AAAA;;;;;;;;;AAAA;ADtCA;;AAAA;;;;;;ACsCA;;;;;ADtCA;;ACsCA;;;;;;;;;AAAA;ADtCA;AAAA;;AAAA;;;;;;ACsCA;;;;;AbnNA;AAHA;AYgLA;AAAA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBngDA;ADtCA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AGztDA;AYgLA;ACsCA;;AAAA;;;;;;;;;AAAA;ADtCA;;AAAA;;;;;;ACsCA;;;;;AbtNA;AYgLA;ACsCA;;AAAA;;;;;;;;;AAAA;ADtCA;;AAAA;;;;;;ACsCA;;;;;AbtNA;AYgLA;ACsCA;;AAAA;;;;;;;;;;AAAA;ADtCA;;AAAA;;;;;;ACsCA;;;;;;AbtNA;AP0iIA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AWtFA;;ACsCA;;;;;;;;;AAAA;ADtCA;AAAA;;AAAA;;;;;;ACsCA;;;;;AbtNA;AAAA;ATQA;AAAA;AAAA;AAAA;AE2jIA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AWtFA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBngDA;ADtCA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AGztDA;ATHA;AAAA;AqBmLA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AmBpqIA;ACsCA;;AG3LA;;;;;;;;;;ADHA;;;;;;;;;AgBIA;;;;;;;;;;;AlB4LA;;;;;;;;;;AACA;;;;;;AAHA;;;;;AhBwzDA;AAAA;AAAA;AArTA;AAAA;AAAA;AJ02EA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AWtFA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBngDA;ADtCA;AAAA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AGztDA;ATHA;AAAA;AAAA;AqBmLA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;ADtCA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;;AoB9nIA;;;;;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;AAAA;;;;;;AAAA;;;;;;ADtCA;AAAA;;ACsCA;;;;;;;;;;AAAA;;;;;;AAAA;;;;;ADnCA;AAHA;;AAGA;;;;;;AAHA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;;ADtCA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AJ02EA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AWtFA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AgBngDA;ADtCA;AAAA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AGztDA;ATHA;AAAA;AAAA;AqBmLA;AAAA;Af81DA;AAAA;AAAA;AArTA;AAAA;AAAA;AeziDA;AAAA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;ADtCA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;AG3LA;;;;;;;;;AHqJA;;;;;;;;;;AACA;;;;;;ADDA;AAAA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;;ADtCA;AAAA;Af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;;AACA;;AADA;;AACA;;AADA;;;;;;;;;;;;AACA;;;;;;;;;;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;AuC/zIA;;;AvC+zIA;;;AuC/zIA;;;;ApB2JA;AAAA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;ADtCA;AAAA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;;;ADtCA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;;;;;;;ADtCA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;;ADtCA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;;ADtCA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;AoB9nIA;;;;;;ADtCA;ACsCA;ApB6nIA;;AACA;;AADA;;;;;;;AACA;;;;;;;;;;AmBpqIA;ACsCA;ApB6nIA;;AACA;;AADA;;AACA;;;;;AmBpqIA;ACsCA;ApB6nIA;;AACA;;AADA;;;;;;AACA;;;;;AmBpqIA;ACsCA;ApB6nIA;;AACA;;AADA;;;;;;AACA;;;;;;AADA;;AACA;;AADA;;AACA;;AmBpqIA;ACsCA;;;;;;;;;;ADtCA;ACsCA;;;;;ADtCA;ACsCA;;;;;ADtCA;ACsCA;ADtCA;ACsCA;;;;;ADtCA;ACsCA;;;;;ADtCA;ACsCA;;;;;;AAAA;;;;;;;;;;AAAA;;;;AAAA;;;AAAA;;;;;;;;;;;AlBvNA;;AACA;;;;;;;;;;AF0iIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;;AE7iIA;;;;;;;AFm1IA;;;;;;;;AAAA;;;;;;;AAAA;;;AAAA;;;AEl1IA;;;;;;;;;;AIwBA;;;;;;;;;AH5BA;;;;;;;;ACi7HA;;;;;;;;;;AAj6DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AFpNA;;;;;;AE0KA;AF1KA;AAAA;;AACA;;;;;;;;AG2BA;;;;;;;;;;ACzBA;;;;;;;;AH86HA;;;;;;;;;;AAj6DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AEjNA;;;;;;AFuKA;AEvKA;AAAA;;AACA;;;;;;;;ADwBA;;;;;;;;;;AR3BA;;;;;;;;;AACA;;;;;;;;;AE0iIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;;AF7iIA;;;;;;;AEm1IA;;;;;;;AAAA;;;;;;AAAA;;;AAAA;;;AFl1IA;;;;;;;;;;AAAA;;;;;;AC2pDA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AA1SA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;ARoyHA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;AV9PA;AAAA;AEkiIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;ARoyHA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;AVxPA;AAAA;AE4hIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;ARoyHA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;AVlPA;AAAA;AEshIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAqBA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AQ9zHA;AR6zHA;AACA;AADA;AACA;AQ9zHA;AVlQA;AAAA;AE+jIA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AQ9zHA;AR6zHA;AACA;AADA;AACA;AQ9zHA;AV5PA;AAAA;AEyjIA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AQ9zHA;AR6zHA;AACA;AADA;AACA;AQ9zHA;AVtPA;AAAA;;AEo0IA;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AA1SA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AO3iIA;;ACyUA;;;;;;;;ARwgIA;;;;;;;AAAA;;;;;AAAA;;;AAAA;;;AOh1IA;;;;;;;;;;AH26HA;;;;;;;;;AAj6DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AE9MA;;;;;AFoKA;AEpKA;AAAA;APsiIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;AC3CA;AADA;ATg1HA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAqBA;AACA;AADA;AACA;AQ9zHA;;AR8kIA;;;AAAA;;;;;;;;;ASrxIA;;;;;AAvCA;;;;;;;;AAbA;AAAA;;AAqEA;;;;AArEA;;AAAA;;;;;AAAA;;ATw0IA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;;;;;;;ATy3HA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAqBA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AR6zHA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AVlQA;AAAA;AAAA;AE+jIA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AR6zHA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AV5PA;AAAA;AAAA;AEyjIA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AR6zHA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;AVtPA;AAAA;AAAA;AEmjIA;AACA;AAAA;AAEA;AACA;AAJA;AACA;AAAA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AAJA;AACA;AAEA;AACA;AQj0HA;ACrFA;AAAA;ATkqIA;;AACA;;AADA;;AACA;;AOp0IA;AR6oDA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AGp1IA;;;;;;;;;AC+6HA;;;;;;;;;AAj6DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AFlNA;;;;;AEwKA;AFxKA;AAAA;AH0iIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;ASpjIA;ATgjIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;AC5QA;ATgjIA;AACA;;AAGA;;AAJA;AACA;;AAGA;AAsSA;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;AV4+CA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AAzSA;;AAGA;;AAHA;;AAGA;;AAHA;;AAGA;;AAHA;;AAGA;;AAHA;;AAGA;;AAHA;;AAGA;;AQxyHA;ANlQA;AAAA;AS0VA;AAAA;AT1VA;;ADgYA;;;;;;;;ADsqHA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQnuHA;AAAA;AAAA;;AACA;;;;;;;;ARwgIA;;;;;;;AAAA;;;;;AAAA;;;AAAA;;AA1SA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;AC3CA;AT+0HA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAqBA;AACA;AADA;AACA;AQ9zHA;APmIA;AAAA;AQ/YA;ATgjIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;APmIA;AAAA;AQ/YA;AAAA;AAAA;ATgjIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;APmIA;AAAA;AQ/YA;ADqRA;;AM7KA;;;;;;;;;;AF0BA;;;;;;;AJmJA;AR2xHA;AACA;;AAGA;;AAJA;AACA;;AAGA;;;AgB95HA;;;;;;;AhBosIA;;;;;;;;AAAA;;;;;;AAn1BA;AAiBA;AAuFA;AS//GA;AAhHA;ATgjIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;APmIA;AAAA;AAAA;AQ/YA;AAAA;AAAA;AISA;AAAA;AbuiIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;AAGA;;AYj7HA;;;;;;AZutIA;;AAAA;;;AAAA;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;;AAAA;;;AAAA;;AAAA;;AAAA;;;AAAA;;;AYttIA;;;;;;;;ARk0HA;;;;;;;;;AAl7DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AOpFA;;;;;AP0CA;AO1CA;AAAA;AACA;AEPA;;Ad4tIA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;;ATmqIA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;;ATmqIA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;;ATmqIA;;;AAAA;AAtSA;;;AAAA;;;AAsSA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;AEh1IA;;AFg1IA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;AA1SA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AExiIA;;AF80IA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;AADA;;AACA;;AADA;;AE70IA;;;AF80IA;AE90IA;;;;AUwHA;;;;;;;;;;;;;;;;;AENA;;;;;;Ad4tIA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;;ATmqIA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;;ATmqIA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;;ATmqIA;;;AAAA;;;AAAA;;;;;;;AAAA;;;;;;AAAA;;;AAAA;;;;;AEh1IA;;AFg1IA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;AE90IA;;;;;;ACNA;;;;AHm1IA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;;;;;;AF7KA;;;;;AP+0IA;;AACA;;AADA;;;;;;AACA;;;;;AOp0IA;;;;;;APm0IA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;AADA;;AACA;;AADA;;AACA;;;;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;;AOn1IA;;;;;;;;;;;;;AR4pDA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;;AGt1IA;;;;;;;;;;;;;AJ+pDA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;AACA;;;;;ADvrFA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;AACA;;;;;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;;;AADA;;AACA;;AADA;;;;AACA;;;;;;;;;;;AY1uIA;;AATA;;;;;;;;;;A4B5FA;AxC+jIA;AAAA;;AyC9nBA;;AzC64BA;;AQ90IA;AR8jIA;;AAGA;;AyChoBA;AADA;AACA;AAAA;;AD77GA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;;AxC00IA;AAAA;AAAA;;;;AwC10IA;;;AAAA;;AACA;;;;;;;;;;A1B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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AmBlrIA;;AAEA;;;AR2kBA;;;;AQ3kBA;;;;;;;AnB+qIA;AAAA;;;AAAA;;AAAA;;;;;;;;;;AAAA;;;AAAA;;AACA;;AW94HA;;AS/SA;;AAAA;AAAA;AAAA;;;;ArBw5CA;AYz6BA;AAAA;AS/eA;AAAA;ArBi5CA;AAOA;AAnSA;AYtoBA;AAAA;AS/eA;AAAA;AAAA;ArBi5CA;AC4lBA;AoB7+DA;AAAA;AAAA;AAAA;ApB6+DA;AoB7+DA;AAAA;AAAA;AAAA;ArBqnCA;ACw3BA;AAAA;AqB3sDA;;;;;AAmeA;AACA;ArB6uCA;AoBjmEA;AAAA;ArB67CA;AAAA;;;AqB77CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ArBw7CA;;AACA;AAAA;;AAIA;AAAA;AAAA;;;;;;;AAGA;;;AqBh8CA;AAAA;AAAA;AAAA;ACm9BA;ADn9BA;AAAA;AAAA;AAAA;AAAA;ArBw7CA;;AqBx7CA;ArB07CA;;AAGA;AAAA;;;;AAGA;AAAA;;;AAAA;AqBh8CA;AAAA;AAAA;AAAA;AAAA;ACm9BA;AAAA;ADn9BA;AAAA;AAAA;AAAA;ArBw7CA;AAAA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;;;;AAGA;;;;AAAA;AqBh8CA;AAAA;AAAA;AAAA;AAAA;ACm9BA;AAAA;ADn9BA;AAAA;AAAA;AAAA;AAAA;;;AAAA;ArB07CA;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;;;;AAAA;;AqBh8CA;AAAA;AAAA;AAAA;AAAA;AAAA;ACm9BA;AD30BA;;;;;ACiiCA;;AACA;;ArBu7BA;;AAAA;AqBt7BA;;AjBivBA;;;;;;;AetxDA;;AAIA;;;;;;;;AAJA;;;AAAA;;;;;;;;;;;;AG1IA;;;;;;;;;;;;;;;;;;AD0YA;;;;;AACA;;AtB6uCA;AAAA;;AACA;;AAAA;AAAA;;;;AAEA;AAAA;;;;AsBjvCA;;;;;AA6BA;;;;;;AAXA;AAixBA;;AACA;;AACA;ArBs7BA;;AqBr7BA;;AFtiCA;AAAA;;;AEgQA;;;;;;AACA;;;AtB6uCA;;;;;;AACA;;AACA;;;AACA;;;;;;AsBjvCA;;;;;;;;;;;AjBshDA;;;;;;;AgB7uDA;;;;;;;;;AhBigDA;;;AgB7iDA;;;;;;;;;;;;ADGA;;;;;;;;;AE0RA;;;;;;AA1BA;;;;;;;;;AACA;;;AtB6uCA;;;;;;AACA;;;AACA;;;;AACA;;AAAA;;AsBjvCA;;;;;;;;;;;;;AC1YA;;AF+KA;;;;;ADrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AEgQA;;;;;AACA;ADvYA;;ArBonDA;;AACA;AAAA;;;;;AAEA;;;;;;;;AiBxgDA;;;;;AK0jCA;AACA;;ArBu7BA;;AqBt7BA;AACA;ACnsCA;AH6JA;Af0iDA;AAqTA;AgB1zDA;ADrCA;AE0RA;AA1BA;;;;AACA;AtB6uCA;AACA;AAAA;;;;AAEA;AAAA;;AsBjvCA;;;;;ALvRA;AI8NA;ApBurHA;;AAHA;AACA;;;AQryHA;ARwyHA;;;AsBzgIA;;;;;AtBqgIA;AAIA;AAJA;;AACA;;;;;AAwBA;;;;AQ7zHA;;AV3QA;;AAAA;;AuBscA;;AAixBA;;AACA;;AACA;ArBs7BA;;AqBr7BA;;ACnsCA;;AH6JA;;Af+1DA;AArTA;;AAqTA;;AkB5/DA;;AtBkjIA;;AAAA;;AQ/jIA;;AR+jIA;;AAGA;;AQj0HA;;AV3QA;;AAAA;;AsByNA;;ADrCA;;;;AEgQA;;;;;;ADtYA;;ArBonDA;;;;AACA;;;;;;AAEA;;AAAA;;;;AsBjvCA;;;;;;;;ALvRA;;AMtIA;;;;;;;;AAAA;;AtBwhIA;;AACA;;;;AQtiIA;;ARsiIA;AAAA;AAEA;AAAA;;;AQvyHA;AAAA;AAAA;;AV3QA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AwBuBA;;;;;;;;;;;AtBwhIA;AAAA;AACA;AAAA;AAAA;;AAGA;;AQziIA;ARqiIA;;AACA;;AAEA;AACA;;AQxyHA;AAAA;AV3QA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;AEw1IA;;AACA;;AoBhoIA;ACqPA;;;AA1BA;;AACA;AAAA;ADvYA;;ArBqnDA;AAAA;;;AAEA;AsBjvCA;;;;ALvRA;;;AhBk5HA;AACA;;AQtiIA;ARsiIA;AAAA;AAEA;AACA;;AQxyHA;AAAA;AV3QA;AAAA;AAAA;AAAA;AAAA;AuButCA;AAAA;AACA;AACA;AACA;AFtiCA;AAAA;AAAA;AG7JA;AtBijIA;AAAA;AACA;AAGA;AAJA;AAGA;AQh0HA;AV3QA;AAAA;AAAA;AsByNA;;AC2NA;AAAA;;ADtYA;ArBonDA;AAAA;AACA;;AACA;;AACA;;;;;;ACmrFA;AAAA;;AAAA;AACA;;;AmBrqIA;;AE0RA;;AA1BA;;AAAA;;;;;;ADtYA;;ArBonDA;;;;AACA;;;;;;AAEA;;AAAA;;;;AsBjvCA;;;;;;;;ALvRA;;AhB2rIA;;AACA;;AADA;;;;;;AmBpqIA;AAAA;;;AE0RA;;AA1BA;;;AAAA;;;;AACA;;AtB6uCA;;;;AACA;;;;;;AAEA;;;;AsBjvCA;;;;;;;;;;;;;;AFhQA;;AAIA;;;;;;AAJA;;AAAA;;AG7JA;;AAAA;;;;;;;;AtBwhIA;;AACA;;AAGA;;AAJA;;AACA;;;;AQryHA;;AV3QA;;AAAA;;;AAAA;;;AAAA;AAAA;;;AAAA;ASEA;AAAA;;;;AYkLA;;;;;;;;;;;AnBoqIA;;;;;AAAA;;;;AmBpqIA;;AE0RA;AAAA;;;;;;;;AA1BA;AAAA;;;;;;ADtYA;;ArBonDA;AAAA;AAAA;;;;;AACA;;;AACA;;;;;;AACA;;;;;;;;;;;;AsBptCA;;;ALpTA;;;;;;AT3JA;;;AcqtCA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;;AAAA;AAAA;ACnsCA;;;;;;AlBusDA;;;AAqTA;;;AJqjEA;;;AACA;;;AAGA;;;AAJA;;;AACA;;;AQ9zHA;;;AV3QA;;;AAAA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;ASEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;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AA;;;;;ACsCA;;;;;;;;AAAA;;;;;;;;;;AAAA;AAAA;;;ADtCA;;;AAAA;;;;;;;;;AZ7KA;AAAA;;AY6KA;AAAA;AAAA;AAAA;;;ACsCA;AAAA;AAAA;;ADtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;Af81DA;AArTA;AAAA;;AeziDA;ACsCA;AAAA;;;;;;;;;;;AAAA;;AAAA;ADtCA;;AAAA;;AAAA;;;ACsCA;;;AbtNA;;AYgLA;;ACsCA;;;;;;;AAAA;ADtCA;;AAAA;;AAAA;;;ACsCA;;;AbtNA;;;AYgLA;;;;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;AZhLA;;AP0iIA;;AACA;AAAA;AAAA;;;;;AADA;AACA;AAAA;;AQryHA;AAAA;AAAA;AWtFA;;;;;ACsCA;ADtCA;;AAAA;;;;ArBxKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AE4jIA;AAGA;AQlkIA;AR8jIA;AACA;AQ9zHA;AAAA;AVzQA;AqBmLA;ACsCA;ADtCA;AAAA;Af81DA;ANjhEA;AAAA;AAAA;AAAA;AEs1IA;;;;;AsB3zIA;;;;;;;;;;;;AF8LA;;;;;AAAA;ApB82HA;AAAA;AAAA;AQ/jIA;AR+jIA;AAAA;AAAA;AQ9zHA;AWtFA;ACsCA;AAAA;ADtCA;AfyiDA;AGztDA;ATHA;AAAA;AAAA;AAAA;AAAA;AAAA;AsByNA;;ApB8nIA;;AAAA;AmBpqIA;ACsCA;AAAA;;ApB6nIA;;;AoB7nIA;;;AAAA;;;;;;AAAA;;;;;;;;;AAAA;;;;;AAAA;;;;ADtCA;;;;;;;ACsCA;;;;;ADnCA;;AAAA;;AAAA;;;;;;;;;ACmCA;;;ApB6nIA;;;AACA;;;AADA;;;AACA;;;;;;AmBpqIA;;;Af81DA;;;AJqjEA;;;AACA;;;AAEA;;AAHA;AAAA;AACA;AAAA;;AAAA;AAGA;AAAA;;AQj0HA;AAAA;AAAA;AAAA;;;AWtFA;AAAA;AAAA;;AfyiDA;AAAA;AAAA;AgBngDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;ADtCA;AAAA;AAAA;AAAA;AAAA;;;AZhLA;AAAA;AAAA;AAAA;ATHA;;AAAA;;AAAA;AAAA;;AAAA;;A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AAA;;;AAAA;;;AAAA;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AsB1xIA;;;AtB0xIA;AsB1xIA;;;;AVoEA;;;;;;;;;;;;;;;AENA;;;;ALyDA;ATkqIA;;AACA;;AADA;;AACA;;ASnqIA;AAAA;ATkqIA;;AACA;;AADA;;AACA;;ASnqIA;AAAA;ATkqIA;;AACA;;AADA;;AACA;;ASnqIA;AAAA;ATkqIA;;AACA;;AADA;;AACA;;ASnqIA;;ATmqIA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;ATkqIA;;AACA;;AADA;;AACA;;ASnqIA;ATkqIA;;AACA;;AADA;;;;;;;;;;;;AACA;;;;;;;;;;;A4ChzIA;;;;;;;;;;;;AzCpCA;;;;;AHo1IA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;;;;;;AqChLA;;;;A9Ck1IA;;AACA;;AADA;;;;;;AACA;;;;;A8Cz0IA;;;;;;AAbA;;;;;;;;A9Cs1IA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;AAAA;;;;;;AGt1IA;;;;;;;;;;;;AHs1IA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;;AAAA;;;;;;AADA;;AACA;;AADA;;AACA;;;;;;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;;;AAAA;;;;;;;;;;;ADn3FA;;;AACA;;;;;AAGA;AACA;;;;;AAGA;AAAA;;;;;;;;;AAPA;;;;;;AAGA;;AACA;;;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;;;;;;;;;;;;AAJA;;AACA;;;;;;;;;;;AAGA;;;;AAAA;;;;;;;;;;;;;;;;AAPA;;;;;;;ACwkFA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;;AAGA;;AACA;;;;;;;;;;;AAGA;;;;AAAA;;;;;;;;;AC02FA;;AACA;;AADA;;;;;AACA;;;;;;;;AF50IA;AAAA;AAAA;AE2jIA;AACA;AAAA;AAEA;AACA;AAJA;AACA;AAAA;AAEA;AACA;AQj0HA;AVzQA;;;ACq+CA;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;AACA;;ADvrFA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;;;;;AACA;;;;;;AFv1IA;AAAA;AAAA;ACgqDA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;AACA;;;AAEA;;;AC04EA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;;;;AACA;;;;;;;;AFv1IA;AAAA;AAAA;AE6iIA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;;;AAGA;;AACA;;;;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;;;AC02FA;;AACA;;AADA;;;;;;;AACA;;;;;;;AFv1IA;AAAA;AAAA;ASGA;APmkIA;AACA;AAAA;AAEA;AACA;AAJA;AACA;AAAA;AAEA;AACA;AQj0HA;AVzQA;;;ACq+CA;;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;AACA;;;;;;;;AFv1IA;AAAA;AAAA;ASGA;AP0iIA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;;;;;AACA;;;;;;;AFv1IA;AAAA;AAAA;ASGA;AP0iIA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;;;;;;AACA;;;;;;;AFv1IA;AAAA;AAAA;ASGA;AP0iIA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;;;;;;AACA;;;;;;;;AFv1IA;AAAA;AAAA;ASGA;AP0iIA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;;;AAGA;;AACA;;;;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;;;AC02FA;;AACA;;AADA;;;;;;AACA;;;;;;;AFv1IA;AAAA;AAAA;ASGA;APmkIA;AACA;AAAA;AAEA;AACA;AAJA;AACA;AAAA;AAEA;AACA;AQj0HA;AVzQA;;;ACq+CA;;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;;;;;AACA;;;;;;AFv1IA;AAAA;AAAA;ASGA;AR6pDA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AA1SA;AACA;AAAA;AAAA;;AAGA;;AAJA;AACA;AAAA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;;;;;AACA;;;;;;;AFv1IA;AAAA;AAAA;ASGA;AP0iIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;ARoyHA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;AVzQA;ACo+CA;;;AACA;;;;;AAGA;;AACA;;;;;;;;;AAGA;;;;;;AAAA;;;;;;;AC02FA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;;;AFv1IA;AAAA;AAAA;ASGA;ALIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AqC8BA;;;;;;AxC2nDA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;AAHA;;;AACA;;;;;AAEA;;;;AwCzpDA;;;;;;;;;AxCiiDA;;AiBx5CA;;;;;;;;;AjB0oCA;;AC02BA;;;;;;AgB5+DA;;;;;AjBi6CA;AAoGA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;ADrgGA;;;ACsgGA;ADtgGA;;;;AA+UA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;AACA;;;;ADvrFA;;;AACA;;;;;AAEA;;;ACmrFA;;AACA;;AADA;;;;;;AACA;;;;;ADvrFA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A;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AmBtxIA;;;;;;AnBqxIA;;AACA;;AADA;;;;;;AACA;;;;;AADA;;AACA;;AADA;;AmBpxIA;;;AnBqxIA;AmBrxIA;;;;;AP+DA;;;;;;;;;;;;;;;AENA;;;;ALyDA;ATkqIA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;AAAA;ATkqIA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;AAAA;ATkqIA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;AAAA;ATkqIA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;;ATmqIA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;ASnqIA;ATkqIA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;ASnqIA;ATkqIA;;AACA;;AADA;;;;;;;;;;;;AACA;;;;;;;;;;;AADA;;AACA;;AADA;;AACA;;ASnqIA;;;;;;;;;;;;ANjLA;;;;AAIA;;;;;;AANA;;;;;;;;;;;;AHs1IA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;;AAAA;;;;;;AADA;;AACA;;AADA;;AACA;;;;;;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;;;AACA;;;;;AADA;;;;;AACA;;;;;AADA;;AACA;;AADA;;;;;AACA;;;;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;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iIA;;ARsiIA;;AAGA;;;AQxyHA;;;;;;;;;;;;;;;;;;;;;ARqyHA;;;AAGA;;;AAJA;;;;;;;A4CvhIA;;;;;;;A5Ci0IA;;;;;;AAAA;;;;;;;;;;;;AAzSA;;;;AQtiIA;;ARsiIA;;;;;AChjIA;;;ADgjIA;;;AAGA;;;AAJA;;;;;;;AQriIA;ARqiIA;AACA;AAAA;;;;;AQryHA;;;ARwyHA;;AAAA;;;;AGhjIA;;;;;ACi7HA;;;;;;;AC7tHA;;;;;AFpNA;AHgjIA;AAAA;;;;;AAAA;AAAA;;;;;;;;;;;A8ChjIA;;;;;;;A1Ci7HA;;;;;;;;;AAj6DA;;;;;;;;;;;ACt2DA;AyC1KA;AACA;;A9C4iIA;;;AADA;;;;;AC/iIA;AD+iIA;AAAA;;;;AQriIA;;;ARsiIA;;;;AQryHA;AAAA;AP3QA;;;;;AOUA;ARsiIA;;;;;;;;;;AAySA;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;AA1SA;;;AAAA;;;;;AQriIA;;ARsiIA;;;;;A8C3iIA;;AtC4UA;;;;;;;;ARwgIA;;;;;;AAAA;;;AAAA;AAAA;AAAA;;;;;AAAA;;;;A8Cn1IA;AAAA;;;;;;;A1C86HA;;;;;;;;AAj6DA;;AC5zDA;;;;AyCjNA;;;;AAAA;;A9C0iIA;;AAGA;;AQziIA;ARsiIA;;;;AADA;;AACA;;AAGA;;AAJA;;AACA;;AAGA;;AQxyHA;;;;;;ARoyHA;;AACA;AAGA;;AAJA;;;;ASh1HA;;AT02HA;;AAAA;;AQ9zHA;;AR8zHA;;AADA;;AQ7zHA;;AR8kIA;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIraA;;;;;;AAj6DA;;AC5zDA;;;;AFlNA;;;;AAAA;;;;;;;AH0iIA;;;;;;AQriIA;;;ARsiIA;;;AAySA;;;AAAA;;;;;;AAAA;;;;;;;;;;;;;ASnqIA;;;;;;;;;;;;;;;;;;;;;;;;;;ATy3HA;AACA;;;;AQtiIA;;ARsiIA;;AAEA;;;;A4CxhIA;;;;;;;;;;;;;;;;;A5CqhIA;;AAGA;;;;AAFA;;;;AADA;;AACA;;AAEA;;;;AAHA;;AACA;AAAA;;;;AQryHA;;AAAA;;AoC1OA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AA;;;ADvrFA;AAAA;;;AACA;;AAAA;;;;;;;AAEA;AAAA;;;ACmrFA;;;;;AAAA;AAAA;;AACA;;ADvrFA;AAAA;AAAA;;;;;;AAGA;;AAAA;;ACmrFA;;AACA;;;AADA;AACA;;;;;;;ADtrFA;AAAA;;;AAEA;;;;ACmrFA;AAAA;;AACA;;ADvrFA;AAAA;AAAA;;;;;;AAGA;;AAAA;;ACmrFA;;AACA;;;AADA;AACA;;;;;;;ADtrFA;AAAA;;;AAEA;;;;ACmrFA;AAAA;;AACA;;ADvrFA;AAAA;AAAA;;;;;;AAGA;;AAAA;;ACmrFA;;AACA;;;AADA;AACA;;;;;;;ADtrFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;;ACmrFA;;;;;ADrrFA;AAAA;AAAA;;AACA;;;;;;;ACqrFA;;AADA;;;;ADtrFA;;;AACA;;AAAA;;;;;;;AAEA;AAAA;;;ACmrFA;;;;;ADrrFA;AAAA;AAAA;;AACA;;;;;;;;;AADA;;AAAA;AACA;;;AACA;AAAA;;AAAA;;;;;;;;;;;AAxHA;;;;;AC4lBA;;;;;;AgB5+DA;AAAA;;;;AjBsgDA;;AAAA;;;;;AAEA;AAAA;AAAA;;;ACmrFA;;;;;;;AAAA;;;AAAA;;;AAAA;;ADtrFA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;;;ACqrFA;;AAAA;AACA;;AADA;AAAA;;;;AAAA;;;;;;AAAA;ADrgGA;AAAA;;;;;AA+UA;;;;;;AACA;;;;AAEA;AAAA;;ACmrFA;;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;;;;AACA;;;;AFv1IA;ACgqDA;AAAA;;AACA;AAAA;;AAAA;AACA;;;;;;AACA;AAAA;;;ACmrFA;;;AACA;;AAAA;;AADA;AAAA;AAAA;;;;;;;;;ADrrFA;;AAAA;AACA;;;AACA;AAAA;;AAAA;;;;;;;;ACmrFA;;;AACA;;;ADtrFA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAHA;;;;AACA;AAAA;;;;;;;AAEA;AAAA;;ACmrFA;AACA;;;;;;;;;;ADvrFA;AAAA;;;;;;AAGA;;AAAA;;;ACmrFA;;AACA;;AADA;;;;;;;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AAAA;AAEA;AQjkIA;AR+jIA;;;AAAA;;;;AoBx2HA;AAAA;;ApBu2HA;;;;AACA;;AQ/jIA;;;;;APmSA;;AD2xHA;AACA;AQ9zHA;APkCA;AD2xHA;AACA;AAAA;AAGA;AAJA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AQj0HA;AAAA;AAAA;;ACrFA;;;AWiDA;AAAA;;;;ApBk2HA;AC5xHA;AAAA;;AD4xHA;;AADA;AACA;AAAA;;AQ9zHA;;APkCA;;AD2xHA;AAAA;;;AACA;AAEA;AQjkIA;AR8jIA;;;;AAGA;;;AQh0HA;;ACrFA;AD5KA;AR+jIA;;;AAGA;AC/xHA;AD2xHA;AACA;AAAA;AAAA;;AQ/jIA;AR8jIA;AACA;AAAA;AAEA;;;AQh0HA;;;AR8zHA;;AQ/jIA;AAAA;;AR+jIA;AAAA;;AAEA;;;;ASr5HA;;;ATm5HA;AAAA;;;;AQ/jIA;;AR8jIA;AACA;AAAA;AAGA;;;;;AmBr5HA;AnBi5HA;AAAA;;AAIA;AQlkIA;AR8jIA;AACA;AAAA;;;AAGA;;;;;AAHA;;AAEA;AACA;AQlkIA;AR8jIA;AACA;AAGA;AQj0HA;AAAA;;;AR6zHA;AAAA;AACA;;;;;;;;AuBziIA;AAAA;;;;;;;;;;;AHqJA;AAAA;;;;;;;;;;;;;AACA;;;;;;ADDA;;ACsCA;ApB6nIA;;;;;AACA;;;;;;AIt0EA;;AJqjEA;AACA;AAAA;;;AQ/jIA;AAAA;;;;;;;AR+jIA;AAAA;;;;AQ9zHA;AAAA;;;AWtFA;AAAA;;;;;ACsCA;;ADtCA;Af81DA;;;AG9gEA;;;;ATHA;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;AMihEA;;;;;;;;;AiB1zBA;;;;;;AFpiCA;AAAA;;;AnBoqIA;AAAA;;;;;AAAA;;AmBpqIA;AnBmqIA;;;;;;;AACA;;;AoB9nIA;;AAAA;AAAA;;ApB6nIA;AAAA;;;;;;;;;;;;AACA;;AoB9nIA;ApB6nIA;;AACA;;;AADA;;;AmBnqIA;;;;AnBoqIA;;;;;;AmBpqIA;AnBmqIA;;;;;;AAAA;AAAA;;;;;;;;;;AoB7nIA;;;;;ApB6nIA;;AACA;;;;AoB9nIA;;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AA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;A6C9qIA;;AAAA;AAAA;;;;;;;;;;;A9Cu/CA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;ACmrFA;AAAA;;;AAAA;AAAA;;;;;;;AACA;;;;ADvrFA;AAAA;;;;AACA;;;;AAEA;AAAA;;;;;;;;;ACyqEA;;;;;ADznEA;AAAA;AAAA;AAAA;AAAA;;;;;AUrsDA;AAAA;;;;;;;ACgzBA;;;;;;;;;;ADhzBA;AAAA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ATwzHA;AU5gGA;;;;ADlpBA;;;;;;;;;;;;;;;;;;;;;AA1JA;;;;;ATmzHA;AAAA;AAAA;AAAA;;;;;;;;;;AUngGA;AAAA;AAAA;AAAA;;;;;;;;ADhzBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATw0IA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;;AACA;;AADA;AAAA;AAAA;;AACA;;AADA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;AoBnlIA;AAAA;AAAA;;ArBsjCA;AAAA;;;;;AC4hGA;;;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;AACA;;;AADA;AACA;AAAA;;;;;;;;;AADA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;AgB3rIA;;;;;AhBk/DA;AAAA;;;;;;;;AkBrhEA;;;;AnBquCA;;;;;;;;;;;;;;;;AE3/BA;;;AmBnVA;;;;AAAA;;AAsPA;AAAA;AAAA;AAAA;;;;AAAA;AT4fA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;APgxCA;AAAA;AAAA;AAAA;;;;;;;;AI/vDA;APgFA;AAAA;AAAA;AAAA;;;;;;AU+ZA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;APw8BA;AAMA;AAAA;AAAA;AAAA;;;;;;AAq4BA;;;;;;;;;;;;;;;;;;;;;;;;;;ACz6EA;;;;;;Ae2FA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AZYA;;;A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AAA;;;AACA;;AADA;AAAA;;AACA;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;;AADA;;;;AAAA;;;;AAAA;;;;AACA;;AAAA;;AAAA;;;;;;;AAAA;;;AAAA;AAAA;;AmBhuIA;;;;;AnB+tIA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;AACA;AAAA;;;;;AADA;;;;;AAAA;;AmB9tIA;;;;;;;;;;;;;;;AnB8tIA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AACA;;AADA;AACA;;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvSA;AACA;;AAJA;AAGA;;;;AWp8GA;AXq8GA;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAJA;AACA;AAEA;AAAA;;;AWvmHA;;AXwmHA;;;;;AAAA;;;;;;;AAAA;;;;;;;;AADA;;;;AAAA;;AACA;;AS/1HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVg9CA;;;;ACqrFA;ADvrFA;;AACA;;;;;AACA;AAAA;;;;;ACqrFA;AADA;AAAA;AAAA;;;;;;ADrrFA;AAAA;AAAA;;;AACA;;AACA;;ACmrFA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;ADtrFA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;;;;;;;AEt2CA;AAAA;AAAA;;;;;;;;;;;;ADyhIA;AAAA;;;;;AC5hIA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AD6hIA;AAAA;;;;;;;;;;;;;;;;;;;AQrkIA;AAAA;;;;;AYnQA;AAAA;;;;;;AyB0JA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;A9Cu/CA;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;ACmrFA;;;;;;;;;;;;;;;;;;;;;;;;;ADrrFA;;;AAEA;;;;;;;;;AC24EA;AAAA;;AADA;AAAA;;;AACA;AAAA;AAAA;;;AAGA;;;;;;;;;;;;;A6C98HA;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;ApCuDA;AVsgDA;AACA;AAAA;AAAA;;;;;;;;;;;;ACqrFA;AAAA;AAAA;;;;;AACA;AAAA;;;;;ADvrFA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;ACqrFA;AAAA;;;;;;;A6ClvIA;;;;;;;;A7C08HA;AAAA;;;;;;;;;AADA;AAAA;;;;;;;;;;ADxkFA;;;;AUx+CA;;AVy+CA;AAAA;AAAA;AAAA;;;;AAGA;;;AAAA;;AAAA;;;;;;AU5+CA;AAAA;;;AAAA;;AV++CA;;;AAAA;;;;;;;AC02FA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AQpkIA;;;AY0FA;AAAA;;APtWA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AbwiIA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;AQxiIA;;ARqiIA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;;;AAGA;;ASl7HA;;AT+6HA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI7GA;AAAA;AAAA;;;;;;;;;AAl7DA;;;;;;;;;;;;;;;;;;;;;;;;;;;ASz8DA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AA3EA;;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AbijIA;;;AAGA;AAAA;AAAA;;;AAJA;AAAA;AAAA;AAAA;;;;;;;;AAGA;;;;;;ASj7HA;AT86HA;;;;;;AACA;AAAA;;;;;;AajjIA;;;;;;;;;;;;AAAA;;AmC6SA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;A3BuxCA;;;;;;;;;ARpkDA;AAAA;AAAA;AAAA;;;;;;AbijIA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;AajjIA;AAAA;;AQ2kDA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ArB+wFA;AAAA;AAAA;;;;;;AAAA;;;;;;;;;AiD5sHA;AAAA;AAAA;AAAA;;;;;;AnBglIA;AAAA;AAAA;AAAA;;;;;;;;;A9BpYA;AAAA;AAAA;;;;;;;;;;;;;;;AAzSA;AAAA;AAAA;AAAA;AAAA;;;;;AAG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;;;;;;;;AhBi3GA;AAiBA;AAiFA;AAkkBA;AACA;;AmBlhIA;;;;;;;;;AnBs5HA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;ARoyHA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AQxyHA;;A+B7OA;;;;;;AvC0zIA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;AAAA;;;;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AmB9rIA;;;;;;AnB6rIA;;AACA;;AADA;;;;;;AACA;;;;;AADA;;AACA;;AADA;;AmB5rIA;;;AnB6rIA;AmB7rIA;;;;;AnB4rIA;;;;;;AACA;;;;;AADA;;AACA;;AADA;;;;;;AACA;;;;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;AAAA;;;;;;;;;;AgD7iIA;AAAA;AAAA;;;;;AxClSA;ARsiIA;;;AS/6HA;;AT+6HA;AAAA;;AAGA;;;;AgD1vHA;;;;;;;;;;;;;;;;ACoVA;AnBglIA;AC73GA;;;A/By/FA;;Aa9wIA;;;;Abo+HA;;AACA;;AAAA;AAAA;AAEA;AACA;AQziIA;ARqiIA;AACA;AAAA;AAAA;;;;;;;;;;;;ASj8HA;;;;;;AT+/GA;AgBj9GA;;;;;AhB2rIA;;;;AAAA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A;AD3gFA;;AS99CA;;;;;;ATkkDA;;AACA;;;;;;;;;;AAEA;;;;;AAHA;;;AACA;;;;;AAEA;;;;ACmyGA;;;Ac30JA;ANjBA;;;AR41JA;Ac30JA;ANjBA;;;;;;;;AR41JA;;;;;;;;Ac30JA;;;Ad20JA;;;Ac30JA;;;;;;;;;;ANlDA;;;;AMkDA;ANjBA;;;;;;;AMiBA;;;;;;;;Ad2tIA;AAAA;AAAA;;AACA;AADA;AAAA;AACA;;AADA;AAAA;;;AACA;;AADA;AAAA;;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;A6C9qIA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;ApCfA;AVsgDA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;ACmrFA;AAAA;;;;;AACA;AAAA;AAAA;;AADA;AAAA;AAAA;;;;;AACA;AAAA;;;;AS7rIA;AVsgDA;AAAA;AAAA;;AACA;;;;;ACqrFA;AAAA;;;;AAAA;AACA;;AA1SA;AACA;AAGA;;AQziIA;ARsiIA;AAEA;;A6Ct4HA;;;;;;AAvEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;A9C6jDA;AACA;AAAA;AAAA;;;;AAEA;AAAA;;ACmrFA;;AAAA;AACA;;AADA;;;;;;;;ADtrFA;AAAA;;;AACA;;AAAA;AAAA;;AACA;AAAA;;;;ACorFA;;;AAAA;AAAA;A6ClvIA;;A7CmvIA;;;;;;;;;AA1SA;;;AACA;AAAA;AAAA;AAAA;;AAGA;;;AQziIA;AAAA;;;ARsiIA;AAAA;AAAA;AAEA;AAAA;;;ASnjIA;AVu+CA;AAAA;;;AACA;AAAA;AUx+CA;AAAA;AAAA;AAAA;AAAA;;;AVy+CA;;;;AAEA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;AU5+CA;AAAA;AAAA;AAAA;;;;AV++CA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AqBjxCA;;;AhBigDA;AAAA;;;;AgBngDA;;;;;;;AAAA;;;;;;;AAAA;;;;;AAAA;ADtCA;;;;;;ACsCA;;ADnCA;;;;;;;ACmCA;;;;;;ADtCA;;AAAA;;Af81DA;Ae91DA;AAAA;ACsCA;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AAHA;AAEA;AAAA;;AC9xHA;AD2xHA;AAAA;AACA;;;;;;;;;;AgClkIA;AAAA;AAAA;AxBGA;AAAA;AR8jIA;AACA;AAAA;;AQ9zHA;;AwBpQA;;AhCikIA;AACA;AAAA;AAAA;;;AAGA;;AAHA;AAEA;AACA;AC/xHA;AD2xHA;AACA;AAAA;;;AAEA;;;AACA;AQj0HA;AAAA;AAAA;;APkCA;;;;AD4xHA;AAAA;;AAEA;;;AQjkIA;;;AR+jIA;AAAA;;;AAGA;;;;AgCrkIA;;;AAAA;AAAA;AAAA;;;;AvBqJA;AAAA;AuB/IA;AAAA;;AAAA;;;;AhC4jIA;AAAA;;;;AQ/jIA;;;AR+jIA;AAAA;AAAA;;;;;;;AC5xHA;;AD2xHA;AAAA;AAAA;;;AACA;;;AQ/jIA;AR+jIA;;AQ9zHA;AAAA;AAAA;AAAA;;AR6zHA;;;;AAIA;;AAHA;;AAAA;AAAA;AAEA;AAAA;;AQh0HA;;;AwB9PA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AhC2jIA;AAAA;AACA;AAAA;;AAAA;;;AQ/jIA;;;AR+jIA;;;AC5xHA;AAAA;AAAA;;;AD4xHA;;AQ/jIA;AR8jIA;AAAA;AAAA;;AACA;;;AAGA;AAAA;;;;AC/xHA;AAAA;AAAA;;;;;AD4xHA;AAEA;AAAA;;;AQjkIA;;AAiQA;;AwBzPA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AhCsjIA;AACA;;AAEA;;;AACA;AQj0HA;AAAA;AAAA;;ACrFA;;;;ATm5HA;AAEA;;AQjkIA;;;AR+jIA;;;AAEA;;;AAHA;;;AACA;AAEA;AACA;AAAA;;AQj0HA;;;;ACrFA;ATkqIA;;;;;AAAA;;;;;;;;;;;;;;AACA;;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;ASruIA;;;ACwsBA;AAAA;AAIA;;AyB1vBA;;AnCwwHA;;AUlhGA;;AAIA;;AF5iBA;AAAA;;;;;AoCnPA;AAAA;;;A5CkyHA;;;;;AUvgGA;;;;;AV4gGA;AAAA;;AUxgGA;;;;;AoCnzBA;;;;;AACA;;;;;;;;;;;ArCEA;;;AAqEA;AAAA;AAAA;;;;;;;;;AArEA;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAA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AAAA;AAAA;AAAA;;AAJA;AACA;AAAA;AAAA;AAAA;;;;AAGA;;;;AAHA;;AAGA;;AAAA;;AQxyHA;;;ARqyHA;AAAA;;;AADA;;;;;;;AA0BA;AAAA;AAAA;;AADA;;AC1rHA;;AO1HA;;;AR2xHA;AACA;AAAA;AAAA;;;;;;;;;;AAAA;;;;;AADA;;AQriIA;;ARsiIA;;;AQryHA;;;APmIA;AAAA;AAAA;;AQ/YA;AAAA;AAAA;AAAA;AAAA;;;ATijIA;AAAA;AAAA;AAAA;AAAA;;;;;;AADA;;AACA;;AAAA;;;;;AADA;AAAA;;;;;;;;;;ACjqHA;;AAAA;;AQ/YA;;ADqRA;;;;;;;;;;;;;;;;;;AAAA;;;;;AR2xHA;;;;;;;;;;;;;;;;AoBt1HA;;AGhMA;;AAAA;;AAAA;;AvB+zIA;;AACA;;AADA;;;;AmBpqIA;;;;;;;;AEiQA;;AtB6uCA;;;;AACA;;AACA;;;;AACA;;;;;;;;AsBptCA;;ALpTA;;AhB2rIA;;;;;;AoB/nIA;;ACqPA;;AA1BA;;;;;;ADtYA;;ArBonDA;;AACA;;AAAA;;;;AAEA;;AAAA;;AsBjvCA;;;;;;;;;;;ArBq6HA;;AAAA;;AAAA;;AoBhoIA;;;ACqPA;;;;;;;;ArB6nHA;AQjkIA;AAAA;;ARkkIA;;AoB/1HA;;;;;;;ApB2mIA;;;;AAAA;AAAA;;;;AAAA;;;;;AACA;;;AAAA;AADA;;AACA;;;;AADA;;AACA;;;;;;;AADA;AAAA;;;AAAA;;AACA;;;;;AADA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;;AADA;;;;AAAA;;;AAAA;AAAA;;;;;AACA;AADA;;;AAAA;;;;;;;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;AAAA;;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;AACA;;;;;;;;;;;AAAA;;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AAAA;;;;;;AADA;;;;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;AACA;;;AADA;;;;;;;;;;;ADnrFA;;ACmrFA;;;;;;ADrrFA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;;;ACmrFA;AACA;;AADA;AACA;;ADvrFA;AACA;;AACA;;AACA;AAAA;;;;ACorFA;;;;;;;;;AC1hIA;;AD0hIA;;;;AAAA;;;AADA;AAAA;;;;;;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;A6C9qIA;;;;;;;A9Cu/CA;AAAA;;;;;;;AACA;AAAA;;;AAEA;AAAA;;ACmrFA;AAAA;;;;;;;;;ADtrFA;AAAA;AACA;;;;ACqrFA;;AACA;;;AADA;AAAA;;;;;;;;;;;AoB7mIA;AACA;AAAA;ArBy7CA;AAAA;AqB17CA;AACA;;;;AXlEA;;;;ACkpBA;;;ADhyBA;AAAA;;;;AAZA;AAAA;;;;;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;AVsvCA;;;;;;;;;;;;;AqB9hCA;ArB6kCA;;;;;;;AAhCA;AqB7iCA;AAAA;;;AAAA;AAAA;;;;;;AAAA;AJ3EA;AjBgrCA;;;;;;;;;;;;;ACmuFA;;AAGA;;ASl7HA;;;;AAYA;;AAAA;AAAA;;;;;;AT4sIA;AAAA;AAAA;;;;AAAA;;ADtgGA;;AmBztCA;AAAA;;AlBshEA;AAAA;;;;AD3yBA;AAAA;;;;;;;;;;;AC89EA;AAAA;;;;AUvgGA;AAAA;;;;ADhyBA;;;;;;;;;;;AAAA;AACA;;;;;;;AAwKA;;AArLA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuGA;;;;AAAA;;;;;;;;;;;;;;;;;;AA3FA;;AAAA;;;;;AAAA;;;AAAA;;AACA;;;;;;;;;;AAbA;AAAA;;AAqEA;;;AArEA;;AAAA;;;;;AAAA;;;;;;;;;;;AAaA;;;;;;;;;;AAbA;AAAA;;AAqEA;;;AArEA;;AAAA;;;;;AAAA;;;;;;;;;;;AAaA;;;;;;;;;;AAbA;AAAA;;AAqEA;;;AArEA;;AAAA;;;;;AAAA;;;;;;;;;;;;AAaA;;;;;;;;AA0FA;;;;;AAvGA;AAAA;;AAqEA;;;AArEA;;AAAA;;;;;AAAA;;;;;;;;ATy0IA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AADA;;;;AAAA;;;;AAAA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AADA;;;;AAAA;;;;AACA;;;;AADA;;AACA;;AADA;;AmB9tIA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AVfA;AAiDA;AT4rIA;;;;;;;;;;;;;;;;;AArhBA;AAWA;;;;;AUlhGA;AAAA;AAIA;AAAA;;AD5sBA;;;AwBuIA;AA7BA;;;;;;;;;;;;;APgPA;;;;;;;;;AQnPA;;;;ARwRA;AAAA;AACA;AAAA;;AlBhOA;;;AYnQA;AAAA;AAAA;ATkvBA;AAAA;AAAA;AAAA;;AAzIA;;;AQ3cA;;;;;;;;;;;;;Af4hDA;AAAA;;AAMA;AA1BA;AAAA;AAVA;AAAA;;;;;AsBt9BA;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AjBvsBA;AAAA;AT8zHA;;;;AUlhGA;AAAA;;;;;;;;;;;;AD5yBA;AAAA;AAAA;;;;;;AAAA;AAoGA;;;;;;AT0tHA;AAAA;;;;;;;AUlhGA;AAIA;AAAA;;;ADhzBA;AAAA;;;;AAqEA;;;;;;;;;AT69HA;;;AQxiIA;;;;ARsiIA;AAAA;;;;;;;AAAA;;;;;AAGA;;;AQxyHA;;;;ARqyHA;;;;;;AAyBA;AAAA;;AADA;;;;;;AACA;;AADA;AACA;;;;;AAAA;AQ/jIA;;AR+jIA;AQ9zHA;;AR6zHA;;AAAA;;AACA;;;AADA;AACA;AQ9zHA;;AV5PA;AWgNA;AAAA;AAAA;AAAA;;AT02HA;AQ/jIA;AAAA;AAAA;AAAA;;;AR+jIA;AC5xHA;AD2xHA;;;AAAA;;;;AQ7zHA;AVtPA;;;AAAA;;;;AEo0IA;;;;;;;;;;;AADA;;;;;;;;AAAA;AAAA;;;AACA;;AADA;;;;;AACA;;;;;;;;;;AAAA;;;;AAAA;AADA;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAvSA;;;;;AAFA;;;AAAA;;;;AAAA;;;;ASh1HA;;;ATg1HA;;;;AAwBA;AACA;;;;;AAAA;;;;;;;AAAA;;;;AmB/7HA;AAAA;;;;;;;;AAMA;;;;;;;;;;;;;;AnBg6HA;AAAA;;;AQtiIA;;;;;AAiQA;AAAA;;;;;;;;AWtFA;AAAA;AAAA;;AAAA;AAAA;;;;;;ACsCA;;;;AbtNA;;ATHA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;;;AEs1IA;AAAA;;;;;;;;;;;AoB7nIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;ADtCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;Ab5JA;AAAA;;;;;;Aa4JA;ACsCA;AAAA;ApB6nIA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AqBn5HA;;;AAEA;AAAA;;;AA+LA;AAAA;;;AAojBA;AAAA;AAAA;;AA3RA;;;;;;;;;;;;;;;;;;;;;;;ArBgvCA;AAAA;;AqBv9BA;;;;;;;;;;;AD1oCA;;;;;;;;;;;;;;AXlBA;;;;;;;;AAAA;;;;;AACA;;;;;;;;;;AAbA;AAAA;;;AAqEA;;;;;;AArEA;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;AAqEA;;;;AArEA;;;;;AAAA;;;;;;;;;;;;AAaA;;;;;;;AA0FA;AAvGA;;AAqEA;;;;;;AArEA;;;;;;AAAA;;;;;;;;;;;;;;AAwLA;AT2nHA;;ASzsHA;;AT8sHA;AU5gGA;AAAA;AAIA;AAAA;;;;;;ADnyBA;;;;AA6FA;;;AA1GA;AAAA;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AVkpDA;AAAA;AACA;;AAEA;;AC04EA;AACA;;AAEA;;AAHA;AACA;AAAA;;AAGA;;AQxyHA;AT2tCA;AAAA;AACA;AACA;AAEA;AACA;AAAA;;AAAA;;;;;;AAGA;;;AAAA;;;;;;AC02FA;AAAA;;;;;AFt1IA;AAAA;;AAAA;;AAAA;AAAA;AE6iIA;;AACA;;;AAAA;AAEA;;;AQvyHA;;AT2tCA;;AACA;;;;AAGA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AALA;;;;AAQA;AAAA;;;;;;;;A0B1eA;;;;;;;AC7SA;;;;;;;;ACziBA;;;;;;;;;;;;;;;;AFs1BA;AAAA;;;;;;;;;;;AdjQA;AAAA;;;;AAAA;;;;;;;;;;;;;;AAAA;;AS1tBA;;;;;;;;;;;AK09BA;AAAA;;;;;AC5SA;;;;;;;;;ACrJA;;;;;;ADqJA;AD4SA;;;;;;;;AA5IA;;;;;;AA4IA;;AAAA;;;;;;;;;;;;;;AEjcA;;;;;;;;ADqJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD4SA;AAAA;AAAA;;;;;;;;;AEr1BA;AAAA;;;;AAoZA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3B6+GA;AAAA;AAAA;;;AACA;AAAA;AAEA;AAHA;AACA;AAAA;;AE1iIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF6zHA;AAAA;;;;;;;;;;;;AIiHA;AAAA;;;;;;;;AAttEA;;ACvgDA;AAAA;;;;;;;;AA1CA;;;;;;;;;;;;;;;;;;AGsIA;;;;AHtIA;AGsIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;;;;;;;AADA;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;ARqiIA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;;;;ADllGA;;;;;;;;ACklGA;AAAA;;;;;;;;;;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;;;;AAAA;;;ADllGA;;;AAAA;;;;AiBjnCA;;;;;;;;;;;;;AhBmsIA;AAAA;;;;;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;;AACA;;;;ADthGA;;ACshGA;ADthGA;;;;ACqhGA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;AACA;;AADA;AAAA;;AACA;AAAA;;AADA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AD3gGA;AC4gGA;;;;;;;;;;;;;;AAAA;AAAA;;;;;AAAA;;AADA;AAAA;;;;;AACA;;;;AADA;;AACA;;;;AAAA;;;;AmBtyIA;;;;;AnBqyIA;;;;;AACA;;;;;;;;;;AADA;AAAA;AAAA;;;;;;AAAA;AAAA;;AACA;;;;AAAA;;;;ADvrFA;;;;;;;;;;;AAGA;;AAHA;AAAA;AAAA;;AACA;AAAA;;;;AACA;;;;;AACA;AAAA;AAAA;;;;;AAFA;;;;;;;;;AAEA;;AAAA;;;;;;;;;ACorFA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIt0EA;AArTA;;;AAuuEA;;;;;;;;;AAvuEA;;;;;;;AsCltDA;;;;;;;;;;;;;;;;;A3BipBA;;;;;AhBqgCA;AAAA;;;;AAEA;;;;;;;;;;;;ACqbA;AAsDA;;;;;;A6Bj7CA;;;;;;;;;;AAjqBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ArBnDA;;;;;;;;AAAA;ARqiIA;;AACA;AAAA;AAEA;;;;;AQx3HA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AHfA;;;;;;;;AL2qIA;;;;;;;;;;;;A6B3xIA;;;;;;;;;;;;;;;;;;;ApBuDA;;;;AAAA;;;AuBrGA;AC4OA;;AA7BA;;;;;;;ARypBA;;;;;;ACzaA;AAEA;AAkBA;AAkBA;A1Bo1GA;;AC9uHA;AAAA;;;;;;AUgiBA;AAnSA;AqBxUA;;AAAA;;;;;;;APw2BA;;;;;;AOx2BA;;AAAA;;;;;;;A5B0mDA;;AqBxkBA;;;;;;;;AC1VA;;;;;;AAAA;;ACziBA;;;;;AAoZA;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;AOr/BA;AAAA;AvBqGA;;;;;AiBmmBA;;;;;;;;;AMxsBA;;;AAAA;;;;;;;;;;;AvBCA;AAAA;;;;AAYA;;;AAZA;;AAAA;;;;;AAAA;;;;;;AAAA;AAAA;AAoGA;;;;;;;;;;;;;AT+7HA;AAAA;;;;;;;;;A6C98HA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAhEA;AAAA;AAAA;;;AAAA;AACA;A7C6xHA;AAAA;;AAAA;AAWA;;;;;;;AAAA;;;AANA;;;;AiC34GA;AAAA;AAAA;;;;AtBsUA;AAAA;AAzIA;AAAA;;;;;AsB7LA;;;;;;;AYlZA;AAEA;;;;;;AALA;;;;;;;;;;;;;;;;;;;;;;;A9C2nDA;;;;;;ACqrFA;;AACA;AAAA;;;;;;AAAA;;;;;;;;;;;ADvrFA;;;AACA;;;ACqrFA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAxSA;;AAEA;;AACA;;;AAJA;AACA;AAAA;AAAA;;AAEA;AACA;;;AD7kFA;AAAA;;;;AACA;AUx+CA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AV2+CA;;;;AACA;;AAAA;AAAA;;;AU5+CA;;AAAA;AAAA;;;AV++CA;AAAA;;;;;;;;;;;;;AC02FA;AACA;;;;;;AADA;AAAA;;;;;AAAA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;AACA;AAAA;;AADA;;;;;;AACA;;;;;;AADA;AAAA;;;AACA;;;;;;AAAA;;AADA;AAAA;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;ASx0IA;AAAA;AAAA;AAAA;;;;;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATgiIA;;AAGA;;;;AgChiIA;;;;;;;;;;AvBHA;AAAA;AAAA;ATmzHA;AAAA;AAWA;;ASptHA;AAAA;;;ACksBA;;AAIA;;;;ADhzBA;;;AAAA;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ATmzHA;;;AQ/iHA;AwB3QA;AAAA;;;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AhCqiIA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;;;AAHA;AAEA;AgCziIA;AhC+jIA;AAAA;AAAA;;AACA;;AAGA;AQlkIA;AAAA;AR8jIA;AAAA;AACA;AAAA;AAAA;;AAEA;;;AAHA;;AACA;AAAA;;AAGA;AQlkIA;AAAA;AR8jIA;AAAA;AAAA;;;;AACA;AAEA;;AQh0HA;AAAA;AAAA;;APkCA;AD2xHA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;AAHA;AACA;AAAA;AAAA;;AAAA;AAAA;AAGA;;;;;;;;;;AgC1kIA;;;AhCu1IA;;;;;;;;AAAA;;AAthBA;;;;;;AIhzDA;AArTA;AAAA;;;;;;;;;A4B3tDA;AAAA;AawDA;A7Cq/HA;AAEA;AACA;AAJA;AACA;AAEA;;;;AgC3iIA;AAAA;AAAA;AAAA;;AhCwiIA;AACA;;AAGA;;AAJA;;;;;;AAGA;;;AQxiIA;;ARsiIA;AAAA;AAAA;AAAA;;;;AQryHA;AAAA;AAAA;AAAA;AAAA;;;AP3QA;AAAA;AAAA;AAAA;AD+iIA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AQtiIA;ARsiIA;;AQryHA;AAAA;AAAA;;AwBjQA;;AAAA;AAAA;AAAA;AAAA;AAGA;AhCkiIA;AACA;AAAA;;;;;AAAA;;;;;AAAA;AAAA;AAEA;;AACA;AAAA;;;;AAHA;AAEA;;;;;;AAFA;AAEA;AAAA;AAAA;;;;AAHA;AACA;AAAA;AAAA;AAAA;;;;;AgC9hIA;AAAA;AAAA;;AhC8hIA;AAAA;;;;;;;;;;;AAAA;;AAAA;;;AQtiIA;;ARwiIA;;;AQvyHA;AAAA;AAAA;AAAA;;;AC5QA;AAAA;;;;AD4QA;AAAA;AAAA;AAAA;;AC5QA;AAAA;AAAA;AAAA;;;;;;;ATy+DA;AAunDA;AAAA;AAAA;;;;;;;AAvnDA;AAunDA;AAAA;AAAA;;;;;;;AAoDA;AAAA;AAAA;AAAA;;;;;;;AAUA;;;;;;;ASljHA;AAAA;;AT6uIA;;AACA;AAAA;;AADA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;AAAA;;AACA;AAAA;;;;;AAAA;;;;;;AAAA;;AADA;AAAA;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AS7uIA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACitBA;AAIA;;;;;;;;;;;;;;;;AmBrrBA;AAAA;;;;;A7BwrHA;AAAA;;AiB3wHA;;AY4yBA;AAAA;AAAA;AA6vBA;;;;A7BkuEA;;A6B3vEA;;;;;;;AAUA;;;;;AANA;;AAoFA;;AApEA;;AAoEA;AAtCA;;AAsCA;;;;;;;;;;;AA36CA;AAAA;;AACA;AAAA;;;AAzLA;AA8LA;AAAA;AACA;;AAAA;;;AAGA;AAEA;AACA;;;AAoBA;;;;AAKA;AArCA;;;;;;AA9CA;AAEA;;;AAEA;AAAA;AA/IA;AAAA;;AAoJA;AACA;AA2DA;AADA;AA/CA;AAAA;AAAA;AAEA;AACA;AAnKA;;AAqKA;;;;AArKA;AA+JA;AACA;;;;;;;;;A7B2mHA;AcjuHA;;;Adi+HA;AACA;AAGA;AAAA;AUtxGA;;AFppBA;;;;;;;;;;;AJmyHA;;;;;;;;;AAl7DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AGrDA;;;;;AHWA;AGXA;AAAA;AR64HA;AACA;;AAGA;;Acj0HA;;Adi0HA;;;AAAA;;;AgB95HA;;;;;;;;AhBosIA;;;;;;AAAA;;;;;AD1jGA;ACyyFA;AACA;AADA;AACA;AD3gFA;AAoJA;;AACA;AAlgBA;;AAkgBA;;;;AAEA;;;;AAnDA;;AACA;;;AAEA;;;;ACorFA;;;AQ5oIA;;;AR4oIA;AQ5oIA;;;;;;ATq9CA;;AACA;;;;;;;;;AAEA;;;;;;;;;;;;ACorFA;;;;;;;AQvrIA;;;;;;;ARurIA;;;;;Ac5tIA;;;;AAAA;ANgFA;;;;;;;;AJwvHA;AAAA;;AAvuEA;;;;;;;ACjjDA;AO1CA;AAAA;AJiJA;AIhJA;AAAA;;;;;;AZqtIA;AAAA;;AAAA;;AAAA;;;;;;;;;AAtSA;;;;AAsSA;;;AAAA;;;;;;;;AAAA;;;;;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AACA;AAAA;;AAAA;;;;;;AAAA;;;;;;;;;AYttIA;;;;;;;AZqtIA;;;;;;;Ac3tIA;;;;;;;Ad2tIA;;AACA;;;AADA;;;;;;;AACA;AADA;;;;;;;AACA;;;;;AAAA;;;;;AAAA;;AAAA;;;;;AAAA;;;;;;;;AA1SA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AgC5iIA;AhCwiIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;AwBpQA;;AAAA;;;;;;AhCi1IA;;AACA;;AADA;;AACA;;;;;AgCl1IA;AAAA;AAAA;AAMA;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAKA;;AAAA;;;;AAAA;AAAA;AAAA;AhC6hIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AQryHA;AAAA;AAAA;AAAA;;;ARwyHA;AQxyHA;AAAA;AAAA;AAAA;;;;;ATu5CA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;;;;AACA;;;;;ADvrFA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;;AACA;;;;;AADA;;AACA;;AADA;;;;AACA;;;;;;;;Ae7rHA;AAsCA;AAAA;;AAKA;AhB29BA;AAAA;AACA;;AACA;;AACA;AAAA;;;;AiBxgDA;AAAA;;;;;;;;;;ARpHA;AOogBA;;AAkJA;;AAnCA;;AAAA;;AACA;;;;AA0CA;;;;;;;;AhB89BA;;AiBxgDA;;;;;;;;;AjBqgDA;AAAA;;;AACA;;AS1nDA;;AT2nDA;;AS3nDA;;AT4nDA;;AS5nDA;;;;AR+yIA;;;AAAA;;;AACA;;;;;;AADA;;;;AAAA;;ADllGA;;AAAA;;;;;;AAoBA;;ACsxFA;;;AQx4HA;;;ARw4HA;;AAEA;;;;;;;;;;;;AD9xFA;;AC4xFA;;AAAA;;AAGA;;AQ34HA;;ARw4HA;;AAAA;;ADpvFA;;;AC4hGA;;;;;AAAA;;;;;;;;;;;;;;;;A6BtwFA;AAAA;;;;;;;;;;;;;;;;;;;;;Ab77CA;AauiDA;A7Bm3EA;AAAA;;;AACA;AAEA;AAAA;;AACA;AAAA;AAAA;;AQziIA;ARqiIA;AACA;AAAA;AAAA;AAAA;;;AAGA;;A6B34EA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;A7BmeA;A6BheA;AAAA;;AmBn4CA;AAAA;;AnBkiDA;;;;;;;A7B0gFA;AAAA;AAAA;;;;;;;AA+mBA;AAAA;AAAA;;;;;;;;;;ADjsHA;;;;;ACklGA;AAAA;;;;;AA+mBA;;ADjsHA;;ACksHA;ADlsHA;AAAA;;;;;;;;;AC04BA;ADv3BA;AC+mHA;AAAA;AACA;AAAA;AAAA;;;;AAGA;;;;AQ5yJA;ARwyJA;;;;AACA;AAAA;;;;;;;;;;;AAt1BA;AAAA;;;;;AYl7HA;;;AZ+6HA;;;AAAA;;;AgB35HA;;;;;;;;;;;;;AhBi3GA;;AAiBA;AAuFA;AS//GA;AAAA;;ATg8HA;;;;;;AShjIA;;AAAA;;;;;AISA;AAAA;AAAA;AAAA;AAAA;AAAA;;AbwiIA;;;;AQtiIA;ARsiIA;AAAA;;;;;;;;;;;;AAySA;AAAA;;;;;;;;AAAA;;AAAA;;AAAA;;;AAAA;;;;;;;;AIpZA;;;;;;;;;;;AQl0HA;;;;AP0CA;;;AGuGA;;;AR+xHA;;;;;;;AgC1iIA;AhC+0IA;AAAA;AACA;AAAA;;AADA;AACA;AAAA;;AADA;AACA;AAAA;;AADA;AAAA;AAAA;;;;;AAAA;;;;;AACA;;;;;;;AArsBA;;;;AASA;;;;;;;;ADhnEA;AAAA;ASngDA;AOoKA;Afq4DA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;Aer4DA;Afq4DA;;AQviEA;;;;;;AJy5HA;;;;;;AAl7DA;;AC5zDA;;;;AG3KA;;;;AAAA;;;;;;;AOigBA;;AAkJA;AAGA;AAtCA;;;;;;;;;;;AgBghBA;AAAA;AAbA;AAAA;ApB5ZA;AAAA;AAAA;AAAA;;AE5tBA;AAAA;;;;;;;;;AbwgIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AapjIA;AAAA;AmC0TA;AAAA;AnC1TA;AAAA;AAAA;AAAA;AmC2UA;AAAA;AAAA;AlB63IA;;;;;;;;;AAGA;AC9hHA;ApBzaA;AAAA;;AE5tBA;AAAA;;;;;;;;;;;;;;AAxCA;AAAA;AAAA;AmC2UA;AAAA;AAAA;AAAA;AlB63IA;;;;;;;;;;AjBxsJA;AAAA;AAAA;;AbojIA;;AyCxmBA;AzCugCA;AyCxgCA;AACA;;AzC84BA;;;AAtSA;;AyCxmBA;AzCugCA;AyCxgCA;AACA;;AzC84BA;;;AAtSA;;AyCxmBA;AzCugCA;AyCxgCA;AACA;;AzC84BA;;AgD/gIA;AAAA;AAAA;;AhD+gIA;;;AAAA;;;;;AAAA;;;;;;;;;A6BrmHA;;A7B+kGA;AAAA;;;A6BrqEA;;AAEA;;AA1gDA;;;;AAzFA;;;;;;;;;;;AAkEA;;;;;;;;;;;AAquBA;;AA6vBA;;AA+DA;;;;;A7BmqEA;;A6B3vEA;;;;;;;;;;;;;;;AAUA;AAAA;;;;;;;;;;;;AANA;;AAoFA;;AA1EA;;AA0EA;;AApEA;;AAoEA;;;;;AAfA;;AAeA;;AAVA;;AAUA;;;;;;;AA7/CA;;;;AAtGA;;;;;;;;;;;AA8EA;;;;;;;;;A7BwrHA;;;;A6B/9FA;;AA6vBA;;AA+DA;;;;;A7BmqEA;;A6B3vEA;;;;;;;;;;;;;;;AAUA;AAAA;;;;;;;;;;;;AANA;;AAoFA;;AA1EA;;AA0EA;;AApEA;;AAoEA;;;;;AApCA;;AAoCA;;AA/BA;AAAA;;AA+BA;;;;;;;;;;;;AJzyBA;;;;;;;;AErTA;AAAA;;;;AFkcA;;;;AhBh5BA;;;AiBmmBA;;;;;;;;;;;;AjBvsBA;;;;;;AAAA;;;;;;;;;;;AAoGA;;;;;;;;;AAGA;;;;ACqsBA;;;;;AD5yBA;;;;;;;;;;;;;;;;;;;;ATmzHA;AAAA;;;ASzsHA;;AT8sHA;AAAA;;AUxgGA;;;;;;;;;;;;;ADhzBA;AAAA;;AAqEA;;;;;;;;;;;;;;;;;;;;;ADsLA;AAAA;AoC7OA;A5CihIA;;AQriIA;ARsiIA;;AQtiIA;AAiQA;;;;;;;;;ARoyHA;AACA;;;;AAAA;;;ASjjIA;;AAgOA;ATi1HA;;AAGA;;AAHA;AAGA;AAqBA;AACA;AAAA;AAEA;AQh0HA;AoC7OA;A5C2iIA;AQ/jIA;AR+jIA;AAAA;;;AADA;;AACA;AAAA;;;AAEA;AACA;AAHA;AAEA;;AC9xHA;AD8xHA;;AAFA;;AAGA;;;;;AA6QA;;;;;;AAzSA;AAGA;;;AAAA;AADA;;;AQvyHA;;;AqChNA;;;;;ArCyNA;;;;;;AInJA;AAAA;;AAAA;;;;;AZ+6HA;;AAEA;;AACA;;;AAHA;;;;;;;;;;;;;;;;;;;AAzhBA;;;;;ASx6GA;;;;;;;;;;;AA/FA;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;AAoLA;AAAA;;;;;ATooHA;AU5gGA;AAIA;AAAA;;;;ADpyBA;;;;;;;;;;;AAAA;AAAA;;;;;;;;AAyKA;AAAA;AAAA;;;;;AArLA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXCA;;AWlBA;;;;;;;ATy1IA;AAAA;;;;AAAA;;;;;AACA;AAAA;;;;;;AS11IA;ATgjIA;AAAA;AAAA;;;AAGA;;;AQxiIA;AAAA;;ARqiIA;AACA;AAAA;;;AAAA;;;;;;;;;;ADjtFA;;;AUh2CA;ATijIA;AAEA;;AACA;;AAJA;AACA;AAAA;;AAEA;AACA;;;;AAJA;AACA;AAAA;AAAA;;;;AQtiIA;ARqiIA;AAAA;AACA;AAAA;;AAAA;AAEA;;;;;AQvyHA;AC5QA;AAAA;AAAA;AAAA;AAAA;;ATgjIA;AACA;;;;;;AAGA;;AQziIA;ARqiIA;AAAA;AAAA;;;;;;AShjIA;;;;;ATojIA;;;;ASpjIA;;;;;;;ATgmHA;;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AA1iDA;AA8lDA;;;;;;;AgBt/GA;AAAA;AAAA;AhBggHA;;;;;;;ASljHA;AAAA;;AT6uIA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;;AACA;;;AADA;;;;;AAAA;;AACA;AAAA;;;;;;ASnqIA;AA3EA;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AT6uIA;AAAA;AAAA;;;AACA;;;AADA;AACA;AADA;;AAAA;AACA;;;;;AAAA;;;;;;AADA;AAAA;;AACA;AAAA;;AADA;AAAA;;;;;AAAA;AAAA;;AACA;AAAA;;AADA;;;;;;;AACA;;AADA;;AACA;AAAA;;;;;;AADA;;;;;ASlqIA;;;;ATkqIA;AACA;AAAA;;AADA;AAAA;AAAA;AAAA;;;;;AACA;;;;;;AoB1+HA;;;;;;;;;;;;;;;;;;;;ApBy+HA;;;;;AAAA;AAAA;;;;AAAA;AAAA;;;AACA;;AADA;AAAA;;;AACA;;AADA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AACA;;;;AADA;;;;;AAAA;;;AAAA;;AAAA;AAAA;;;;;;;AFx0IA;AAAA;AAAA;;;AEy0IA;;;AADA;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;ASxpIA;AAAA;AT8oHA;AANA;AUxgGA;;ADpyBA;;;;AAAA;;;;;;;;;;;;;AAZA;;;;;;;;;;;;;;AAAA;AAAA;AAgLA;AAAA;;;;;;;;;;;;AWkCA;AZkDA;AAAA;;;;AYnQA;;AAAA;;AAiNA;AAAA;AAAA;AAAA;;;;AAAA;ArBk1CA;AAAA;;ACqlBA;AAAA;AAAA;AqBtkBA;;;;AAAA;;;;ADrhDA;AAAA;AAAA;AAAA;;ArBs9CA;;;AACA;AAAA;AAAA;;;AAQA;;;;;AALA;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AqB39CA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC4hDA;AAAA;;;AAGA;;;;;;AtBqFA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;;;;AC8pEA;;;;;;;;;;AQzzHA;;;;;AVDA;;AAAA;;;AAAA;;;AAAA;;;;;AAMA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAMA;AAAA;;;AAAA;AAAA;;;;;AWtBA;;;;ATgmHA;;AAAA;;;;;AAAA;AAAA;;;;;;;;AAoDA;;;;;;;;;;;;AAqsBA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;AADA;AAAA;;;;;AACA;;;AADA;AAAA;;;;AAAA;AAAA;;;ASlqIA;;;;;;AA3EA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoFA;AAAA;;;AT+oHA;;AU9gGA;AAAA;;;AAJA;;;;AT5aA;;;AD87GA;;;AUlhGA;;;AVovGA;;;AQtiIA;;;;;;;ARwiIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A6BxoHA;;;AA7MA;;;;;;AAGA;AAAA;;;;;;;AAIA;;AAEA;;;;;AAwPA;;;AACA;;AAnRA;;;AA/IA;AAAA;;;;AAmJA;AAAA;;;AAkOA;;AAvOA;AAAA;AAAA;;AACA;AAAA;AAAA;AA/IA;AAAA;;;;AAiJA;;;;;;;;;;;;;;;;AAwRA;;AAEA;;;AA3QA;;;;;;;AAGA;;;AAnKA;;AAyKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A7By3GA;A6C9kHA;AAAA;;A7Cw0IA;;;;AADA;;;;;;;;;AACA;AA1vBA;;;;;;;AAAA;;;;;;;AgBl8GA;AhBggHA;AAAA;;;;;;;;;;AA4rBA;AADA;AAAA;AAAA;;;;AAAA;;;;;;;;AACA;;AADA;AAAA;AAAA;;AACA;;;AADA;;;;;AACA;;;;;;;;AADA;AAAA;;AAAA;AACA;;AADA;AAAA;AAAA;;AACA;;;;AADA;AAAA;;;;AAAA;;A6Cv0IA;AAAA;;A7Cw0IA;;;;;A6C9xIA;AAAA;;AAlCA;;;;;;;;;;;;AAGA;;;;AAAA;A7CmhIA;AACA;AAAA;AAAA;AAAA;;;AAGA;;;;;;;AAHA;AAAA;AAEA;;AACA;AAAA;;ASl7HA;AT86HA;;AACA;;;;;;A6CphIA;AAAA;;;;;;;;;;;ApCwFA;;;;AAAA;;;AuBhGA;ACuOA;;AA7BA;;;;;;;;ARypBA;;;;;;ACzaA;AAEA;AAkBA;AAkBA;A1Bo1GA;;AC9uHA;AAAA;;;;;;AUgiBA;AAnSA;AqBnUA;;AAAA;;;;;;;APm2BA;;;;;;;AOn2BA;;;;;;;APm2BA;;;;;;;AChKA;;;;;;AAAA;;ACziBA;;;;;AAoZA;;;;ADqJA;;AD4SA;;;;;;;;AACA;;;;;;;AhBh5BA;;;;;AiBmmBA;;;;;;;;;;;;;;;AjBvsBA;AAAA;;;;AAYA;;;AAZA;;AAAA;;;;;AAAA;;;;;;AAAA;AAAA;AAoGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL0mDA;AWx2BA;;;;;;;AXq1BA;AAMA;AAAA;AAAA;AAAA;;;AAjUA;;AAssCA;AAAA;AAAA;AAAA;;;;;AAnkBA;AArTA;AAAA;;;;;AI/rDA;AAAA;AAAA;AAAA;;;;;AO8gBA;AAg1CA;AAjuCA;;;AAmuCA;AAAA;AAAA;;AAluCA;AAAA;AAAA;;;AA6YA;AAAA;AAs1BA;AAEA;;;;AP/1DA;;;;;;;;AJ2rDA;;ACvgDA;AAAA;;;;;;;;AN2/CA;AAAA;;;;;;AAGA;;;AShrDA;;;;;;AJg6HA;;;;;;;;;;;;;;;ACxxHA;AGxIA;AAAA;AOqSA;;AA0BA;;;;;;;;;;;;;;;;APjUA;;;;;;;;ATkoDA;AAAA;AAAA;ACmrFA;;AACA;;AADA;AAAA;;;AACA;;;;;;;;ADtrFA;AACA;AACA;AAAA;;;;ACorFA;AADA;AAAA;;AS7uIA;;;;;;AAQA;;;;;;;;AAGA;;AACA;;;;;;AAEA;;;;;;;;;;;;;;AT0sHA;AAWA;AAAA;;ASzqHA;;;ACupBA;;;;;;AXs5BA;;;;;;;;;;;;AAGA;;;;AUhjDA;;;;;;AArJA;ATmzHA;AAAA;;;;;AAKA;AAAA;AAAA;AU5gGA;AAAA;AAIA;AAAA;;;ADpyBA;;;;;;;AAZA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ATy0IA;AAAA;;AAAA;;;;;;;;;AADA;;;;;AACA;;;;AAAA;;;;;;;AAAA;;;;AYttIA;;;;;;;;;;;AENA;;;ALyDA;AAAA;ATkqIA;AAAA;;AACA;AAAA;;AADA;;;ASlqIA;;;ATkqIA;;;;;;AAAA;AAAA;AAAA;;AACA;;;ASnqIA;ATkqIA;;AAAA;AACA;;AADA;AAAA;AAAA;AACA;;ASnqIA;AAAA;AAAA;;ATkqIA;;;AAAA;;;;;;;;;;;AACA;AAAA;;AAAA;;;;;;;;;AAAA;ASnqIA;ATkqIA;AAAA;;AACA;AADA;AAAA;;AACA;AAAA;;AADA;;;AAAA;;;;;;;;;;ADpyFA;AAnSA;AgBnkCA;AAAA;Afq4DA;Aer4DA;AAAA;Afq4DA;Aer4DA;AAAA;Afq4DA;;AQviEA;;;;;;;;;AJy5HA;;;;;;;;;AAl7DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AG3KA;;;;;AHiIA;AGjIA;AAAA;AACA;;;;;AADA;;;;;AOmpBA;AAnCA;AAAA;AAAA;AACA;AAsCA;;;;;AAIA;AfgwIA;;AACA;;AgB3yJA;;;;;ADkiBA;AAnCA;AAAA;AAAA;AACA;AAsCA;;;;;AAIA;AhB29BA;;AACA;;;AAEA;;;AiBxgDA;;;;;ADkiBA;AAnCA;AAAA;AAAA;AACA;AAsCA;;;;;AAIA;AhB29BA;;AACA;;;AAEA;;;AiBxgDA;;;;AjBqgDA;;AACA;;;;;;AAEA;;;;;;;;;;;ASj5CA;AM7KA;;AF0BA;;;;AJmJA;AIlJA;AAAA;;AAAA;;;;AC1HA;AAAA;AbuiIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;;AYj7HA;;;;;;;AZutIA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;Ac5tIA;;;Ad4tIA;;;Ac5tIA;;;;Ad4tIA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AYttIA;;;;;ARk0HA;;;;;;;;;AAl7DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AOpFA;;;;;AP0CA;AO1CA;AAAA;AACA;AEPA;AFQA;;;;;AAFA;;;AENA;;;;;;;;AAAA;;;;;;;;Afi3CA;;;;;AC02FA;;;;;AFt1IA;AAAA;AAAA;;AAAA;;ASMA;APgkIA;AAAA;;AACA;;AADA;AACA;AAEA;;AQh0HA;;AVzQA;ACo+CA;;;;AACA;;;AACA;;;AAEA;;;AACA;;;AAAA;;;;;;;;;;AAGA;;;AAAA;;;;;;AAAA;;;;;;;;;;;;AC02FA;;;;;;;;;AFt1IA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;ASGA;AAAA;AAAA;AAAA;;;AP2iIA;AAAA;AAAA;AAEA;;;;;AQxiIA;ARqiIA;AAAA;AAAA;;;;;;;;;;AQ3xHA;AM7KA;;AF0BA;;;;AACA;AAAA;AAAA;AZ66HA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;Aa3iIA;AAAA;AbuiIA;AACA;;AAGA;;AAJA;AACA;;AAGA;;AAJA;AACA;;AAGA;;;AYj7HA;;;;;;;AZutIA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;Ac5tIA;;;Ad4tIA;;;Ac5tIA;;;;Ad4tIA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AYttIA;;;;;ARk0HA;;;;;;;;;AAl7DA;AAAA;AAAA;AArTA;AAAA;AAAA;;ACvgDA;;;;;;AOpFA;;;;;AP0CA;AO1CA;AAAA;AACA;AEPA;AFQA;;;;;AAFA;;;AENA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ad4tIA;;;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;AAAA;;;;AS1pIA;ATooHA;;;;;;;AUngGA;;;AZtzBA;;;;;;;;;AEsiIA;;;;;;;;AADA;;;;;;;;AShjIA;;;;;;;ATojIA;;;;;AQxyHA;;;AC5QA;;;;ATgjIA;AAA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ACA;;;;AADA;;AACA;AAAA;;AADA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;AS3zIA;AAAA;;;;;;;;AAiJA;;;;AG3CA;;;;;;;;;;;;;;;;AZqtIA;AAAA;AAAA;;AACA;;AADA;AAAA;;;AACA;;;;AADA;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;AAAA;;;;;;;;;;AADA;;;;AAAA;AAAA;;AACA;;;AADA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;;;AACA;;;;AADA;;AACA;AAAA;;AADA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;;;AACA;;;;AADA;;AACA;AAAA;;AADA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;AACA;AADA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;AADA;;;;AAAA;AAAA;AAAA;;;;;AAAA;;;;;;;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;;AACA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;;ASz0IA;;;;;;;;;;;;;;;;;;;;ATwzHA;AS9rHA;AAAA;;;;AT+sIA;;;;AAAA;;;;;;;;AAAA;;;ADtgGA;AAAA;;ACsgGA;ADtgGA;;;;AmBztCA;;AAAA;;AnB2uCA;;;;;AqB7nCA;AZ4CA;;AYnQA;;AAuNA;AAAA;AAAA;AAAA;;;;ArB40CA;;;AsBeA;AAAA;ArB4kBA;;;AoBjmEA;;;AAAA;AAAA;;;;;;ArB+9CA;AAAA;AACA;AAAA;;;;AANA;AACA;AAAA;;;;AAAA;;;;;;;;;;;AevxCA;AAAA;AAAA;AFtIA;;;;;;AEkFA;;;;AACA;;;;;;;;;AACA;AAAA;;;;;;;;;;AAEA;AAAA;;;;;;;AACA;AAAA;;;;AdqpIA;;AACA;;AADA;;AArhBA;;;;;;;;;;;;;;AY7tHA;;;;;AZkvIA;;;AACA;AAAA;;;;;AAAA;;AADA;AAAA;;;;;;AACA;;;;;;;;;;;;;;AwC/0IA;AxC8jIA;AACA;AAAA;AAAA;;AyC9n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AA;;;;;;;;;AjBxhBA;AAAA;AAAA;;;AEo0IA;;AADA;;AAAA;;AAAA;;AACA;;AADA;AACA;AADA;;;AAAA;;AAAA;AACA;;;;;;AADA;AAAA;;;;;ADtrFA;AAAA;;AACA;;AAAA;AAAA;;AACA;AAAA;;;;AACA;;;;;;ACmrFA;;;;;;;;;AAAA;;AACA;;;;ADvrFA;;;AACA;;;AAAA;;;;;;AAEA;;;AAAA;;;;ACmrFA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;;AAAA;;;AAAA;;;;;;;;;;AAAA;;;AACA;;AADA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;AAAA;;;;;;;;;AACA;;;;;;AADA;;;;;;AAAA;;AACA;;AADA;;;;;;;;;;;;AOt1IA;Ae8FA;AtB+8HA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AAGA;;AQxyHA;AN3QA;AAAA;AAAA;AAAA;AoBgGA;Af9FA;AP6iIA;AACA;AAAA;;AAGA;;AAJA;AACA;AAAA;;AQryHA;AAAA;AAAA;AAAA;AV3QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AEmjIA;AQxyHA;AAAA;AAAA;AAAA;AV3QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AEw1IA;;AACA;;AADA;;AACA;;ADvrFA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;ADvrFA;;AACA;;;AAEA;;;ACmrFA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;AACA;;AADA;;;;AACA;;;;;;;AA7xDA;AACA;AAAA;;;;AQ1wEA;;;;;;;;;AAAA;;;;;;AJ03CA;;;;;;;;;;;;;;;;AAsWA;;;;;;;;;;;;;;AArTA;ACvgDA;;;AG4FA;;;AHtIA;;AGsIA;;;AACA;;;;AADA;;;;;;;AAAA;;;;;AAJA;;;;;;;;;;;;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7EA;;;;;;;;;;;;;;;;;;AYuVA;AAAA;;;;;;AA1BA;AAAA;;;;;;;;;;;;ArBqpHA;AC12HA;AD02HA;;AADA;;AQ7zHA;;AR6zHA;;AQ9jIA;;AR+jIA;;AF1jIA;;AAAA;AAAA;;;AWgNA;ATy2HA;AACA;;;;;;;;;;;;;;;AqBppHA;;AtB6uCA;;;;;;;;;;;A0B3yBA;;;;;;;;;;AhB71BA;AAAA;AA0KA;AA7EA;;;;;;ATy7HA;;;;;;;;;;;;;;;;AA4BA;AQlkIA;AAAA;;ARkkIA;ACjuHA;AD2sEA;;AC3sEA;;;;;;;;;;;;;;;;;;;;;;ADosHA;;AACA;AAAA;;;;;ACpuHA;AAAA;AAAA;;;AFwrCA;;;AAEA;;;;;;;;;;AAEA;;;;;;AACA;;;;;;;;AkBnnCA;AAAA;;;;;;;;;;;Ab6nDA;AAAA;;;;AC5zDA;;;;;;;;;;;;;;;AL4mHA;AAWA;AAAA;AU9gGA;;;;;;;;;;;;;;;;;;;;;;;;ADrtBA;;;;;;;;;;;;;;;;;;;;AT08DA;;AA8lDA;;;;;;;;;;;AAUA;;;;;;;ASjgHA;;;;;AAjDA;AT6uIA;;AACA;;AADA;;AACA;;ASnqIA;;;;;;;ATmqIA;ASnqIA;AAAA;;;;;;;;;;;;;;;;;;ADgHA;AR02DA;AQz2DA;;;;;;;;;;;;;;;;AYzPA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AZ6NA;AVzQA;AqBmLA;AfyiDA;AAAA;AAAA;AAAA;AgBngDA;AAAA;AAAA;AAAA;ADtCA;AAAA;AAAA;Af81DA;;;;;;;;;;AJ6hEA;;;;;;;;;;AAwSA;;;;;;ASx0IA;;;;;;;AD2PA;AAAA;;;AY9BA;AAAA;ApB21HA;;AAIA;;AAJA;AACA;;AAAA;;AAGA;AC/xHA;;AD2xHA;AAGA;AQjkIA;AR8jIA;AAAA;AACA;;;;;;AA+QA;;ASlqIA;;;AT03HA;;;;;;;;;;;;;;;;;;;;;AD54EA;;;;;;ACk2DA;AAAA;;;;;;;;;;;;AQ5/GA;AAAA;;AAqQA;AAAA;;;AR0kIA;;;;AenzFA;;AhBcA;;;;;;;;;;;AA9SA;;;;AAAA;AqB9hCA;;;;;ArB6kCA;;;;;;;;;;;;;;AAyLA;;;;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A;AACA;;AAGA;;AQxyHA;;;;;;;ARqyHA;AAGA;AAJA;AACA;;;;;;;;;;;ASjjIA;;;;;;;;;;;AGoIA;;;;;;;;;;;;;;;;;;;;;;AbkiDA;;;;;;;;;;;;;;;;;AAtUA;;;;ACy/FA;;;;;;;;;;AA/QA;AAEA;AACA;AAAA;;AQj0HA;APkCA;;AD4xHA;;AAAA;;;;ADn0FA;;;;;;AC6yFA;;;;;;;;;;;;;AD9sFA;;;;;;;;;;;;;;;;;;;;;;AsBj7BA;;;;;;ArBguGA;;;AgBv/GA;;;;;;;AhBk8GA;AAAA;;;;;;;ASp/GA;AT8uIA;;;;;;;;AADA;AACA;AADA;AAAA;;;;;;AAAA;AAAA;AACA;AADA;;;;;;;A0BjoHA;;;;;;;;;;;AG1fA;;;;;;;;A7Bs1HA;;AQziIA;;;;;;;;;;;AR+0IA;;;;;;;;;;;;;;;;;;;;AAjRA;;;;;;;;;;;;Ac38HA;AL+BA;AT4rIA;;;;;AAzsEA;A6BheA;AAAA;AAuGA;AAHA;;;;;;;;;;A7BqkFA;;;;;AAAA;;;;;;;;;;AACA;;;AADA;;;;;;;;;;;;AACA;;;;;;;;;Aa11IA;AAAA;;;;;;;Aby1IA;;;;;;;;;;;;;;;;AC/gIA;AAAA;;;;;;;;;;;;;;;;;;ADuuHA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAwSA;;;;;;;;AACA;;;;;;AD1/FA;;;;;;;;;;;;;;;ACitFA;;;;;A0Bz1GA;;;;;;;;;;;AV1jBA;;;;;;AjBksCA;;;;;AC0/FA;;AQxkIA;AAAA;;APsDA;;;;;;;;;;;;;;A4Bu2CA;;;;;;;;;;;;;;;AbjhDA;;;;;;;;;;;;;;;;;;AhB4rIA;;;;;;;;;ADvrFA;;AACA;AAAA;;;;;ACqrFA;;;;;;;;;AQ90IA;;;;;;;;;;;;;ARyzHA;AAAA;;;;;;AApOA;AAAA;;;;AAAA;;;;;;;;AgDtyGA;;;;AjD68BA;;;;;;;;;;;;;;;;;;;;A8BtiCA;;;;;A9BqoCA;;;;;;;;;;;AMxrCA;;;;;;;;;;ANylCA;;;;;;;;;AA+FA;;;;;;;;;;;;;;;;;;;;;;;AC2sFA;;;;;;;;;;;;;;;;;;AADA;;;;A6B9yHA;;;;;;;;;;A9Bi6CA;;;;;;;;;;;;;;AAGA;;;;;;AAjKA;AAAA;;;;;;AsB7SA;;;;;;;;;;;;;;;ArB47EA;;;;;;;;;AD9+DA;;;;;AC84EA;;;;;;;;;;AADA;;;;AAHA;;;;;;;;;;;AgBl5HA;;;;;;AhB2rIA;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;AAtsBA;;;;;;;;;;;;AoBryGA;AAAA;;;;;ArBqzCA;;;;;;Aa/kDA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A6Bu3GA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A/B3oFA;AAAA;;;ADpyBA;;;;ATmkHA;AAvtDA;AAutDA;AAAA;;;;;;;;;AA4eA;;AQjkIA;;AR8jIA;;;;;;;;ADr6EA;;;;;;;;;;;;;;;;AC44EA;;;;;AD1sFA;;;;;;;;;;;;;;;AiCv1CA;;AAAA;;AAAA;;;;AvBfA;;;;;;;;;ATy1IA;;;;Aah1IA;;;;;;;;;Adu1CA;;;;;;;;;;;;;;;;;;AAqUA;;;;;;;;;;;;;;;;;;;;;AA9ZA;;;;;;;;AC4yFA;;AACA;;;;;;AQziIA;;;;;ARqlHA;AAAA;AAAA;AAAA;;;;;AD1vEA;;;;AAgUA;;;;;AsBptCA;;;;;;;;ArB+lHA;;;;;;;;;;AgB35HA;AjBqoCA;AA2BA;;;;;;;;;;;;;;;;;;;;;;;;AC6vFA;;;;;;;AgCpiIA;;AvBfA;;AAAA;;;;;;;AD4QA;;AP3QA;;AD+iIA;;;;;;;;;;;;ADhtFA;;;;;AAAA;;;;ACgwEA;AAvtDA;AAutDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgB18GA;AjBqoCA;AA2BA;;;;;;;;;;;;;AaruCA;AE8GA;;;;;;;Adk9DA;ADv3BA;AA4BA;;;;;;AiD3+BA;AlBq8IA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A9BvbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADllGA;;;;;;AiD57BA;AAAA;AAAA;;;;;;;;;;;;AhD8gIA;;;;;;;;;;;;AAAA;;;;;;A6C7xIA;A5CrCA;;;;;A+CoTA;;;AAAA;;;AlB83IA;;;AAEA;;;;;A9BjXA;;;;;;;;;;;;;;;;;;AE90IA;;;;;AckJA;;;;;AhBk8GA;AAAA;AAAA;;;;;AD1vEA;;;;;AAhFA;;;;;;AC8iFA;;AAKA;;;;;;;;ADn+EA;;;;;;;;ACo/FA;;;;;;AgD/gIA;;AnC3UA;;;;;;;;;;;;;Ads2CA;;;;AkB/8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjB0pHA;;;;AAySA;;;;;;;;;AADA;;;;;;;;;A6C7xIA;AAlCA;;;;A7BoIA;;;;;;AjBksCA;;;;;;;;;;;;;;;;;;;;;;;ACotFA;;;;;ASthIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATmnEA;;;;;;ADjzBA;;;;;;;;;;AUh2CA;;;;ATmjIA;;;;AAFA;;;;;;;;;;;AD3xFA;;;;;;;;;;ACokGA;;;;;;;;AAAA;;;;;;;;;;;;;;;AgC30IA;AvBfA;;;;;;;;;;;;;;AT01IA;;;;;;;;;;;;;;;AgC10IA;AhCgiIA;;;;;;AShjIA;;;;ATykIA;;;;;;;;;;;;;;;;;;ADnzFA;;;;;;ActxCA;;;;;;Adg2CA;;;;;;;;;;;;;;;;;;;;;;;;;;;AQ71CA;;;;;;APs1IA;;;;;;AAAA;;;;;;AAAA;;;;;AqB/nGA;;;;;;;;;;;;;;;;;;;;ArB01FA;;;;;;;;;;AAsSA;;;;;;;;;;;;;;;;;;;;;AADA;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;AgB3rIA;;;;;;;;;;;AARA;AjBqoCA;AA2BA;;;;;;;;;;;;;;;;;;;AA8WA;;;;;;;;;;;;;;;;;;;;;;;AC64EA;;;;;;;;;;;;;AADA;;;;;;;;;;;;;AQriIA;;;;;;;;;;;;;;;;;;AR80IA;AAAA;;AACA;;AADA;;;;;;;;;;;;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;;ASlqIA;;;;;;;;;;ATy3HA;;;;;;;;;;;;;;;;;;AoBjsHA;;;;;;;;;;;;;;;;;;AX7OA;AT86HA;;;AACA;;;;;;;;;;;;;;ADtkFA;AACA;;;;;ACokFA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AiB5pHA;;;;;;;;;AlBg3BA;;;;;;;;;;;;;;AA+FA;;;;;;;;;;;;;AiBxsCA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhB2rIA;;;;;;AAAA;AACA;;;;;;;;;AADA;;;;;;;;;;;;;;AoB1+HA;;;;;ApB2+HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADpkGA;;;;;;ACmzFA;AAAA;AACA;;;;;AiBnrHA;;;;;;AEjOA;;AnBmqIA;;AACA;;;;AAtsBA;;;;;;;;;AmB39GA;;;;;;;ANzLA;;;;;AiBwvJA;AAAA;;;;;;;;;ArB5oJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EA;AAAA;;;;;;;;AWqCA;;;;;ArB2iCA;;;;;AAAA;;;;;AC64EA;;;;;;AAgaA;;;;;;;;;;;;;AD9sFA;;;;AAAA;;;;;;;AEz/BA;;;;A4BwfA;;;;;;;;;;;;;;A7B8sGA;;;;;;;;;;AD5kFA;;;;;;AC6kFA;AAHA;;;;;;;;;;ADj4EA;AAHA;;;;;;;;;;;AmD73CA;AA8CA;;;;;;;AlDqtHA;;;;;;;;;AAsSA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;ASlqIA;AAAA;;;;;;;;;;;;;;;;;;;ATkqIA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;AFx0IA;AAAA;;;;;;;;;;;;;;;;;;;AEmiIA;AAAA;;;;;;;;;AADA;AAAA;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;AS53HA;AAAA;;;;;;;;;;;;;;;;;;AT03HA;;AAAA;;;;;;;;;;;;;;;AAwSA;AAAA;;;;;;;ASjuIA;;;;ATk9HA;AAAA;;;;;AD/yFA;AE98BA;;;;;;;AD6gIA;;;;;;;;AkD3iIA;;;;AlDwtGA;AAAA;;;;;;AQlvGA;;;;;;;;;;;ARokIA;AAAA;;;;;;;;;;;ADp1FA;AAAA;;;;;;;;;;;;;AA/OA;;;;;;;;;;;;;;;;;;;;;;;;;AiBxnCA;;;;;AAAA;;;;;AhBm5HA;AAEA;;;;;AAsSA;;;;;;;;;;;;;;;;AAxSA;;;;;;;;;;AADA;;;;;;;;;;AShjIA;;;;;;;;;;AAAA;;;;AEyjBA;;;;;;;;;;;;;AXgyHA;;;;AgB3rIA;;;;;;;;;;;;;AI/GA;AAAA;;;;;;;;AJ+GA;;;;;AjBwsCA;;;;;;;;;ACm+EA;AU5gGA;AAAA;;;;;;;;;;;;;;;;;;;AD5yBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoCqFA;;;;;;;A7CmvIA;;;;;;;;;;ADn/FA;;;;;;;;;;;;;;;;;;;;A8ChwCA;;;;;ArC3FA;;;;;AYiNA;;;;ArB08CA;;;;;;AC07DA;;;;AoBhvGA;;;;;;;;;;;;;;;;;;;;;;;ApBmsHA;;;;;;;AAHA;;;;AgCjiIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvBEA;;;;;;AVsvCA;;;;;;;AAAA;;;;AA+ZA;AAAA;;;;;AAhUA;;;;ACo/FA;;;;;;;AADA;;;;;AArSA;;;;;;;;;;ASl7HA;;;;;;;;;;;;AAlIA;;;;ATijIA;;;;;;;;;;;;;;;AY19HA;;;;;AQxCA;;;;;;;;;;ApBkgIA;AAEA;;;;;AQrxHA;AAAA;;;;;;;AauJA;;;;ArB4nHA;;;;;ASp5HA;;;;;;;;;;AT4rIA;;;;;ADrrFA;;;;AUnpDA;;;;;;ADNA;;;;;;;;ATmgDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AU7/CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4yBA;AAAA;;;;;;;;;;;;;;;AVkhGA;AAAA;;;;AIuHA;;;;;;AQp0HA;;;;;;ASs6CA;;;;;ArBwgFA;AACA;;;;;;;;;ADviFA;;;;;;ACuiFA;;;;;AD74EA;;;;;;;;;AmDp3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A1CpCA;;;;;;;;;;;;AR8kIA;;;;;;;;;;;;;AAv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;AAAA;;;;AFx0IA;AAAA;;;;AEy0IA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AFx0IA;AAAA;;;;AEy0IA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;AFx0IA;AAAA;;;;AgB6GA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ad4tIA;AAAA;;;;ASnqIA;AAAA;;;;ATkqIA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;;;;AACA;AAAA;;;;AADA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;AD9jGA;;;;AgBnlBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfipHA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;ASlqIA;;;;;;;;;;ATkqIA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;ASlqIA;;;;;;;;;;ATkqIA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AAAA;;;;;AFx0IA;;;;;AcoHA;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AZstIA;;;;;AAAA;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAtSA;;;;;AAJA;;;;;AAIA;;;;;AAHA;;;;;;;;;;AAAA;;;;;AaviIA;;;;;AADA;;;;;AAAA;;;;;AJuGA;;;;;AAAA;;;;;ATw6GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBl4GA;;;;;AhB85HA;;;;;AAHA;;;;;A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;;AADA;;;;;;;;AgC/0IA;;;;Aa4FA;;;;A/BwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ad2tIA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;AACA;;;;AADA;;;;;;;;AgC/0IA;;;;;;;;AhC0iIA;;;;AADA;;;;AACA;;;;AAHA;;;;A6C38HA;;;;AjC+BA;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AZstIA;;;;AAAA;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AAtSA;;;;AAJA;;;;AAIA;;;;AAHA;;;;;;;;AAAA;;;;AaviIA;;;;AADA;;;;AAAA;;;;AJTA;;;;AuBUA;;;;AAAA;;;;AvBVA;;;;;;;;ATgjIA;;;;AAIA;;;;AAHA;;;;ASj8HA;;;;ATw6GA;;;;AAjBA;;;;;;;;;;;;;;;;AAm1BA;;;;;;;;;;;;;;;;AAvSA;;;;;;;;AAAA;;;;AQ9xHA;;;;;;;;;;;;AInJA;;;;;;;;;;;;;;;;AHlIA;;;;AuBUA;;;;;;;;AhCuiIA;;;;AQtiIA;;;;;;;;ARqiIA;;;;AQpyHA;;;;;;;;ARoyHA;;;;AAIA;;;;AAHA;;;;;;;;AAAA;;;;AQtiIA;;;;;;;;ARqiIA;;;;AShjIA;;;;;;;;ATgjIA;;;;AAIA;;;;AAHA;;;;ASjjIA;;;;AD4QA;;;;ARwyHA;;;;AAHA;;;;;;;;AAAA;;;;AChjIA;;;;;;;;ADgjIA;;;;AQtiIA;;;;;;;;ARqiIA;;;;AAIA;;;;AAHA;;;;;;;;AAAA;;;;AgCviIA;;;;;;;;AhCuiIA;;;;AQtiIA;;;;;;;;ARqiIA;;;;AShjIA;;;;AAAA;;;;AD4QA;;;;ARwyHA;;;;AAHA;;;;AQtiIA;;;;;;;;ARsiIA;;;;AQryHA;;;;ARwyHA;;;;AAHA;;;;;;;;;;;;;;;;AQtiIA;;;;;;;;ARsiIA;;;;;;;;AAEA;;;;AAHA;;;;AAIA;;;;AAHA;;;;AADA;;;;AgCtiIA;;;;;;;;AhCyiIA;;;;AAFA;;;;AQtiIA;;;;;;;;ACWA;;;;AT6hIA;;;;AAFA;;;;A6Cr/HA;;;;AblDA;;;;AxBkQA;;;;ARi0HA;;;;AAHA;;;;AADA;;;;AQ9jIA;;;;AR+jIA;;;;AAAA;;;;AC5xHA;;;;AOlCA;;;;ARi0HA;;;;AAHA;;;;AADA;;;;AQ9jIA;;;;AR+jIA;;;;AAAA;;;;AC5xHA;;;;AD8xHA;;;;AAFA;;;;AADA;;;;AAIA;;;;AAHA;;;;AADA;;;;AgC/jIA;;;;;;;;AhCyiIA;;;;AAFA;;;;AADA;;;;;;;;AAGA;;;;AAFA;;;;AADA;;;;AgCriIA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AADA;;;;;;;;;;;;;;;;;;;;AADA;;;;AxB4QA;;;;AE4iBA;;;;AAJA;;;;;;;;AVkhGA;;;;AS1qHA;;;;;;;;ACwpBA;;;;;;;;AVugGA;;;;AFxzHA;;;;;;;;AYizBA;;;;;;;;AVkhGA;;;;AS/oHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AW4BA;;;;;;;;;;;;;;;;;;;;;;;;;AhB0uHA;;;;;;;;;AgB1pHA","sourcesContent":["#pragma once\n\nnamespace rx {\n\nconst auto delay = [](auto makeStrand, auto delay){\n    info(\"new delay\");\n    return make_lifter([=](auto scbr){\n        info(\"delay bound to subscriber\");\n        return make_subscriber([=](auto ctx){\n            info(\"delay bound to context\");\n            subscription lifetime;\n            ctx.lifetime.insert(lifetime);\n            auto outcontext = copy_context(ctx.lifetime, makeStrand, ctx);\n            auto r = scbr.create(outcontext);\n            return make_observer(r, lifetime, \n                [=](auto& r, auto v){\n                    auto next = make_observer(r, subscription{}, [=](auto& r, auto& ){\n                        r.next(v);\n                    }, detail::pass{}, detail::skip{});\n                    defer_after(outcontext, delay, next);\n                },\n                [=](auto& r, auto e){\n                    auto error = make_observer(r, subscription{}, [=](auto& r, auto& ){\n                        r.error(e);\n                    }, detail::pass{}, detail::skip{});\n                    defer_after(outcontext, delay, error);\n                },\n                [=](auto& r){\n                    auto complete = make_observer(r, subscription{}, [=](auto& r, auto& ){\n                        r.complete();\n                    }, detail::pass{}, detail::skip{});\n                    defer_after(outcontext, delay, complete);\n                });\n        });\n    });\n};\n\n}","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return -_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) : __f_(__f) {}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_return<type, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm)\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\ntemplate<class _Fp> class _LIBCPP_TYPE_VIS_ONLY function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    return __invoke(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TYPE_VIS_ONLY function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    template <class _Fp>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const _Fp&) {return true;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) {return __p;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const function<_R2(_Ap...)>& __p) {return !!__p;}\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value =\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp>\n      function(_Fp, typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                      >::type* = 0);\n\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f,\n               typename enable_if<__callable<_Fp>::value>::type* = 0);\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f,\n                                     typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                     >::type*)\n    : __f_(0)\n{\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,\n                                     typename enable_if<__callable<_Fp>::value>::type*)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<_FF>\n#else\n            rebind_alloc<_FF>::other\n#endif\n            _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = (__base*)&__tempbuf;\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = (__base*)&__buf_;\n        __t->__clone((__base*)&__f.__buf_);\n        __t->destroy();\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f_ == (__base*)&__buf_)\n    {\n        __f_->__clone((__base*)&__f.__buf_);\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = (__base*)&__buf_;\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__f_ == 0)\n        throw bad_function_call();\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n_LIBCPP_FUNC_VIS extern __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern __ph<10> _10;\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_bind_expression<_Ti>::value,\n    typename __invoke_of<_Ti&, _Uj...>::type\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = _is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(const __bind& __b)\n        : __f_(__b.__f_),\n          __bound_args_(__b.__bound_args_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(const __bind& __b)\n    {\n        __f_ = __b.__f_;\n        __bound_args_ = __b.__bound_args_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(__bind&& __b)\n        : __f_(_VSTD::move(__b.__f_)),\n          __bound_args_(_VSTD::move(__b.__bound_args_)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(__bind&& __b)\n    {\n        __f_ = _VSTD::move(__b.__f_);\n        __bound_args_ = _VSTD::move(__b.__bound_args_);\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(const __bind_r& __b)\n        : base(_VSTD::forward<const base&>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(const __bind_r& __b)\n    {\n        base::operator=(_VSTD::forward<const base&>(__b));\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(__bind_r&& __b)\n        : base(_VSTD::forward<base>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(__bind_r&& __b)\n    {\n        base::operator=(_VSTD::forward<base>(__b));\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__c = 0;\n        __u.__d = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b ^ __u.__c ^ __u.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash\n    : public unary_function<_Tp, size_t>\n{\n    static_assert(is_enum<_Tp>::value, \"This hash only works for enumeration types\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","#pragma once\n\nnamespace rx {\n\n\ntemplate<class Select = defaults, class... TN>\nstruct context;\n\nnamespace detail {\n    template<class C, class E>\n    struct abstract_context : public abstract_strand<C, E>\n    {\n        virtual ~abstract_context(){}\n    };\n\n    template<class C, class E, class MakeStrand>\n    struct basic_context : public abstract_context<C, E> {\n        using clock_type = decay_t<C>;\n        using errorvalue_type = decay_t<E>;\n        basic_context(context<void, MakeStrand, C> o)\n            : d(o){\n        }\n        template<class Defaults>\n        basic_context(context<Defaults> o)\n            : d(o.lifetime, o.m){\n        }\n        context<void, MakeStrand, C> d;\n        virtual time_point_t<clock_type> now() const {\n            return d.now();\n        }\n        virtual void defer_at(time_point_t<clock_type> at, observer_interface<re_defer_at_t<C>, E> out) const {\n            d.defer_at(at, out);\n        }\n    };\n    \n    template<class C, class E>\n    using make_strand_t = function<strand_interface<C, E>(subscription)>;\n\n    template<class Clock = steady_clock>\n    struct make_immediate {\n        auto operator()(subscription lifetime) const {\n            return make_strand<Clock>(lifetime, detail::immediate<Clock>{lifetime}, detail::now<Clock>{});\n        }\n    };\n\n}\n\n#if !RX_SLOW\ntemplate<class Clock>\nauto make_shared_make_strand(const detail::make_immediate<Clock>& make) {\n    return make;\n}\n#endif\n\ntemplate<class C, class E>\nstruct context<interface<C, E>> {\n    using payload_type = void;\n    using clock_type = decay_t<C>;\n    using errorvalue_type = decay_t<E>;\n    context(const context& o) = default;\n    context(context&& o) = default;\n    context(const context<void, void, clock_type>& o)\n        : lifetime(o.lifetime)\n        , d(make_shared<detail::basic_context<C, E, void>>(o))\n        , m([m = o.m](subscription lifetime){\n            return m(lifetime);\n        }) {\n    }\n    context(context<void, void, clock_type>&& o)\n        : lifetime(o.lifetime)\n        , d(make_shared<detail::basic_context<C, E, void>>(o))\n        , m([m = o.m](subscription lifetime){\n            return m(lifetime);\n        }) {\n    }\n    template<class... CN>\n    context(const context<CN...>& o)\n        : lifetime(o.lifetime)\n        , d(make_shared<detail::basic_context<C, E, decay_t<decltype(o.m)>>>(o))\n        , m([m = o.m](subscription lifetime){\n            return m(lifetime);\n        }) {\n    }\n    template<class... CN>\n    context(context<CN...>&& o)\n        : lifetime(o.lifetime)\n        , d(make_shared<detail::basic_context<C, E, decay_t<decltype(o.m)>>>(o))\n        , m([m = o.m](subscription lifetime){\n            return m(lifetime);\n        }) {\n    }\n\n    subscription lifetime;\n    shared_ptr<detail::abstract_context<clock_type, errorvalue_type>> d;\n    detail::make_strand_t<clock_type, E> m;\n    time_point_t<clock_type> now() const {\n        return d->now();\n    }\n    void defer_at(time_point_t<clock_type> at, observer_interface<detail::re_defer_at_t<clock_type>, E> out) const {\n        d->defer_at(at, out);\n    }\n    template<class... TN>\n    context as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class C, class E>\nusing context_interface = context<interface<C, E>>;\n\ntemplate<>\nstruct context<defaults> {\n    using payload_type = void;\n    using Clock = steady_clock;\n    using clock_type = decay_t<Clock>;\n    using make_strand_type = detail::make_immediate<Clock>;\n    using strand_type = decay_t<decltype(declval<make_strand_type>()(declval<subscription>()))>;\n    subscription lifetime;\n    make_strand_type m;\nprivate:\n    struct State {\n        explicit State(strand_type&& s) : s(s) {}\n        explicit State(const strand_type& s) : s(s) {}\n        strand_type s;\n    };\n    state<State> s;    \npublic:\n\n    explicit context(subscription lifetime) \n        : lifetime(lifetime)\n        , m()\n        , s(make_state<State>(lifetime, m(subscription{}))) {\n        lifetime.insert(s.get().s.lifetime);\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    context(subscription lifetime, make_strand_type m, strand_type strand) \n        : lifetime(lifetime)\n        , m(m)\n        , s(make_state<State>(lifetime, strand)) {\n        lifetime.insert(s.get().s.lifetime);\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    time_point_t<clock_type> now() const {\n        return s.get().s.now();\n    }\n    template<class... ON>\n    void defer_at(time_point_t<clock_type> at, observer<ON...> out) const {\n        s.get().s.defer_at(at, out);\n    }\n    template<class E = exception_ptr>\n    context_interface<Clock, E> as_interface() const {\n        using context_t = detail::basic_context<Clock, E, make_strand_type>;\n        return {lifetime, make_shared<context_t>(*this)};\n    }\n};\n\ntemplate<class Clock>\nstruct context<void, void, Clock> {\n    using payload_type = void;\n    using clock_type = decay_t<Clock>;\n    using make_strand_type = detail::make_immediate<Clock>;\n    using strand_type = decay_t<decltype(declval<make_strand_type>()(declval<subscription>()))>;\n    subscription lifetime;\n    make_strand_type m;\nprivate:\n    struct State {\n        explicit State(strand_type&& s) : s(s) {}\n        explicit State(const strand_type& s) : s(s) {}\n        strand_type s;\n    };\n    state<State> s;    \npublic:\n\n    explicit context(subscription lifetime) \n        : lifetime(lifetime)\n        , m()\n        , s(make_state<State>(lifetime, m(subscription{}))) {\n        lifetime.insert(s.get().s.lifetime);\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    context(subscription lifetime, make_strand_type m, strand_type s) \n        : lifetime(lifetime)\n        , m(m)\n        , s(make_state<State>(lifetime, s)) {\n        lifetime.insert(s.get().s.lifetime);\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    time_point_t<clock_type> now() const {\n        return s.get().s.now();\n    }\n    template<class... ON>\n    void defer_at(time_point_t<clock_type> at, observer<ON...> out) const {\n        s.get().s.defer_at(at, out);\n    }\n    template<class E = exception_ptr>\n    context_interface<clock_type, E> as_interface() const {\n        using context_t = detail::basic_context<clock_type, E, make_strand_type>;\n        return {lifetime, make_shared<context_t>(*this)};\n    }\n};\n\ntemplate<class MakeStrand, class Clock>\nstruct context<void, MakeStrand, Clock> {\n    using payload_type = void;\n    using clock_type = decay_t<Clock>;\n    using make_strand_type = decay_t<MakeStrand>;\n    using strand_type = decay_t<decltype(declval<make_strand_type>()(declval<subscription>()))>;\n    subscription lifetime;\n    MakeStrand m;\n\nprivate:\n    struct State {\n        explicit State(strand_type&& s) : s(s) {}\n        explicit State(const strand_type& s) : s(s) {}\n        strand_type s;\n    };\n    state<State> s;  \n\npublic:\n    context(subscription lifetime, make_strand_type m) \n        : lifetime(lifetime)\n        , m(m)\n        , s(make_state<State>(lifetime, m(subscription{}))) {\n        lifetime.insert(s.get().s.lifetime);\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    template<class OP, class OM, class OC>\n    context(subscription lifetime, const context<OP, OM, OC>& o, make_strand_type m) \n        : lifetime(lifetime)\n        , m(m)\n        , s(make_state<State>(lifetime, m(subscription{}))) {\n        lifetime.insert(s.get().s.lifetime);\n        if (lifetime != o.lifetime) {\n            lifetime.insert(o.lifetime);\n        }\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    context(subscription lifetime, make_strand_type m, strand_type s) \n        : lifetime(lifetime)\n        , m(m)\n        , s(make_state<State>(lifetime, s)) {\n        lifetime.insert(this->s.get().s.lifetime);\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = this->s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    time_point_t<clock_type> now() const {\n        return s.get().s.now();\n    }\n    template<class... ON>\n    void defer_at(time_point_t<clock_type> at, observer<ON...> out) const {\n        s.get().s.defer_at(at, out);\n    }\n    template<class E = exception_ptr>\n    context_interface<Clock, E> as_interface() const {\n        using context_t = detail::basic_context<Clock, E, make_strand_type>;\n        return {lifetime, make_shared<context_t>(*this)};\n    }  \n};\n\ntemplate<class Payload, class MakeStrand, class Clock>\nstruct context<Payload, MakeStrand, Clock> {\n    using payload_type = decay_t<Payload>;\n    using clock_type = decay_t<Clock>;\n    using make_strand_type = decay_t<MakeStrand>;\n    using strand_type = decay_t<decltype(declval<make_strand_type>()(declval<subscription>()))>;\n    subscription lifetime;\n    MakeStrand m;\n    context(subscription lifetime, payload_type p, make_strand_type m) \n        : lifetime(lifetime)\n        , m(m)\n        , s(make_state<State>(lifetime, m(subscription{}), move(p))) {\n        lifetime.insert(s.get().s.lifetime);\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    template<class OP, class OM, class OC>\n    context(subscription lifetime, const context<OP, OM, OC>& o, make_strand_type m) \n        : lifetime(lifetime)\n        , m(m)\n        , s(make_state<State>(lifetime, State(m(subscription{}), o))) {\n        lifetime.insert(s.get().s.lifetime);\n        if (lifetime != o.lifetime) {\n            lifetime.insert(o.lifetime);\n        }\n#if !RX_DEFER_IMMEDIATE\n        lifetime.bind_defer([s = s.get().s](function<void()> target){\n            if (s.lifetime.is_stopped()) abort();\n            defer(s, make_observer(subscription{}, [target](auto& ){\n                return target();\n            }));\n        });\n#endif\n    }\n    time_point_t<clock_type> now() const {\n        return s.get().s.now();\n    }\n    template<class... ON>\n    void defer_at(time_point_t<clock_type> at, observer<ON...> out) const {\n        s.get().s.defer_at(at, out);\n    }\n    template<class E = exception_ptr>\n    context_interface<clock_type, E> as_interface() const {\n        using context_t = detail::basic_context<clock_type, E, make_strand_type>;\n        return {lifetime, make_shared<context_t>(*this)};\n    }\n    payload_type& get(){\n        return s.get().p;\n    }\n    const payload_type& get() const {\n        return s.get().p;\n    }\n    operator context<void, make_strand_type, clock_type> () const {\n        return context<void, make_strand_type, clock_type>(lifetime, m, s.get().s);\n    }\nprivate:\n    using Strand = decay_t<decltype(declval<MakeStrand>()(declval<subscription>()))>;\n    struct State {\n        State(strand_type&& s, payload_type&& p) : s(s), stg(std::make_unique<payload_type>(p)), p(*stg) {}\n        State(const strand_type& s, const payload_type& p) : s(s), stg(std::make_unique<payload_type>(p)), p(*stg) {}\n        template<class OP, class OM, class OC>\n        State(strand_type&& s, const context<OP, OM, OC>& o) : s(s), stg(), p(const_cast<context<OP, OM, OC>&>(o).get()) {}\n        strand_type s;\n        std::unique_ptr<payload_type> stg;\n        payload_type& p;\n    };\n    state<State> s;    \n};\n\n\ntemplate<class... CN, class... ON>\nsubscription defer(context<CN...> s, observer<ON...> out) {\n    s.defer_at(s.now(), out);\n    return out.lifetime;\n}\ntemplate<class... CN, class... ON>\nsubscription defer_at(context<CN...> s, clock_time_point_t<context<CN...>> at, observer<ON...> out) {\n    s.defer_at(at, out);\n    return out.lifetime;\n}\ntemplate<class... CN, class... ON>\nsubscription defer_after(context<CN...> s, clock_duration_t<context<CN...>> delay, observer<ON...> out) {\n    s.defer_at(s.now() + delay, out);\n    return out.lifetime;\n}\ntemplate<class... CN, class... ON>\nsubscription defer_periodic(context<CN...> s, clock_time_point_t<context<CN...>> initial, clock_duration_t<context<CN...>> period, observer<ON...> out) {\n    auto lifetime = subscription{};\n    auto state = make_state<pair<long, clock_time_point_t<context<CN...>>>>(lifetime, make_pair(0, initial));\n    s.defer_at(initial, make_observer(\n        out,\n        out.lifetime, \n        [state, period](const observer<ON...>& out, auto& self) mutable {\n            auto& s = state.get();\n            out.next(s.first++);\n            s.second += period;\n            self(s.second);\n        }, detail::pass{}, detail::skip{}));\n    return out.lifetime;\n}\n\ninline auto make_context(subscription lifetime) {\n    auto c = context<>{\n        lifetime\n    };\n    return c;\n}\n\ntemplate<class Payload, class... AN, class C = void_t<decltype(Payload(declval<AN>()...))>>\nauto make_context(subscription lifetime, AN&&... an) {\n    auto c = context<Payload, detail::make_immediate<steady_clock>, steady_clock>{\n        lifetime,\n        Payload(forward<AN>(an)...),\n        detail::make_immediate<steady_clock>{}\n    };\n    return c;\n}\n\ntemplate<class Payload, class Clock, class... AN, class C = void_t<decltype(Payload(declval<AN>()...))>>\nauto make_context(subscription lifetime, AN&&... an) {\n    auto c = context<Payload, detail::make_immediate<Clock>, Clock>{\n        lifetime,\n        Payload(forward<AN>(an)...),\n        detail::make_immediate<Clock>{}\n    };\n    return c;\n}\n\ntemplate<class Payload, class Clock, class MakeStrand, class... AN, class C = void_t<decltype(Payload(declval<AN>()...))>, class CS = detail::for_strand<decltype(declval<MakeStrand>()(declval<subscription>()))>>\nauto make_context(subscription lifetime, MakeStrand&& m, AN&&... an) {\n    auto c = context<Payload, decay_t<MakeStrand>, Clock>{\n        lifetime,\n        Payload(forward<AN>(an)...),\n        forward<MakeStrand>(m)\n    };\n    return c;\n}\n\ntemplate<class MakeStrand, class MS, class Clock, class CS = detail::for_strand<decltype(declval<MakeStrand>()(declval<subscription>()))>>\nauto make_context(subscription lifetime, const context<void, MS, Clock>& o, MakeStrand&& m) {\n    auto c = context<void, decay_t<MakeStrand>, Clock>{\n        lifetime,\n        o,\n        forward<MakeStrand>(m)\n    };\n    return c;\n}\n\ntemplate<class MakeStrand, class Payload, class MS, class Clock, class CS = detail::for_strand<decltype(declval<MakeStrand>()(declval<subscription>()))>>\nauto make_context(subscription lifetime, const context<Payload, MS, Clock>& o, MakeStrand&& m) {\n    auto c = context<Payload, decay_t<MakeStrand>, Clock>{\n        lifetime,\n        o,\n        forward<MakeStrand>(m)\n    };\n    return c;\n}\n\ntemplate<class Clock, class MakeStrand, class C = void_t<typename Clock::time_point>, class CS = detail::for_strand<decltype(declval<MakeStrand>()(declval<subscription>()))>>\nauto make_context(subscription lifetime, MakeStrand&& m) {\n    auto c = context<void, decay_t<MakeStrand>, Clock>{\n        lifetime,\n        forward<MakeStrand>(m)\n    };\n    return c;\n}\n\ntemplate<class MakeStrand, class CS = detail::for_strand<decltype(declval<MakeStrand>()(declval<subscription>()))>>\nauto make_context(subscription lifetime, MakeStrand&& m) {\n    auto c = context<void, decay_t<MakeStrand>, steady_clock>{\n        lifetime,\n        forward<MakeStrand>(m)\n    };\n    return c;\n}\n\ninline auto copy_context(subscription lifetime, const context<>&) {\n    return make_context(lifetime);\n}\n\ntemplate<class Payload, class MakeStrand, class Clock, class C = detail::for_strand<decltype(declval<MakeStrand>()(declval<subscription>()))>>\nauto copy_context(subscription lifetime, const context<Payload, MakeStrand, Clock>& o) {\n    return make_context<Payload, Clock>(lifetime, o.m, o.get());\n}\n\ntemplate<class MakeStrand, class Clock>\nauto copy_context(subscription lifetime, const context<void, MakeStrand, Clock>& o) {\n    return make_context<Clock>(lifetime, o.m);\n}\n\ntemplate<class Clock>\nauto copy_context(subscription lifetime, const context<void, void, Clock>& o) {\n    return make_context<Clock>(lifetime, o.m);\n}\n\ntemplate<class NewMakeStrand, class Payload, class MS, class Clock, class C = void_t<typename Clock::time_point>, class CS = detail::for_strand<decltype(declval<NewMakeStrand>()(declval<subscription>()))>>\nauto copy_context(subscription lifetime, NewMakeStrand&& makeStrand, const context<Payload, MS, Clock>& o) {\n    return make_context<>(lifetime, o, forward<NewMakeStrand>(makeStrand));\n}\n\ntemplate<class NewMakeStrand, class MS, class Clock, class C = void_t<typename Clock::time_point>, class CS = detail::for_strand<decltype(declval<NewMakeStrand>()(declval<subscription>()))>>\nauto copy_context(subscription lifetime, NewMakeStrand&& makeStrand, const context<void, MS, Clock>& o) {\n    return make_context<>(lifetime, o, forward<NewMakeStrand>(makeStrand));\n}\n\ntemplate<class NewMakeStrand, class... CN, class CS = detail::for_strand<decltype(declval<NewMakeStrand>()(declval<subscription>()))>>\nauto copy_context(subscription lifetime, NewMakeStrand&& makeStrand, const context<CN...>&) {\n    return make_context<clock_t<context<CN...>>, NewMakeStrand>(lifetime, forward<NewMakeStrand>(makeStrand));\n}\n\ntemplate<class C, class E>\nauto copy_context(subscription lifetime, const context_interface<C, E>& o) {\n    auto c = context_interface<C, E>{\n        context<void, detail::make_strand_t<C, E>, C> {\n            lifetime,\n            o.m\n        }\n    };\n    return c;\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_context = for_specialization_of_t<T, context>;\n\ntemplate<class T>\nusing not_context = not_specialization_of_t<T, context>;\n\n}\n\n}","#pragma once\n\nnamespace rx {\n\nconst auto intervals = [](auto makeStrand, auto initial, auto period){\n    info(\"new intervals\");\n    return make_observable([=](auto scrb){\n        info(\"intervals bound to subscriber\");\n        return make_starter([=](auto ctx) {\n            info(\"intervals bound to context\");\n            subscription lifetime;\n            ctx.lifetime.insert(lifetime);\n            auto intervalcontext = copy_context(lifetime, makeStrand, ctx);\n            auto r = scrb.create(ctx);\n            info(\"intervals started\");\n            defer_periodic(intervalcontext, initial, period, r);\n            return ctx.lifetime;\n        });\n    });\n};\n\n}","#pragma once\n\nnamespace rx {\n\nconst auto copy_if = [](auto pred){\n    info(\"new copy_if\");\n    return make_lifter([=](auto scbr){\n        info(\"copy_if bound to subscriber\");\n        return make_subscriber([=](auto ctx){\n            info(\"copy_if bound to context lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n            auto r = scbr.create(ctx);\n            info(\"copy_if observer lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(r.lifetime.store.get())));\n            return make_observer(r, r.lifetime, [=](auto& r, auto v){\n                if (pred(v)) r.next(v);\n            });\n        });\n    });\n};\n\n}","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s) {return strlen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz || __sz - __pos < __n)\n        return __npos;\n    if (__n == 0)\n        return __pos;\n    const _CharT* __r = \n        _VSTD::__search(__p + __pos, __p + __sz,\n                        __s, __s + __n, _Traits::eq,\n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p + __ip);\n#else\n    return iterator(__p + __ip);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n  \n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <intsize_t I, class T> class tuple_element; // undefined\ntemplate <intsize_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t _Ip, class ..._Tp>\n  using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <intsize_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <intsize_t I, class... T>\n    typename const tuple_element<I, tuple<T...>>::type &\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <intsize_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr T1 const& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// tuple_size\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_size<tuple<_Tp...> >\n    : public integral_constant<size_t, sizeof...(_Tp)>\n{\n};\n\n// tuple_element\n\ntemplate <size_t _Ip, class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<_Ip, tuple<_Tp...> >\n{\npublic:\n    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Ip, class ..._Tp>\nusing tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;\n#endif\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp, bool=is_empty<_Hp>::value\n#if __has_feature(is_final)\n                                 && !__is_final(_Hp)\n#endif\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)) ||\n                        (is_rvalue_reference<_Hp>::value &&\n                         !is_lvalue_reference<_Tp>::value),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_lvalue_reference<_Hp>::value ||\n                       (is_lvalue_reference<_Hp>::value &&\n                        (is_lvalue_reference<_Tp>::value ||\n                         is_same<typename remove_reference<_Tp>::type,\n                                 reference_wrapper<\n                                    typename remove_reference<_Hp>::type\n                                 >\n                                >::value)),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <bool ...> struct __all;\n\ntemplate <>\nstruct __all<>\n{\n    static const bool value = true;\n};\n\ntemplate <bool _B0, bool ... _Bp>\nstruct __all<_B0, _Bp...>\n{\n    static const bool value = _B0 && __all<_Bp...>::value;\n};\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TYPE_VIS_ONLY tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value)) \n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_constructible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value &&\n                         !__tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value,\n                         bool\n                      >::type =false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              class = typename enable_if\n                      <\n                         sizeof...(_Up) <= sizeof...(_Tp) &&\n                         __tuple_convertible\n                         <\n                            tuple<_Up...>,\n                            typename __make_tuple_types<tuple,\n                                     sizeof...(_Up) < sizeof...(_Tp) ?\n                                        sizeof...(_Up) :\n                                        sizeof...(_Tp)>::type\n                         >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple>::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple>::value &&\n                         !__tuple_convertible<_Tuple, tuple>::value,\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_convertible<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n// get by type\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_helper;\n\n// -- find exactly one\ntemplate <typename _T1, size_t _Idx, typename... _Args>\nstruct __find_exactly_one_t_checker {\n    static constexpr size_t value = _Idx;\n//  Check the rest of the list to make sure there's only one\n    static_assert ( __find_exactly_one_t_helper<_T1, 0, _Args...>::value == -1, \"type can only occur once in type list\" );\n    };\n\n\ntemplate <typename _T1, size_t _Idx>\nstruct __find_exactly_one_t_helper <_T1, _Idx> {\n    static constexpr size_t value = -1;\n    };\n\ntemplate <typename _T1, size_t _Idx, typename _Head, typename... _Args>\nstruct __find_exactly_one_t_helper <_T1, _Idx, _Head, _Args...> {\n    static constexpr size_t value =\n        std::conditional<\n            std::is_same<_T1, _Head>::value,\n            __find_exactly_one_t_checker<_T1, _Idx,   _Args...>,\n            __find_exactly_one_t_helper <_T1, _Idx+1, _Args...>\n        >::type::value;\n    };\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t {\n    static constexpr size_t value = __find_exactly_one_t_helper<_T1, 0, _Args...>::value;\n    static_assert ( value != -1, \"type not found in type list\" );\n    };\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_less<_Ip-1>()(__x, __y) ||\n             (!__tuple_less<_Ip-1>()(__y, __x) && _VSTD::get<_Ip-1>(__x) < _VSTD::get<_Ip-1>(__y));\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","#pragma once\n\nnamespace rx {\n\ntemplate<class Select = defaults>\nstruct subscriber;\n\nnamespace detail {\n    template<class V, class C, class E>\n    using create_t = function<observer_interface<V, E>(context_interface<C, E>)>;\n}\ntemplate<class V, class C, class E>\nstruct subscriber<interface<V, C, E>> {\n    detail::create_t<V, C, E> c;\n    subscriber(const subscriber&) = default;\n    template<class Create>\n    subscriber(const subscriber<Create>& o)\n        : c(o.c) {\n    }\n    observer_interface<V, E> create(context_interface<C, E> ctx) const {\n        return c(ctx);\n    }\n    template<class... TN>\n    subscriber as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class V, class C, class E>\nusing subscriber_interface = subscriber<interface<V, C, E>>;\n\ntemplate<class Create>\nstruct subscriber {\n    Create c;\n    /// \\brief returns observer\n    template<class... CN>\n    auto create(context<CN...> ctx) const {\n        static_assert(detail::is_specialization_of<decltype(c(ctx)), observer>::value, \"subscriber function must return observer!\");\n        return c(ctx);\n    }\n    template<class V, class C = steady_clock, class E = exception_ptr>\n    subscriber_interface<V, C, E> as_interface() const {\n        return {*this};\n    }\n};\n\ntemplate<class Create>\nsubscriber<Create> make_subscriber(Create&& c) {\n    return {forward<Create>(c)};\n}\n\nauto make_subscriber() {\n    return make_subscriber([](auto ctx){return make_observer(ctx.lifetime);});\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_subscriber = for_specialization_of_t<T, subscriber>;\n\ntemplate<class T>\nusing not_subscriber = not_specialization_of_t<T, subscriber>;\n\n}\n\n}","#pragma once\n\nnamespace rx {\n\nconst auto take = [](int n){\n    info(\"new take\");\n    return make_adaptor([=](auto source){\n        info(\"take bound to source\");\n        return make_observable([=](auto scrb){\n            info(\"take bound to subscriber\");\n            return source.bind(\n                make_subscriber([=](auto ctx){\n                    info(\"take bound to context lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n                    auto r = scrb.create(ctx);\n                    auto remaining = make_state<int>(r.lifetime, n);\n                    info(\"take observer lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(r.lifetime.store.get())));\n                    auto lifted = make_observer(r, r.lifetime,\n                        [remaining](auto& r, auto v){\n                            r.next(v);\n                            if (--remaining.get() == 0) {\n                                r.complete();\n                            }\n                        });\n                    if (n == 0) {\n                        lifted.complete();\n                    }\n                    return lifted;\n                }));\n        });\n    });\n};\n\n}","#pragma once\n\nnamespace rx {\n\ntemplate<class T>\nusing payload_t = typename decay_t<T>::payload_type;\n\ntemplate<class Payload = void>\nstruct state;\n\n///\n/// \\brief A subscription represents the scope of an async operation. \n/// Holds a set of nested lifetimes. \n/// Can be used to make state that is scoped to the subscription. \n/// Can call arbitratry functions at the end of the lifetime.\n///\nstruct subscription\n{\nprivate:\n    using lock_type = mutex;\n    using guard_type = unique_lock<lock_type>;\n    struct finish\n    {\n        finish() \n            : stopped(false)\n            , joined(false) {\n        }\n        lock_type lock;\n        set<subscription> others;\n        atomic<bool> stopped;\n        mutex joinlock;\n        atomic<bool> joined;\n        condition_variable joinwake;\n    };\n    struct shared\n    {\n        ~shared(){\n            info(to_string(reinterpret_cast<ptrdiff_t>(this)) + \" - subscription: destroy - \" + to_string(destructors.size()));\n            {\n                auto expired = move(destructors);\n                for (auto& d : expired) {\n                    info(to_string(reinterpret_cast<ptrdiff_t>(this)) + \" - subscription: destroy destructor\");\n                    d();\n                    info(to_string(reinterpret_cast<ptrdiff_t>(this)) + \" - subscription: destroy destructor exit\");\n                }\n            }\n            info(to_string(reinterpret_cast<ptrdiff_t>(this)) + \" - end lifetime\");\n        }\n        explicit shared(const shared_ptr<finish>& ) \n            : defer([](function<void()> target){target();}) {\n            info(to_string(reinterpret_cast<ptrdiff_t>(this)) + \" - new lifetime\");\n        }\n        bool search_scopes(shared_ptr<shared> other) {\n            for(auto& check : scopes) {\n                auto scope = check.lock();\n                if (scope == other) {\n                    return true;\n                }\n                if (scope && scope->search_scopes(other)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function<void(function<void()>)> defer;\n        list<function<void()>> stoppers;\n        list<function<void()>> destructors;\n        list<weak_ptr<shared>> scopes;\n    };\npublic:\n    subscription() : signal(make_shared<finish>()), store(make_shared<shared>(signal)) {}\n    subscription(shared_ptr<shared> st, shared_ptr<finish> s) : signal(s), store(st) {}\n    /// \\brief used to exit loops or otherwise stop work scoped to this subscription.\n    /// \\returns bool - if true do not access any state objects.\n    bool is_stopped() const {\n        return !store || signal->stopped;\n    }\n    /// \\brief \n    void insert(const subscription& s) const {\n        guard_type guard(signal->lock);\n        if (is_stopped()) {\n            s.stop();\n            return;\n        }\n        if (s == *this) {\n            info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: inserting self!\");\n            std::abort();\n        }\n\n        if (store->search_scopes(s.store)) {\n            info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: inserting loop in lifetime!\");\n            std::abort();\n        }\n\n        // nest\n        signal->others.insert(s);\n\n        weak_ptr<shared> p = store;\n        s.store->scopes.push_front(p);\n\n        // unnest when child is stopped\n        weak_ptr<shared> c = s.store;\n        s.insert([p, c, ps = signal, cs = s.signal](){\n            auto storep = p.lock();\n            auto storec = c.lock();\n            if (storep && storec) {\n                //info(to_string(reinterpret_cast<ptrdiff_t>(storep.get())) + \" - subscription: erase nested - \" + to_string(reinterpret_cast<ptrdiff_t>(storec.get())));\n                auto that = subscription(storep, ps);\n                auto s = subscription(storec, cs);\n                that.erase(s);\n            } else {\n                info(\"subscription: erase nested (store missing!)\");\n            }\n        });\n    }\n    /// \\brief \n    void erase(const subscription& s) const {\n        guard_type guard(signal->lock);\n        if (is_stopped()) {\n            return;\n        }\n        if (s == *this) {\n            info(\"subscription: erasing self!\");\n            std::abort();\n        }\n        signal->others.erase(s);\n    }\n    /// \\brief \n    void insert(function<void()> stopper) const {\n        guard_type guard(signal->lock);\n\n        if (is_stopped()) {\n            guard.unlock();\n            stopper();\n            return;\n        }\n\n        store->stoppers.emplace_front(stopper);\n    }\n    /// \\brief \n    template<class Payload, class... ArgN>\n    state<Payload> make_state(ArgN&&... argn) const;\n    /// \\brief \n    state<> make_state() const;\n    /// \\brief \n    state<> copy_state(const state<>&) const;\n    /// \\brief \n    template<class Payload>\n    state<Payload> copy_state(const state<Payload>&) const;\n    /// \\brief \n    void bind_defer(function<void(function<void()>)> d) {\n        guard_type guard(signal->lock);\n        if (is_stopped()) {\n            return;\n        }\n        store->defer = d;\n    }\n    /// \\brief \n    void stop() const {\n        guard_type guard(signal->lock);\n        if (is_stopped()) {\n            return;\n        }\n\n        auto st = move(store);\n        store = nullptr;\n\n        signal->stopped = true;\n        info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: stopped set to true\");\n\n        auto si = signal;\n\n        guard.unlock();\n\n        st->defer([=](){\n            info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: stop\");\n\n            {\n                guard_type guard(si->lock);\n                auto expired = st->stoppers;\n                guard.unlock();\n                for (auto s : expired) {\n                    info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: stop stopper\");\n                    s();\n                    info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: stop stopper exit\");\n                }\n            }\n            {\n                guard_type guard(si->lock);\n                auto expired = si->others;\n                guard.unlock();\n                for (auto o : expired) {\n                    info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: stop other\");\n                    o.stop();\n                    info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: stop other exit\");\n                }\n            }\n            {\n                guard_type guard(si->lock);\n                st->defer = [](function<void()> target){target();};\n                st->stoppers.clear();\n            }\n\n            info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: notify_all\");\n            {\n                unique_lock<mutex> guard(si->joinlock);\n                si->joined = true;\n            }\n            si->joinwake.notify_all();\n            info(to_string(reinterpret_cast<ptrdiff_t>(st.get())) + \" - subscription: stopped\");\n        });\n    }\n    /// \\brief\n    void join() const {\n        info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: join\");\n        {\n            unique_lock<mutex> guard(signal->lock);\n            auto expired = signal->others;\n            guard.unlock();\n            for (auto o : expired) {\n                info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: join other\");\n                o.join();\n                info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: join other exit\");\n            }\n        }\n        {\n            unique_lock<mutex> guard(signal->joinlock);\n            signal->joinwake.wait(guard, [s = this->signal](){return !!s->joined;});\n        }\n        info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: joined \" + (signal->joined ? \"true\" : \"false\"));\n    }\n    shared_ptr<finish> signal;\n    mutable shared_ptr<shared> store;\nprivate:\n    friend bool operator==(const subscription&, const subscription&);\n    friend bool operator<(const subscription&, const subscription&);\n};\nbool operator==(const subscription& lhs, const subscription& rhs) {\n    return lhs.store == rhs.store;\n}\nbool operator!=(const subscription& lhs, const subscription& rhs) {\n    return !(lhs == rhs);\n}\nbool operator<(const subscription& lhs, const subscription& rhs) {\n    return lhs.store < rhs.store;\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_subscription = for_same_t<T, subscription>;\n\ntemplate<class T>\nusing not_subscription = not_same_t<T, subscription>;\n\n}\n\ntemplate<>\nstruct state<void>\n{\n    using payload_type = void;\n    subscription lifetime;\n    explicit state(subscription lifetime) \n        : lifetime(lifetime) {\n    }\n    state(const state&) = default;\n    template<class Payload>\n    state(const state<Payload>& o)\n        : lifetime(o.lifetime) {\n    }\n};\n\ntemplate<class Payload>\nstruct state\n{\n    using payload_type = decay_t<Payload>;\n    subscription lifetime;\n    state(subscription l, Payload* p) : lifetime(l), p(p) {}\n    Payload& get() {\n        return *p;\n    }\n    Payload& get() const {\n        return *p;\n    }\n    explicit operator state<>(){\n        return {lifetime};\n    }\nprivate:\n    mutable Payload* p;\n};\n\nclass lifetime_error : public logic_error {\npublic:\n  explicit lifetime_error (const string& what_arg) : logic_error(what_arg) {}\n  explicit lifetime_error (const char* what_arg) : logic_error(what_arg) {}\n};\n\ntemplate<class Payload, class... ArgN>\nstate<Payload> subscription::make_state(ArgN&&... argn) const {\n    guard_type guard(signal->lock);\n    auto size = store->destructors.size();\n    info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: make_state - \" + to_string(size) + \" \" + typeid(Payload).name());\n    if (is_stopped()) {\n        throw lifetime_error(\"subscription is stopped!\");\n    }\n    auto p = make_unique<Payload>(forward<ArgN>(argn)...);\n    auto result = state<Payload>{*this, p.get()};\n    store->destructors.emplace_front(\n        [d=p.release(), s=store.get(), size]() mutable {\n            info(to_string(reinterpret_cast<ptrdiff_t>(s)) + \" - subscription: destroy make_state - \" + to_string(size) + \" \" + typeid(Payload).name());\n            auto p = d; \n            d = nullptr; \n            delete p;\n            info(to_string(reinterpret_cast<ptrdiff_t>(s)) + \" - subscription: destroy make_state exit - \" + to_string(size) + \" \" + typeid(Payload).name());\n        });\n    return result;\n}\nstate<> subscription::make_state() const {\n    info(to_string(reinterpret_cast<ptrdiff_t>(store.get())) + \" - subscription: make_state\");\n    if (is_stopped()) {\n        throw lifetime_error(\"subscription is stopped!\");\n    }\n    auto result = state<>{*this};\n    return result;\n}\n\nstate<> subscription::copy_state(const state<>&) const{\n    if (is_stopped()) {\n        throw lifetime_error(\"subscription is stopped!\");\n    }\n    return make_state();\n}\n\ntemplate<class Payload>\nstate<Payload> subscription::copy_state(const state<Payload>& o) const{\n    if (is_stopped()) {\n        throw lifetime_error(\"subscription is stopped!\");\n    }\n    return make_state<Payload>(o.get());\n}\n\ntemplate<class Payload, class... ArgN>\nstate<Payload> make_state(subscription lifetime, ArgN... argn) {\n    return lifetime.template make_state<Payload>(forward<ArgN>(argn)...);\n}\ninline state<> make_state(subscription lifetime) {\n    return lifetime.make_state();\n}\n\nstate<> copy_state(subscription lifetime, const state<>&) {\n    return lifetime.make_state();\n}\n\ntemplate<class Payload>\nstate<Payload> copy_state(subscription lifetime, const state<Payload>& o) {\n    return lifetime.template make_state<Payload>(o.get());\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_state = for_specialization_of_t<T, state>;\n\ntemplate<class T>\nusing not_state = not_specialization_of_t<T, state>;\n\n}\n\n}","#pragma once\n\nnamespace rx {\n\ntemplate<class Select = defaults, class... ON>\nstruct observer;\n\nnamespace detail {\n    \ntemplate<class T>\nstruct observer_check : public false_type {};\n\ntemplate<class... ON>\nstruct observer_check<observer<ON...>> : public true_type {};\n\ntemplate<class T>\nusing for_observer = enable_if_t<observer_check<decay_t<T>>::value>;\n\ntemplate<class T>\nusing not_observer = enable_if_t<!observer_check<decay_t<T>>::value>;\n\nauto report = [](auto&& e, auto&& f, auto&&... args){\n    try{f(args...);} catch(...) {e(current_exception());}\n};\n\nauto enforce = [](const subscription& lifetime, auto&& f) {\n    return [&](auto&&... args){\n        if (!lifetime.is_stopped()) f(args...);\n    };\n};\n\nauto end = [](const subscription& lifetime, auto&& f, auto&&... cap) {\n    return [&](auto&&... args){\n        if (!lifetime.is_stopped()) { \n            f(cap..., args...); \n            lifetime.stop();\n        }\n    };\n};\n\nstruct noop\n{\n    template<class V, class CheckV = not_observer<V>>\n    void operator()(V&&) const {\n    }\n    template<class Delegatee, class V>\n    void operator()(const Delegatee& d, V&& v) const {\n        d.next(std::forward<V>(v));\n    }\n    inline void operator()() const {\n    }\n    template<class Delegatee, class Check = for_observer<Delegatee>>\n    void operator()(const Delegatee& d) const {\n        d.complete();\n    }\n};\nstruct ignore\n{\n    template<class E>\n    void operator()(E&&) const {\n    }\n    template<class Delegatee, class E, class CheckD = for_observer<Delegatee>>\n    void operator()(const Delegatee& d, E&& e) const {\n        d.error(forward<E>(e));\n    }\n};\nstruct pass\n{\n    template<class Delegatee, class E, class CheckD = for_observer<Delegatee>>\n    void operator()(const Delegatee& d, E&& e) const {\n        d.error(forward<E>(e));\n    }\n    template<class Delegatee, class Check = for_observer<Delegatee>>\n    void operator()(const Delegatee& d) const {\n        d.complete();\n    }\n};\nstruct skip\n{\n    template<class Delegatee, class E, class CheckD = for_observer<Delegatee>>\n    void operator()(const Delegatee& , E&& ) const {\n    }\n    template<class Delegatee, class Check = for_observer<Delegatee>>\n    void operator()(const Delegatee& ) const {\n    }\n};\nstruct fail\n{\n    template<class E>\n    void operator()(E&&) const {\n        info(\"abort! \");\n        std::abort();\n    }\n    template<class Delegatee, class E, class CheckD = for_observer<Delegatee>>\n    void operator()(const Delegatee&, E&&) const {\n        info(\"abort! \");\n        std::abort();\n    }\n};\n\n}\n\nnamespace detail{\n    template<class V, class E>\n    struct abstract_observer\n    {\n        virtual ~abstract_observer(){}\n        virtual void next(const V&) const = 0;\n        virtual void error(const E&) const = 0;\n        virtual void complete() const = 0;\n    };\n\n    template<class V, class E, class... ON>\n    struct basic_observer : public abstract_observer<V, E> {\n        using value_type = decay_t<V>;\n        using errorvalue_type = decay_t<E>;\n        basic_observer(const observer<ON...>& o)\n            : d(o){\n        }\n        observer<ON...> d;\n        virtual void next(const value_type& v) const {\n            d.next(v);\n        }\n        virtual void error(const errorvalue_type& err) const {\n            d.error(err);\n        }\n        virtual void complete() const {\n            d.complete();\n        }\n    };\n}\ntemplate<class V, class E>\nstruct observer<interface<V, E>> {\n    using value_type = decay_t<V>;\n    using errorvalue_type = decay_t<E>;\n    observer(const observer& o) = default;\n    template<class... ON>\n    observer(const observer<ON...>& o)\n        : lifetime(o.lifetime)\n        , d(make_shared<detail::basic_observer<V, E, ON...>>(o)) {\n    }\n    subscription lifetime;\n    shared_ptr<detail::abstract_observer<value_type, errorvalue_type>> d;\n    void next(const value_type& v) const {\n        d->next(v);\n    }\n    void error(const errorvalue_type& err) const {\n        d->error(err);\n    }\n    void complete() const {\n        d->complete();\n    }\n    template<class... TN>\n    observer as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class V, class E>\nusing observer_interface = observer<interface<V, E>>;\n\n\ntemplate<class Next, class Error, class Complete>\nstruct observer<Next, Error, Complete> {\n    subscription lifetime;\n    mutable Next n;\n    mutable Error e;\n    mutable Complete c;\n    template<class V>\n    void next(V&& v) const {\n        using namespace detail;\n        report(end(lifetime, e), enforce(lifetime, n), std::forward<V>(v));\n    }\n    template<class E>\n    void error(E&& err) const {\n        using namespace detail;\n        report(fail{}, end(lifetime, e), std::forward<E>(err));\n    }\n    void complete() const {\n        using namespace detail;\n        report(fail{}, end(lifetime, c));\n    }\n    template<class V, class E = exception_ptr>\n    observer_interface<V, E> as_interface() const {\n        using observer_t = detail::basic_observer<V, E, Next, Error, Complete>;\n        return {lifetime, make_shared<observer_t>(*this)};\n    }\n};\ntemplate<class Delegatee, class Next, class Error, class Complete>\nstruct observer<Delegatee, Next, Error, Complete> {\n    Delegatee d;\n    subscription lifetime;\n    mutable Next n;\n    mutable Error e;\n    mutable Complete c;\n    template<class V>\n    void next(V&& v) const {\n        using namespace detail;\n        report(end(lifetime, e, d), enforce(lifetime, n), d, std::forward<V>(v));\n    }\n    template<class E>\n    void error(E&& err) const {\n        using namespace detail;\n        report(fail{}, end(lifetime, e), d, std::forward<E>(err));\n    }\n    void complete() const {\n        using namespace detail;\n        report(fail{}, end(lifetime, c), d);\n    }\n    template<class V, class E = exception_ptr>\n    observer_interface<V, E> as_interface() const {\n        using observer_t = detail::basic_observer<V, E, Delegatee, Next, Error, Complete>;\n        return {lifetime, make_shared<observer_t>(*this)};\n    }\n};\n\ntemplate<class Next = detail::noop, class Error = detail::fail, class Complete = detail::noop, \n    class CheckN = detail::not_observer<Next>>\nauto make_observer(subscription lifetime, Next&& n = Next{}, Error&& e = Error{}, Complete&& c = Complete{}) {\n    return observer<decay_t<Next>, decay_t<Error>, decay_t<Complete>>{\n        lifetime,\n        forward<Next>(n), \n        forward<Error>(e), \n        forward<Complete>(c)\n    };\n}\n\ntemplate<class Delegatee, class Next = detail::noop, class Error = detail::pass, class Complete = detail::pass, \n    class CheckD = detail::for_observer<Delegatee>>\nauto make_observer(Delegatee&& d, subscription lifetime, Next&& n = Next{}, Error&& e = Error{}, Complete&& c = Complete{}) {\n    return observer<decay_t<Delegatee>, decay_t<Next>, decay_t<Error>, decay_t<Complete>>{\n        forward<Delegatee>(d), \n        lifetime,\n        forward<Next>(n), \n        forward<Error>(e), \n        forward<Complete>(c)\n    };\n}\n\n}","// -*- C++ -*-\n//===--------------------------- atomic -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ATOMIC\n#define _LIBCPP_ATOMIC\n\n/*\n    atomic synopsis\n\nnamespace std\n{\n\n// order and consistency\n\ntypedef enum memory_order\n{\n    memory_order_relaxed,\n    memory_order_consume,  // load-consume\n    memory_order_acquire,  // load-acquire\n    memory_order_release,  // store-release\n    memory_order_acq_rel,  // store-release load-acquire\n    memory_order_seq_cst   // store-release load-acquire\n} memory_order;\n\ntemplate <class T> T kill_dependency(T y) noexcept;\n\n// lock-free property\n\n#define ATOMIC_BOOL_LOCK_FREE unspecified\n#define ATOMIC_CHAR_LOCK_FREE unspecified\n#define ATOMIC_CHAR16_T_LOCK_FREE unspecified\n#define ATOMIC_CHAR32_T_LOCK_FREE unspecified\n#define ATOMIC_WCHAR_T_LOCK_FREE unspecified\n#define ATOMIC_SHORT_LOCK_FREE unspecified\n#define ATOMIC_INT_LOCK_FREE unspecified\n#define ATOMIC_LONG_LOCK_FREE unspecified\n#define ATOMIC_LLONG_LOCK_FREE unspecified\n#define ATOMIC_POINTER_LOCK_FREE unspecified\n\n// flag type and operations\n\ntypedef struct atomic_flag\n{\n    bool test_and_set(memory_order m = memory_order_seq_cst) volatile noexcept;\n    bool test_and_set(memory_order m = memory_order_seq_cst) noexcept;\n    void clear(memory_order m = memory_order_seq_cst) volatile noexcept;\n    void clear(memory_order m = memory_order_seq_cst) noexcept;\n    atomic_flag()  noexcept = default;\n    atomic_flag(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) volatile = delete;\n} atomic_flag;\n\nbool\n    atomic_flag_test_and_set(volatile atomic_flag* obj) noexcept;\n\nbool\n    atomic_flag_test_and_set(atomic_flag* obj) noexcept;\n\nbool\n    atomic_flag_test_and_set_explicit(volatile atomic_flag* obj,\n                                      memory_order m) noexcept;\n\nbool\n    atomic_flag_test_and_set_explicit(atomic_flag* obj, memory_order m) noexcept;\n\nvoid\n    atomic_flag_clear(volatile atomic_flag* obj) noexcept;\n\nvoid\n    atomic_flag_clear(atomic_flag* obj) noexcept;\n\nvoid\n    atomic_flag_clear_explicit(volatile atomic_flag* obj, memory_order m) noexcept;\n\nvoid\n    atomic_flag_clear_explicit(atomic_flag* obj, memory_order m) noexcept;\n\n#define ATOMIC_FLAG_INIT see below\n#define ATOMIC_VAR_INIT(value) see below\n\ntemplate <class T>\nstruct atomic\n{\n    bool is_lock_free() const volatile noexcept;\n    bool is_lock_free() const noexcept;\n    void store(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;\n    void store(T desr, memory_order m = memory_order_seq_cst) noexcept;\n    T load(memory_order m = memory_order_seq_cst) const volatile noexcept;\n    T load(memory_order m = memory_order_seq_cst) const noexcept;\n    operator T() const volatile noexcept;\n    operator T() const noexcept;\n    T exchange(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;\n    T exchange(T desr, memory_order m = memory_order_seq_cst) noexcept;\n    bool compare_exchange_weak(T& expc, T desr,\n                               memory_order s, memory_order f) volatile noexcept;\n    bool compare_exchange_weak(T& expc, T desr, memory_order s, memory_order f) noexcept;\n    bool compare_exchange_strong(T& expc, T desr,\n                                 memory_order s, memory_order f) volatile noexcept;\n    bool compare_exchange_strong(T& expc, T desr,\n                                 memory_order s, memory_order f) noexcept;\n    bool compare_exchange_weak(T& expc, T desr,\n                               memory_order m = memory_order_seq_cst) volatile noexcept;\n    bool compare_exchange_weak(T& expc, T desr,\n                               memory_order m = memory_order_seq_cst) noexcept;\n    bool compare_exchange_strong(T& expc, T desr,\n                                memory_order m = memory_order_seq_cst) volatile noexcept;\n    bool compare_exchange_strong(T& expc, T desr,\n                                 memory_order m = memory_order_seq_cst) noexcept;\n\n    atomic() noexcept = default;\n    constexpr atomic(T desr) noexcept;\n    atomic(const atomic&) = delete;\n    atomic& operator=(const atomic&) = delete;\n    atomic& operator=(const atomic&) volatile = delete;\n    T operator=(T) volatile noexcept;\n    T operator=(T) noexcept;\n};\n\ntemplate <>\nstruct atomic<integral>\n{\n    bool is_lock_free() const volatile noexcept;\n    bool is_lock_free() const noexcept;\n    void store(integral desr, memory_order m = memory_order_seq_cst) volatile noexcept;\n    void store(integral desr, memory_order m = memory_order_seq_cst) noexcept;\n    integral load(memory_order m = memory_order_seq_cst) const volatile noexcept;\n    integral load(memory_order m = memory_order_seq_cst) const noexcept;\n    operator integral() const volatile noexcept;\n    operator integral() const noexcept;\n    integral exchange(integral desr,\n                      memory_order m = memory_order_seq_cst) volatile noexcept;\n    integral exchange(integral desr, memory_order m = memory_order_seq_cst) noexcept;\n    bool compare_exchange_weak(integral& expc, integral desr,\n                               memory_order s, memory_order f) volatile noexcept;\n    bool compare_exchange_weak(integral& expc, integral desr,\n                               memory_order s, memory_order f) noexcept;\n    bool compare_exchange_strong(integral& expc, integral desr,\n                                 memory_order s, memory_order f) volatile noexcept;\n    bool compare_exchange_strong(integral& expc, integral desr,\n                                 memory_order s, memory_order f) noexcept;\n    bool compare_exchange_weak(integral& expc, integral desr,\n                               memory_order m = memory_order_seq_cst) volatile noexcept;\n    bool compare_exchange_weak(integral& expc, integral desr,\n                               memory_order m = memory_order_seq_cst) noexcept;\n    bool compare_exchange_strong(integral& expc, integral desr,\n                                memory_order m = memory_order_seq_cst) volatile noexcept;\n    bool compare_exchange_strong(integral& expc, integral desr,\n                                 memory_order m = memory_order_seq_cst) noexcept;\n\n    integral\n        fetch_add(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;\n    integral fetch_add(integral op, memory_order m = memory_order_seq_cst) noexcept;\n    integral\n        fetch_sub(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;\n    integral fetch_sub(integral op, memory_order m = memory_order_seq_cst) noexcept;\n    integral\n        fetch_and(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;\n    integral fetch_and(integral op, memory_order m = memory_order_seq_cst) noexcept;\n    integral\n        fetch_or(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;\n    integral fetch_or(integral op, memory_order m = memory_order_seq_cst) noexcept;\n    integral\n        fetch_xor(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;\n    integral fetch_xor(integral op, memory_order m = memory_order_seq_cst) noexcept;\n\n    atomic() noexcept = default;\n    constexpr atomic(integral desr) noexcept;\n    atomic(const atomic&) = delete;\n    atomic& operator=(const atomic&) = delete;\n    atomic& operator=(const atomic&) volatile = delete;\n    integral operator=(integral desr) volatile noexcept;\n    integral operator=(integral desr) noexcept;\n\n    integral operator++(int) volatile noexcept;\n    integral operator++(int) noexcept;\n    integral operator--(int) volatile noexcept;\n    integral operator--(int) noexcept;\n    integral operator++() volatile noexcept;\n    integral operator++() noexcept;\n    integral operator--() volatile noexcept;\n    integral operator--() noexcept;\n    integral operator+=(integral op) volatile noexcept;\n    integral operator+=(integral op) noexcept;\n    integral operator-=(integral op) volatile noexcept;\n    integral operator-=(integral op) noexcept;\n    integral operator&=(integral op) volatile noexcept;\n    integral operator&=(integral op) noexcept;\n    integral operator|=(integral op) volatile noexcept;\n    integral operator|=(integral op) noexcept;\n    integral operator^=(integral op) volatile noexcept;\n    integral operator^=(integral op) noexcept;\n};\n\ntemplate <class T>\nstruct atomic<T*>\n{\n    bool is_lock_free() const volatile noexcept;\n    bool is_lock_free() const noexcept;\n    void store(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;\n    void store(T* desr, memory_order m = memory_order_seq_cst) noexcept;\n    T* load(memory_order m = memory_order_seq_cst) const volatile noexcept;\n    T* load(memory_order m = memory_order_seq_cst) const noexcept;\n    operator T*() const volatile noexcept;\n    operator T*() const noexcept;\n    T* exchange(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;\n    T* exchange(T* desr, memory_order m = memory_order_seq_cst) noexcept;\n    bool compare_exchange_weak(T*& expc, T* desr,\n                               memory_order s, memory_order f) volatile noexcept;\n    bool compare_exchange_weak(T*& expc, T* desr,\n                               memory_order s, memory_order f) noexcept;\n    bool compare_exchange_strong(T*& expc, T* desr,\n                                 memory_order s, memory_order f) volatile noexcept;\n    bool compare_exchange_strong(T*& expc, T* desr,\n                                 memory_order s, memory_order f) noexcept;\n    bool compare_exchange_weak(T*& expc, T* desr,\n                               memory_order m = memory_order_seq_cst) volatile noexcept;\n    bool compare_exchange_weak(T*& expc, T* desr,\n                               memory_order m = memory_order_seq_cst) noexcept;\n    bool compare_exchange_strong(T*& expc, T* desr,\n                                memory_order m = memory_order_seq_cst) volatile noexcept;\n    bool compare_exchange_strong(T*& expc, T* desr,\n                                 memory_order m = memory_order_seq_cst) noexcept;\n    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;\n    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;\n    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;\n    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;\n\n    atomic() noexcept = default;\n    constexpr atomic(T* desr) noexcept;\n    atomic(const atomic&) = delete;\n    atomic& operator=(const atomic&) = delete;\n    atomic& operator=(const atomic&) volatile = delete;\n\n    T* operator=(T*) volatile noexcept;\n    T* operator=(T*) noexcept;\n    T* operator++(int) volatile noexcept;\n    T* operator++(int) noexcept;\n    T* operator--(int) volatile noexcept;\n    T* operator--(int) noexcept;\n    T* operator++() volatile noexcept;\n    T* operator++() noexcept;\n    T* operator--() volatile noexcept;\n    T* operator--() noexcept;\n    T* operator+=(ptrdiff_t op) volatile noexcept;\n    T* operator+=(ptrdiff_t op) noexcept;\n    T* operator-=(ptrdiff_t op) volatile noexcept;\n    T* operator-=(ptrdiff_t op) noexcept;\n};\n\n\ntemplate <class T>\n    bool\n    atomic_is_lock_free(const volatile atomic<T>* obj) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_is_lock_free(const atomic<T>* obj) noexcept;\n\ntemplate <class T>\n    void\n    atomic_init(volatile atomic<T>* obj, T desr) noexcept;\n\ntemplate <class T>\n    void\n    atomic_init(atomic<T>* obj, T desr) noexcept;\n\ntemplate <class T>\n    void\n    atomic_store(volatile atomic<T>* obj, T desr) noexcept;\n\ntemplate <class T>\n    void\n    atomic_store(atomic<T>* obj, T desr) noexcept;\n\ntemplate <class T>\n    void\n    atomic_store_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;\n\ntemplate <class T>\n    void\n    atomic_store_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;\n\ntemplate <class T>\n    T\n    atomic_load(const volatile atomic<T>* obj) noexcept;\n\ntemplate <class T>\n    T\n    atomic_load(const atomic<T>* obj) noexcept;\n\ntemplate <class T>\n    T\n    atomic_load_explicit(const volatile atomic<T>* obj, memory_order m) noexcept;\n\ntemplate <class T>\n    T\n    atomic_load_explicit(const atomic<T>* obj, memory_order m) noexcept;\n\ntemplate <class T>\n    T\n    atomic_exchange(volatile atomic<T>* obj, T desr) noexcept;\n\ntemplate <class T>\n    T\n    atomic_exchange(atomic<T>* obj, T desr) noexcept;\n\ntemplate <class T>\n    T\n    atomic_exchange_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;\n\ntemplate <class T>\n    T\n    atomic_exchange_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_weak(volatile atomic<T>* obj, T* expc, T desr) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_weak(atomic<T>* obj, T* expc, T desr) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_strong(volatile atomic<T>* obj, T* expc, T desr) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_strong(atomic<T>* obj, T* expc, T desr) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_weak_explicit(volatile atomic<T>* obj, T* expc,\n                                          T desr,\n                                          memory_order s, memory_order f) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_weak_explicit(atomic<T>* obj, T* expc, T desr,\n                                          memory_order s, memory_order f) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_strong_explicit(volatile atomic<T>* obj,\n                                            T* expc, T desr,\n                                            memory_order s, memory_order f) noexcept;\n\ntemplate <class T>\n    bool\n    atomic_compare_exchange_strong_explicit(atomic<T>* obj, T* expc,\n                                            T desr,\n                                            memory_order s, memory_order f) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_add(volatile atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_add(atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_add_explicit(volatile atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_add_explicit(atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_sub(volatile atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_sub(atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_sub_explicit(volatile atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_sub_explicit(atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_and(volatile atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_and(atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_and_explicit(volatile atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_and_explicit(atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_or(volatile atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_or(atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_or_explicit(volatile atomic<Integral>* obj, Integral op,\n                             memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_or_explicit(atomic<Integral>* obj, Integral op,\n                             memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_xor(volatile atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_xor(atomic<Integral>* obj, Integral op) noexcept;\n\ntemplate <class Integral>\n    Integral\n    atomic_fetch_xor_explicit(volatile atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\ntemplate <class Integral>\n    Integral\n    atomic_fetch_xor_explicit(atomic<Integral>* obj, Integral op,\n                              memory_order m) noexcept;\n\ntemplate <class T>\n    T*\n    atomic_fetch_add(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;\n\ntemplate <class T>\n    T*\n    atomic_fetch_add(atomic<T*>* obj, ptrdiff_t op) noexcept;\n\ntemplate <class T>\n    T*\n    atomic_fetch_add_explicit(volatile atomic<T*>* obj, ptrdiff_t op,\n                              memory_order m) noexcept;\ntemplate <class T>\n    T*\n    atomic_fetch_add_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;\n\ntemplate <class T>\n    T*\n    atomic_fetch_sub(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;\n\ntemplate <class T>\n    T*\n    atomic_fetch_sub(atomic<T*>* obj, ptrdiff_t op) noexcept;\n\ntemplate <class T>\n    T*\n    atomic_fetch_sub_explicit(volatile atomic<T*>* obj, ptrdiff_t op,\n                              memory_order m) noexcept;\ntemplate <class T>\n    T*\n    atomic_fetch_sub_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;\n\n// Atomics for standard typedef types\n\ntypedef atomic<bool>               atomic_bool;\ntypedef atomic<char>               atomic_char;\ntypedef atomic<signed char>        atomic_schar;\ntypedef atomic<unsigned char>      atomic_uchar;\ntypedef atomic<short>              atomic_short;\ntypedef atomic<unsigned short>     atomic_ushort;\ntypedef atomic<int>                atomic_int;\ntypedef atomic<unsigned int>       atomic_uint;\ntypedef atomic<long>               atomic_long;\ntypedef atomic<unsigned long>      atomic_ulong;\ntypedef atomic<long long>          atomic_llong;\ntypedef atomic<unsigned long long> atomic_ullong;\ntypedef atomic<char16_t>           atomic_char16_t;\ntypedef atomic<char32_t>           atomic_char32_t;\ntypedef atomic<wchar_t>            atomic_wchar_t;\n\ntypedef atomic<int_least8_t>   atomic_int_least8_t;\ntypedef atomic<uint_least8_t>  atomic_uint_least8_t;\ntypedef atomic<int_least16_t>  atomic_int_least16_t;\ntypedef atomic<uint_least16_t> atomic_uint_least16_t;\ntypedef atomic<int_least32_t>  atomic_int_least32_t;\ntypedef atomic<uint_least32_t> atomic_uint_least32_t;\ntypedef atomic<int_least64_t>  atomic_int_least64_t;\ntypedef atomic<uint_least64_t> atomic_uint_least64_t;\n\ntypedef atomic<int_fast8_t>   atomic_int_fast8_t;\ntypedef atomic<uint_fast8_t>  atomic_uint_fast8_t;\ntypedef atomic<int_fast16_t>  atomic_int_fast16_t;\ntypedef atomic<uint_fast16_t> atomic_uint_fast16_t;\ntypedef atomic<int_fast32_t>  atomic_int_fast32_t;\ntypedef atomic<uint_fast32_t> atomic_uint_fast32_t;\ntypedef atomic<int_fast64_t>  atomic_int_fast64_t;\ntypedef atomic<uint_fast64_t> atomic_uint_fast64_t;\n\ntypedef atomic<intptr_t>  atomic_intptr_t;\ntypedef atomic<uintptr_t> atomic_uintptr_t;\ntypedef atomic<size_t>    atomic_size_t;\ntypedef atomic<ptrdiff_t> atomic_ptrdiff_t;\ntypedef atomic<intmax_t>  atomic_intmax_t;\ntypedef atomic<uintmax_t> atomic_uintmax_t;\n\n// fences\n\nvoid atomic_thread_fence(memory_order m) noexcept;\nvoid atomic_signal_fence(memory_order m) noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <cstddef>\n#include <cstdint>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#ifdef _LIBCPP_HAS_NO_THREADS\n#error <atomic> is not supported on this single threaded system\n#else // !_LIBCPP_HAS_NO_THREADS\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if !__has_feature(cxx_atomic) && _GNUC_VER < 407\n#error <atomic> is not implemented\n#else\n\ntypedef enum memory_order\n{\n    memory_order_relaxed, memory_order_consume, memory_order_acquire,\n    memory_order_release, memory_order_acq_rel, memory_order_seq_cst\n} memory_order;\n\n#if _GNUC_VER >= 407\nnamespace __gcc_atomic {\ntemplate <typename T>\nstruct __gcc_atomic_t {\n  __gcc_atomic_t() _NOEXCEPT {}\n  explicit __gcc_atomic_t(T value) _NOEXCEPT : __a_value(value) {}\n  T __a_value;\n};\n#define _Atomic(x) __gcc_atomic::__gcc_atomic_t<x>\n\ntemplate <typename T> T __create();\n\ntemplate <typename __Tp, typename __Td>\ntypename enable_if<sizeof(__Tp()->__a_value = __create<__Td>()), char>::type\n    __test_atomic_assignable(int);\ntemplate <typename T, typename U>\n__two __test_atomic_assignable(...);\n\ntemplate <typename __Tp, typename __Td>\nstruct __can_assign {\n  static const bool value =\n      sizeof(__test_atomic_assignable<__Tp, __Td>(1)) == sizeof(char);\n};\n\nstatic inline constexpr int __to_gcc_order(memory_order __order) {\n  // Avoid switch statement to make this a constexpr.\n  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:\n         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:\n          (__order == memory_order_release ? __ATOMIC_RELEASE:\n           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:\n            (__order == memory_order_acq_rel ? __ATOMIC_ACQ_REL:\n              __ATOMIC_CONSUME))));\n}\n\n} // namespace __gcc_atomic\n\ntemplate <typename _Tp>\nstatic inline\ntypename enable_if<\n    __gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value>::type\n__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {\n  __a->__a_value = __val;\n}\n\ntemplate <typename _Tp>\nstatic inline\ntypename enable_if<\n    !__gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value &&\n     __gcc_atomic::__can_assign<         _Atomic(_Tp)*, _Tp>::value>::type\n__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {\n  // [atomics.types.generic]p1 guarantees _Tp is trivially copyable. Because\n  // the default operator= in an object is not volatile, a byte-by-byte copy\n  // is required.\n  volatile char* to = reinterpret_cast<volatile char*>(&__a->__a_value);\n  volatile char* end = to + sizeof(_Tp);\n  char* from = reinterpret_cast<char*>(&__val);\n  while (to != end) {\n    *to++ = *from++;\n  }\n}\n\ntemplate <typename _Tp>\nstatic inline void __c11_atomic_init(_Atomic(_Tp)* __a,  _Tp __val) {\n  __a->__a_value = __val;\n}\n\nstatic inline void __c11_atomic_thread_fence(memory_order __order) {\n  __atomic_thread_fence(__gcc_atomic::__to_gcc_order(__order));\n}\n\nstatic inline void __c11_atomic_signal_fence(memory_order __order) {\n  __atomic_signal_fence(__gcc_atomic::__to_gcc_order(__order));\n}\n\nstatic inline bool __c11_atomic_is_lock_free(size_t __size) {\n  return __atomic_is_lock_free(__size, 0);\n}\n\ntemplate <typename _Tp>\nstatic inline void __c11_atomic_store(volatile _Atomic(_Tp)* __a,  _Tp __val,\n                                      memory_order __order) {\n  return __atomic_store(&__a->__a_value, &__val,\n                        __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline void __c11_atomic_store(_Atomic(_Tp)* __a,  _Tp __val,\n                                      memory_order __order) {\n  return __atomic_store(&__a->__a_value, &__val,\n                        __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_load(volatile _Atomic(_Tp)* __a,\n                                    memory_order __order) {\n  _Tp __ret;\n  __atomic_load(&__a->__a_value, &__ret,\n                __gcc_atomic::__to_gcc_order(__order));\n  return __ret;\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_load(_Atomic(_Tp)* __a, memory_order __order) {\n  _Tp __ret;\n  __atomic_load(&__a->__a_value, &__ret,\n                __gcc_atomic::__to_gcc_order(__order));\n  return __ret;\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_exchange(volatile _Atomic(_Tp)* __a,\n                                        _Tp __value, memory_order __order) {\n  _Tp __ret;\n  __atomic_exchange(&__a->__a_value, &__value, &__ret,\n                    __gcc_atomic::__to_gcc_order(__order));\n  return __ret;\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_exchange(_Atomic(_Tp)* __a, _Tp __value,\n                                        memory_order __order) {\n  _Tp __ret;\n  __atomic_exchange(&__a->__a_value, &__value, &__ret,\n                    __gcc_atomic::__to_gcc_order(__order));\n  return __ret;\n}\n\ntemplate <typename _Tp>\nstatic inline bool __c11_atomic_compare_exchange_strong(\n    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,\n    memory_order __success, memory_order __failure) {\n  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,\n                                   false,\n                                   __gcc_atomic::__to_gcc_order(__success),\n                                   __gcc_atomic::__to_gcc_order(__failure));\n}\n\ntemplate <typename _Tp>\nstatic inline bool __c11_atomic_compare_exchange_strong(\n    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,\n    memory_order __failure) {\n  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,\n                                   false,\n                                   __gcc_atomic::__to_gcc_order(__success),\n                                   __gcc_atomic::__to_gcc_order(__failure));\n}\n\ntemplate <typename _Tp>\nstatic inline bool __c11_atomic_compare_exchange_weak(\n    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,\n    memory_order __success, memory_order __failure) {\n  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,\n                                   true,\n                                   __gcc_atomic::__to_gcc_order(__success),\n                                   __gcc_atomic::__to_gcc_order(__failure));\n}\n\ntemplate <typename _Tp>\nstatic inline bool __c11_atomic_compare_exchange_weak(\n    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,\n    memory_order __failure) {\n  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,\n                                   true,\n                                   __gcc_atomic::__to_gcc_order(__success),\n                                   __gcc_atomic::__to_gcc_order(__failure));\n}\n\ntemplate <typename _Tp>\nstruct __skip_amt { enum {value = 1}; };\n\ntemplate <typename _Tp>\nstruct __skip_amt<_Tp*> { enum {value = sizeof(_Tp)}; };\n\n// FIXME: Haven't figured out what the spec says about using arrays with\n// atomic_fetch_add. Force a failure rather than creating bad behavior.\ntemplate <typename _Tp>\nstruct __skip_amt<_Tp[]> { };\ntemplate <typename _Tp, int n>\nstruct __skip_amt<_Tp[n]> { };\n\ntemplate <typename _Tp, typename _Td>\nstatic inline _Tp __c11_atomic_fetch_add(volatile _Atomic(_Tp)* __a,\n                                         _Td __delta, memory_order __order) {\n  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp, typename _Td>\nstatic inline _Tp __c11_atomic_fetch_add(_Atomic(_Tp)* __a, _Td __delta,\n                                         memory_order __order) {\n  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp, typename _Td>\nstatic inline _Tp __c11_atomic_fetch_sub(volatile _Atomic(_Tp)* __a,\n                                         _Td __delta, memory_order __order) {\n  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp, typename _Td>\nstatic inline _Tp __c11_atomic_fetch_sub(_Atomic(_Tp)* __a, _Td __delta,\n                                         memory_order __order) {\n  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_fetch_and(volatile _Atomic(_Tp)* __a,\n                                         _Tp __pattern, memory_order __order) {\n  return __atomic_fetch_and(&__a->__a_value, __pattern,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_fetch_and(_Atomic(_Tp)* __a,\n                                         _Tp __pattern, memory_order __order) {\n  return __atomic_fetch_and(&__a->__a_value, __pattern,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_fetch_or(volatile _Atomic(_Tp)* __a,\n                                        _Tp __pattern, memory_order __order) {\n  return __atomic_fetch_or(&__a->__a_value, __pattern,\n                           __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_fetch_or(_Atomic(_Tp)* __a, _Tp __pattern,\n                                        memory_order __order) {\n  return __atomic_fetch_or(&__a->__a_value, __pattern,\n                           __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_fetch_xor(volatile _Atomic(_Tp)* __a,\n                                         _Tp __pattern, memory_order __order) {\n  return __atomic_fetch_xor(&__a->__a_value, __pattern,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n\ntemplate <typename _Tp>\nstatic inline _Tp __c11_atomic_fetch_xor(_Atomic(_Tp)* __a, _Tp __pattern,\n                                         memory_order __order) {\n  return __atomic_fetch_xor(&__a->__a_value, __pattern,\n                            __gcc_atomic::__to_gcc_order(__order));\n}\n#endif // _GNUC_VER >= 407\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nkill_dependency(_Tp __y) _NOEXCEPT\n{\n    return __y;\n}\n\n// general atomic<T>\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>\nstruct __atomic_base  // false\n{\n    mutable _Atomic(_Tp) __a_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_lock_free() const volatile _NOEXCEPT\n        {return __c11_atomic_is_lock_free(sizeof(_Tp));}\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_lock_free() const _NOEXCEPT\n        {return __c11_atomic_is_lock_free(sizeof(_Tp));}\n    _LIBCPP_INLINE_VISIBILITY\n    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {__c11_atomic_store(&__a_, __d, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    void store(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {__c11_atomic_store(&__a_, __d, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp load(memory_order __m = memory_order_seq_cst) const volatile _NOEXCEPT\n        {return __c11_atomic_load(&__a_, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp load(memory_order __m = memory_order_seq_cst) const _NOEXCEPT\n        {return __c11_atomic_load(&__a_, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    operator _Tp() const volatile _NOEXCEPT {return load();}\n    _LIBCPP_INLINE_VISIBILITY\n    operator _Tp() const _NOEXCEPT          {return load();}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_exchange(&__a_, __d, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_exchange(&__a_, __d, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_weak(_Tp& __e, _Tp __d,\n                               memory_order __s, memory_order __f) volatile _NOEXCEPT\n        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_weak(_Tp& __e, _Tp __d,\n                               memory_order __s, memory_order __f) _NOEXCEPT\n        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_strong(_Tp& __e, _Tp __d,\n                                 memory_order __s, memory_order __f) volatile _NOEXCEPT\n        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_strong(_Tp& __e, _Tp __d,\n                                 memory_order __s, memory_order __f) _NOEXCEPT\n        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_weak(_Tp& __e, _Tp __d,\n                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_weak(_Tp& __e, _Tp __d,\n                               memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_strong(_Tp& __e, _Tp __d,\n                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool compare_exchange_strong(_Tp& __e, _Tp __d,\n                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}\n\n    _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    __atomic_base() _NOEXCEPT = default;\n#else\n    __atomic_base() _NOEXCEPT : __a_() {}\n#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __a_(__d) {}\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __atomic_base(const __atomic_base&) = delete;\n    __atomic_base& operator=(const __atomic_base&) = delete;\n    __atomic_base& operator=(const __atomic_base&) volatile = delete;\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\nprivate:\n    __atomic_base(const __atomic_base&);\n    __atomic_base& operator=(const __atomic_base&);\n    __atomic_base& operator=(const __atomic_base&) volatile;\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n};\n\n// atomic<Integral>\n\ntemplate <class _Tp>\nstruct __atomic_base<_Tp, true>\n    : public __atomic_base<_Tp, false>\n{\n    typedef __atomic_base<_Tp, false> __base;\n    _LIBCPP_INLINE_VISIBILITY\n    __atomic_base() _NOEXCEPT _LIBCPP_DEFAULT\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __base(__d) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator++(int) _NOEXCEPT               {return fetch_add(_Tp(1));}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator--(int) volatile _NOEXCEPT      {return fetch_sub(_Tp(1));}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator--(int) _NOEXCEPT               {return fetch_sub(_Tp(1));}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator++() volatile _NOEXCEPT         {return fetch_add(_Tp(1)) + _Tp(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator++() _NOEXCEPT                  {return fetch_add(_Tp(1)) + _Tp(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator--() volatile _NOEXCEPT         {return fetch_sub(_Tp(1)) - _Tp(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator--() _NOEXCEPT                  {return fetch_sub(_Tp(1)) - _Tp(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator+=(_Tp __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator+=(_Tp __op) _NOEXCEPT          {return fetch_add(__op) + __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator-=(_Tp __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator-=(_Tp __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator&=(_Tp __op) volatile _NOEXCEPT {return fetch_and(__op) & __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator&=(_Tp __op) _NOEXCEPT          {return fetch_and(__op) & __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator|=(_Tp __op) volatile _NOEXCEPT {return fetch_or(__op) | __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator|=(_Tp __op) _NOEXCEPT          {return fetch_or(__op) | __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator^=(_Tp __op) volatile _NOEXCEPT {return fetch_xor(__op) ^ __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator^=(_Tp __op) _NOEXCEPT          {return fetch_xor(__op) ^ __op;}\n};\n\n// atomic<T>\n\ntemplate <class _Tp>\nstruct atomic\n    : public __atomic_base<_Tp>\n{\n    typedef __atomic_base<_Tp> __base;\n    _LIBCPP_INLINE_VISIBILITY\n    atomic() _NOEXCEPT _LIBCPP_DEFAULT\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator=(_Tp __d) volatile _NOEXCEPT\n        {__base::store(__d); return __d;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp operator=(_Tp __d) _NOEXCEPT\n        {__base::store(__d); return __d;}\n};\n\n// atomic<T*>\n\ntemplate <class _Tp>\nstruct atomic<_Tp*>\n    : public __atomic_base<_Tp*>\n{\n    typedef __atomic_base<_Tp*> __base;\n    _LIBCPP_INLINE_VISIBILITY\n    atomic() _NOEXCEPT _LIBCPP_DEFAULT\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR atomic(_Tp* __d) _NOEXCEPT : __base(__d) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator=(_Tp* __d) volatile _NOEXCEPT\n        {__base::store(__d); return __d;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator=(_Tp* __d) _NOEXCEPT\n        {__base::store(__d); return __d;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)\n                                                                        volatile _NOEXCEPT\n        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)\n                                                                        volatile _NOEXCEPT\n        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator++(int) _NOEXCEPT                     {return fetch_add(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator--(int) _NOEXCEPT                     {return fetch_sub(1);}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}\n};\n\n// atomic_is_lock_free\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const volatile atomic<_Tp>* __o) _NOEXCEPT\n{\n    return __o->is_lock_free();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const atomic<_Tp>* __o) _NOEXCEPT\n{\n    return __o->is_lock_free();\n}\n\n// atomic_init\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_init(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT\n{\n    __c11_atomic_init(&__o->__a_, __d);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_init(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT\n{\n    __c11_atomic_init(&__o->__a_, __d);\n}\n\n// atomic_store\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT\n{\n    __o->store(__d);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT\n{\n    __o->store(__d);\n}\n\n// atomic_store_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT\n{\n    __o->store(__d, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT\n{\n    __o->store(__d, __m);\n}\n\n// atomic_load\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_load(const volatile atomic<_Tp>* __o) _NOEXCEPT\n{\n    return __o->load();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_load(const atomic<_Tp>* __o) _NOEXCEPT\n{\n    return __o->load();\n}\n\n// atomic_load_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) _NOEXCEPT\n{\n    return __o->load(__m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) _NOEXCEPT\n{\n    return __o->load(__m);\n}\n\n// atomic_exchange\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT\n{\n    return __o->exchange(__d);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_exchange(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT\n{\n    return __o->exchange(__d);\n}\n\n// atomic_exchange_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT\n{\n    return __o->exchange(__d, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\natomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT\n{\n    return __o->exchange(__d, __m);\n}\n\n// atomic_compare_exchange_weak\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT\n{\n    return __o->compare_exchange_weak(*__e, __d);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT\n{\n    return __o->compare_exchange_weak(*__e, __d);\n}\n\n// atomic_compare_exchange_strong\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT\n{\n    return __o->compare_exchange_strong(*__e, __d);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT\n{\n    return __o->compare_exchange_strong(*__e, __d);\n}\n\n// atomic_compare_exchange_weak_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,\n                                      _Tp __d,\n                                      memory_order __s, memory_order __f) _NOEXCEPT\n{\n    return __o->compare_exchange_weak(*__e, __d, __s, __f);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,\n                                      memory_order __s, memory_order __f) _NOEXCEPT\n{\n    return __o->compare_exchange_weak(*__e, __d, __s, __f);\n}\n\n// atomic_compare_exchange_strong_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,\n                                        _Tp* __e, _Tp __d,\n                                        memory_order __s, memory_order __f) _NOEXCEPT\n{\n    return __o->compare_exchange_strong(*__e, __d, __s, __f);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,\n                                        _Tp __d,\n                                        memory_order __s, memory_order __f) _NOEXCEPT\n{\n    return __o->compare_exchange_strong(*__e, __d, __s, __f);\n}\n\n// atomic_fetch_add\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_add(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_add(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_add(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT\n{\n    return __o->fetch_add(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT\n{\n    return __o->fetch_add(__op);\n}\n\n// atomic_fetch_add_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_add(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_add(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,\n                          memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_add(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_add(__op, __m);\n}\n\n// atomic_fetch_sub\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_sub(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_sub(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT\n{\n    return __o->fetch_sub(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT\n{\n    return __o->fetch_sub(__op);\n}\n\n// atomic_fetch_sub_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_sub(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_sub(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,\n                          memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_sub(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\natomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_sub(__op, __m);\n}\n\n// atomic_fetch_and\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_and(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_and(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_and(__op);\n}\n\n// atomic_fetch_and_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_and(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_and(__op, __m);\n}\n\n// atomic_fetch_or\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_or(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_or(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_or(__op);\n}\n\n// atomic_fetch_or_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_or(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_or(__op, __m);\n}\n\n// atomic_fetch_xor\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_xor(__op);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT\n{\n    return __o->fetch_xor(__op);\n}\n\n// atomic_fetch_xor_explicit\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_xor(__op, __m);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,\n    _Tp\n>::type\natomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT\n{\n    return __o->fetch_xor(__op, __m);\n}\n\n// flag type and operations\n\ntypedef struct atomic_flag\n{\n    _Atomic(bool) __a_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {return __c11_atomic_exchange(&__a_, true, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool test_and_set(memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {return __c11_atomic_exchange(&__a_, true, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT\n        {__c11_atomic_store(&__a_, false, __m);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear(memory_order __m = memory_order_seq_cst) _NOEXCEPT\n        {__c11_atomic_store(&__a_, false, __m);}\n\n    _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    atomic_flag() _NOEXCEPT = default;\n#else\n    atomic_flag() _NOEXCEPT : __a_() {}\n#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    atomic_flag(bool __b) _NOEXCEPT : __a_(__b) {}\n\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    atomic_flag(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) = delete;\n    atomic_flag& operator=(const atomic_flag&) volatile = delete;\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\nprivate:\n    atomic_flag(const atomic_flag&);\n    atomic_flag& operator=(const atomic_flag&);\n    atomic_flag& operator=(const atomic_flag&) volatile;\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n} atomic_flag;\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_flag_test_and_set(volatile atomic_flag* __o) _NOEXCEPT\n{\n    return __o->test_and_set();\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_flag_test_and_set(atomic_flag* __o) _NOEXCEPT\n{\n    return __o->test_and_set();\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT\n{\n    return __o->test_and_set(__m);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT\n{\n    return __o->test_and_set(__m);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_flag_clear(volatile atomic_flag* __o) _NOEXCEPT\n{\n    __o->clear();\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_flag_clear(atomic_flag* __o) _NOEXCEPT\n{\n    __o->clear();\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT\n{\n    __o->clear(__m);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT\n{\n    __o->clear(__m);\n}\n\n// fences\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_thread_fence(memory_order __m) _NOEXCEPT\n{\n    __c11_atomic_thread_fence(__m);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_signal_fence(memory_order __m) _NOEXCEPT\n{\n    __c11_atomic_signal_fence(__m);\n}\n\n// Atomics for standard typedef types\n\ntypedef atomic<bool>               atomic_bool;\ntypedef atomic<char>               atomic_char;\ntypedef atomic<signed char>        atomic_schar;\ntypedef atomic<unsigned char>      atomic_uchar;\ntypedef atomic<short>              atomic_short;\ntypedef atomic<unsigned short>     atomic_ushort;\ntypedef atomic<int>                atomic_int;\ntypedef atomic<unsigned int>       atomic_uint;\ntypedef atomic<long>               atomic_long;\ntypedef atomic<unsigned long>      atomic_ulong;\ntypedef atomic<long long>          atomic_llong;\ntypedef atomic<unsigned long long> atomic_ullong;\ntypedef atomic<char16_t>           atomic_char16_t;\ntypedef atomic<char32_t>           atomic_char32_t;\ntypedef atomic<wchar_t>            atomic_wchar_t;\n\ntypedef atomic<int_least8_t>   atomic_int_least8_t;\ntypedef atomic<uint_least8_t>  atomic_uint_least8_t;\ntypedef atomic<int_least16_t>  atomic_int_least16_t;\ntypedef atomic<uint_least16_t> atomic_uint_least16_t;\ntypedef atomic<int_least32_t>  atomic_int_least32_t;\ntypedef atomic<uint_least32_t> atomic_uint_least32_t;\ntypedef atomic<int_least64_t>  atomic_int_least64_t;\ntypedef atomic<uint_least64_t> atomic_uint_least64_t;\n\ntypedef atomic<int_fast8_t>   atomic_int_fast8_t;\ntypedef atomic<uint_fast8_t>  atomic_uint_fast8_t;\ntypedef atomic<int_fast16_t>  atomic_int_fast16_t;\ntypedef atomic<uint_fast16_t> atomic_uint_fast16_t;\ntypedef atomic<int_fast32_t>  atomic_int_fast32_t;\ntypedef atomic<uint_fast32_t> atomic_uint_fast32_t;\ntypedef atomic<int_fast64_t>  atomic_int_fast64_t;\ntypedef atomic<uint_fast64_t> atomic_uint_fast64_t;\n\ntypedef atomic<intptr_t>  atomic_intptr_t;\ntypedef atomic<uintptr_t> atomic_uintptr_t;\ntypedef atomic<size_t>    atomic_size_t;\ntypedef atomic<ptrdiff_t> atomic_ptrdiff_t;\ntypedef atomic<intmax_t>  atomic_intmax_t;\ntypedef atomic<uintmax_t> atomic_uintmax_t;\n\n#define ATOMIC_FLAG_INIT {false}\n#define ATOMIC_VAR_INIT(__v) {__v}\n\n// lock-free property\n\n#define ATOMIC_BOOL_LOCK_FREE      __GCC_ATOMIC_BOOL_LOCK_FREE\n#define ATOMIC_CHAR_LOCK_FREE      __GCC_ATOMIC_CHAR_LOCK_FREE\n#define ATOMIC_CHAR16_T_LOCK_FREE  __GCC_ATOMIC_CHAR16_T_LOCK_FREE\n#define ATOMIC_CHAR32_T_LOCK_FREE  __GCC_ATOMIC_CHAR32_T_LOCK_FREE\n#define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE\n#define ATOMIC_SHORT_LOCK_FREE     __GCC_ATOMIC_SHORT_LOCK_FREE\n#define ATOMIC_INT_LOCK_FREE       __GCC_ATOMIC_INT_LOCK_FREE\n#define ATOMIC_LONG_LOCK_FREE      __GCC_ATOMIC_LONG_LOCK_FREE\n#define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE\n#define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE\n\n#endif  //  !__has_feature(cxx_atomic)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // !_LIBCPP_HAS_NO_THREADS\n\n#endif  // _LIBCPP_ATOMIC\n","// -*- C++ -*-\n//===---------------------------- chrono ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CHRONO\n#define _LIBCPP_CHRONO\n\n/*\n    chrono synopsis\n\nnamespace std\n{\nnamespace chrono\n{\n\ntemplate <class ToDuration, class Rep, class Period>\nconstexpr\nToDuration\nduration_cast(const duration<Rep, Period>& fd);\n\ntemplate <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};\n\ntemplate <class Rep>\nstruct duration_values\n{\npublic:\n    static constexpr Rep zero();\n    static constexpr Rep max();\n    static constexpr Rep min();\n};\n\n// duration\n\ntemplate <class Rep, class Period = ratio<1>>\nclass duration\n{\n    static_assert(!__is_duration<Rep>::value, \"A duration representation can not be a duration\");\n    static_assert(__is_ratio<Period>::value, \"Second template parameter of duration must be a std::ratio\");\n    static_assert(Period::num > 0, \"duration period must be positive\");\npublic:\n    typedef Rep rep;\n    typedef Period period;\n\n    constexpr duration() = default;\n    template <class Rep2>\n        constexpr explicit duration(const Rep2& r,\n            typename enable_if\n            <\n               is_convertible<Rep2, rep>::value &&\n               (treat_as_floating_point<rep>::value ||\n               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)\n            >::type* = 0);\n\n    // conversions\n    template <class Rep2, class Period2>\n        constexpr duration(const duration<Rep2, Period2>& d,\n            typename enable_if\n            <\n                treat_as_floating_point<rep>::value ||\n                ratio_divide<Period2, period>::type::den == 1\n            >::type* = 0);\n\n    // observer\n\n    constexpr rep count() const;\n\n    // arithmetic\n\n    constexpr duration  operator+() const;\n    constexpr duration  operator-() const;\n    duration& operator++();\n    duration  operator++(int);\n    duration& operator--();\n    duration  operator--(int);\n\n    duration& operator+=(const duration& d);\n    duration& operator-=(const duration& d);\n\n    duration& operator*=(const rep& rhs);\n    duration& operator/=(const rep& rhs);\n\n    // special values\n\n    static constexpr duration zero();\n    static constexpr duration min();\n    static constexpr duration max();\n};\n\ntypedef duration<long long,         nano> nanoseconds;\ntypedef duration<long long,        micro> microseconds;\ntypedef duration<long long,        milli> milliseconds;\ntypedef duration<long long              > seconds;\ntypedef duration<     long, ratio<  60> > minutes;\ntypedef duration<     long, ratio<3600> > hours;\n\ntemplate <class Clock, class Duration = typename Clock::duration>\nclass time_point\n{\npublic:\n    typedef Clock                     clock;\n    typedef Duration                  duration;\n    typedef typename duration::rep    rep;\n    typedef typename duration::period period;\nprivate:\n    duration d_;  // exposition only\n\npublic:\n    time_point();  // has value \"epoch\" // constexpr in C++14\n    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14\n\n    // conversions\n    template <class Duration2>\n       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14\n\n    // observer\n\n    duration time_since_epoch() const; // constexpr in C++14\n\n    // arithmetic\n\n    time_point& operator+=(const duration& d);\n    time_point& operator-=(const duration& d);\n\n    // special values\n\n    static constexpr time_point min();\n    static constexpr time_point max();\n};\n\n} // chrono\n\n// common_type traits\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;\n\ntemplate <class Clock, class Duration1, class Duration2>\n  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;\n\nnamespace chrono {\n\n// duration arithmetic\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type\n  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type\n  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator*(const duration<Rep1, Period>& d, const Rep2& s);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator*(const Rep1& s, const duration<Rep2, Period>& d);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator/(const duration<Rep1, Period>& d, const Rep2& s);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<Rep1, Rep2>::type\n  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\n\n// duration comparisons\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\n\n// duration_cast\ntemplate <class ToDuration, class Rep, class Period>\n  ToDuration duration_cast(const duration<Rep, Period>& d);\n\n// time_point arithmetic (all constexpr in C++14)\ntemplate <class Clock, class Duration1, class Rep2, class Period2>\n  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>\n  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Clock, class Duration2>\n  time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>\n  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Rep2, class Period2>\n  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>\n  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n  typename common_type<Duration1, Duration2>::type\n  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\n\n// time_point comparisons (all constexpr in C++14)\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\n\n// time_point_cast (constexpr in C++14)\n\ntemplate <class ToDuration, class Clock, class Duration>\n  time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);\n\n// Clocks\n\nclass system_clock\n{\npublic:\n    typedef microseconds                     duration;\n    typedef duration::rep                    rep;\n    typedef duration::period                 period;\n    typedef chrono::time_point<system_clock> time_point;\n    static const bool is_steady =            false; // constexpr in C++14\n\n    static time_point now() noexcept;\n    static time_t     to_time_t  (const time_point& __t) noexcept;\n    static time_point from_time_t(time_t __t) noexcept;\n};\n\nclass steady_clock\n{\npublic:\n    typedef nanoseconds                                   duration;\n    typedef duration::rep                                 rep;\n    typedef duration::period                              period;\n    typedef chrono::time_point<steady_clock, duration>    time_point;\n    static const bool is_steady =                         true; // constexpr in C++14\n\n    static time_point now() noexcept;\n};\n\ntypedef steady_clock high_resolution_clock;\n\n}  // chrono\n\nconstexpr chrono::hours                                 operator \"\" h(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , ratio<3600,1>> operator \"\" h(long double); // C++14\nconstexpr chrono::minutes                               operator \"\" min(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , ratio<60,1>>   operator \"\" min(long double); // C++14\nconstexpr chrono::seconds                               operator \"\" s(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified >                operator \"\" s(long double); // C++14\nconstexpr chrono::milliseconds                          operator \"\" ms(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , milli>         operator \"\" ms(long double); // C++14\nconstexpr chrono::microseconds                          operator \"\" us(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , micro>         operator \"\" us(long double); // C++14\nconstexpr chrono::nanoseconds                           operator \"\" ns(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , nano>          operator \"\" ns(long double); // C++14\n\n}  // std\n*/\n\n#include <__config>\n#include <ctime>\n#include <type_traits>\n#include <ratio>\n#include <limits>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace chrono\n{\n\ntemplate <class _Rep, class _Period = ratio<1> > class _LIBCPP_TYPE_VIS_ONLY duration;\n\ntemplate <class _Tp>\nstruct __is_duration : false_type {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<const duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<volatile duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<const volatile duration<_Rep, _Period> > : true_type  {};\n\n} // chrono\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<chrono::duration<_Rep1, _Period1>,\n                                         chrono::duration<_Rep2, _Period2> >\n{\n    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,\n                             typename __ratio_gcd<_Period1, _Period2>::type> type;\n};\n\nnamespace chrono {\n\n// duration_cast\n\ntemplate <class _FromDuration, class _ToDuration,\n          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,\n          bool = _Period::num == 1,\n          bool = _Period::den == 1>\nstruct __duration_cast;\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)\n                                                          / static_cast<_Ct>(_Period::den)));\n    }\n};\n\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nduration_cast(const duration<_Rep, _Period>& __fd)\n{\n    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);\n}\n\ntemplate <class _Rep>\nstruct _LIBCPP_TYPE_VIS_ONLY treat_as_floating_point : is_floating_point<_Rep> {};\n\ntemplate <class _Rep>\nstruct _LIBCPP_TYPE_VIS_ONLY duration_values\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep zero() {return _Rep(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep max()  {return numeric_limits<_Rep>::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep min()  {return numeric_limits<_Rep>::lowest();}\n};\n\n// duration\n\ntemplate <class _Rep, class _Period>\nclass _LIBCPP_TYPE_VIS_ONLY duration\n{\n    static_assert(!__is_duration<_Rep>::value, \"A duration representation can not be a duration\");\n    static_assert(__is_ratio<_Period>::value, \"Second template parameter of duration must be a std::ratio\");\n    static_assert(_Period::num > 0, \"duration period must be positive\");\n\n    template <class _R1, class _R2>\n    struct __no_overflow\n    {\n    private:\n        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;\n        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;\n        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;\n        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;\n        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;\n        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;\n        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1);\n\n        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>\n        struct __mul    // __overflow == false\n        {\n            static const intmax_t value = _Xp * _Yp;\n        };\n\n        template <intmax_t _Xp, intmax_t _Yp>\n        struct __mul<_Xp, _Yp, true>\n        {\n            static const intmax_t value = 1;\n        };\n\n    public:\n        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);\n        typedef ratio<__mul<__n1, __d2, !value>::value,\n                      __mul<__n2, __d1, !value>::value> type;\n    };\n    \npublic:\n    typedef _Rep rep;\n    typedef _Period period;\nprivate:\n    rep __rep_;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n        duration() = default;\n#else\n        duration() {}\n#endif\n\n    template <class _Rep2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n        explicit duration(const _Rep2& __r,\n            typename enable_if\n            <\n               is_convertible<_Rep2, rep>::value &&\n               (treat_as_floating_point<rep>::value ||\n               !treat_as_floating_point<_Rep2>::value)\n            >::type* = 0)\n                : __rep_(__r) {}\n\n    // conversions\n    template <class _Rep2, class _Period2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n        duration(const duration<_Rep2, _Period2>& __d,\n            typename enable_if\n            <\n                __no_overflow<_Period2, period>::value && (\n                treat_as_floating_point<rep>::value ||\n                (__no_overflow<_Period2, period>::type::den == 1 &&\n                 !treat_as_floating_point<_Rep2>::value))\n            >::type* = 0)\n                : __rep_(_VSTD::chrono::duration_cast<duration>(__d).count()) {}\n\n    // observer\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR rep count() const {return __rep_;}\n\n    // arithmetic\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR duration  operator+() const {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR duration  operator-() const {return duration(-__rep_);}\n    _LIBCPP_INLINE_VISIBILITY duration& operator++()      {++__rep_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration  operator++(int)   {return duration(__rep_++);}\n    _LIBCPP_INLINE_VISIBILITY duration& operator--()      {--__rep_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration  operator--(int)   {return duration(__rep_--);}\n\n    _LIBCPP_INLINE_VISIBILITY duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}\n\n    // special values\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration zero() {return duration(duration_values<rep>::zero());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration min()  {return duration(duration_values<rep>::min());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration max()  {return duration(duration_values<rep>::max());}\n};\n\ntypedef duration<long long,         nano> nanoseconds;\ntypedef duration<long long,        micro> microseconds;\ntypedef duration<long long,        milli> milliseconds;\ntypedef duration<long long              > seconds;\ntypedef duration<     long, ratio<  60> > minutes;\ntypedef duration<     long, ratio<3600> > hours;\n\n// Duration ==\n\ntemplate <class _LhsDuration, class _RhsDuration>\nstruct __duration_eq\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const\n        {\n            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;\n            return _Ct(__lhs).count() == _Ct(__rhs).count();\n        }\n};\n\ntemplate <class _LhsDuration>\nstruct __duration_eq<_LhsDuration, _LhsDuration>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const\n        {return __lhs.count() == __rhs.count();}\n};\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);\n}\n\n// Duration !=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__lhs == __rhs);\n}\n\n// Duration <\n\ntemplate <class _LhsDuration, class _RhsDuration>\nstruct __duration_lt\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const\n        {\n            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;\n            return _Ct(__lhs).count() < _Ct(__rhs).count();\n        }\n};\n\ntemplate <class _LhsDuration>\nstruct __duration_lt<_LhsDuration, _LhsDuration>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const\n        {return __lhs.count() < __rhs.count();}\n};\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);\n}\n\n// Duration >\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __rhs < __lhs;\n}\n\n// Duration <=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__rhs < __lhs);\n}\n\n// Duration >=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__lhs < __rhs);\n}\n\n// Duration +\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());\n}\n\n// Duration -\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());\n}\n\n// Duration *\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,\n    duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n>::type\noperator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,\n    duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n>::type\noperator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)\n{\n    return __d * __s;\n}\n\n// Duration /\n\ntemplate <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>\nstruct __duration_divide_result\n{\n};\n\ntemplate <class _Duration, class _Rep2,\n    bool = is_convertible<_Rep2,\n                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>\nstruct __duration_divide_imp\n{\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\nstruct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>\n{\n    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\nstruct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>\n    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>\n{\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type\noperator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<_Rep1, _Rep2>::type\noperator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;\n    return _Ct(__lhs).count() / _Ct(__rhs).count();\n}\n\n// Duration %\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type\noperator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));\n}\n\n//////////////////////////////////////////////////////////\n///////////////////// time_point /////////////////////////\n//////////////////////////////////////////////////////////\n\ntemplate <class _Clock, class _Duration = typename _Clock::duration>\nclass _LIBCPP_TYPE_VIS_ONLY time_point\n{\n    static_assert(__is_duration<_Duration>::value,\n                  \"Second template parameter of time_point must be a std::chrono::duration\");\npublic:\n    typedef _Clock                    clock;\n    typedef _Duration                 duration;\n    typedef typename duration::rep    rep;\n    typedef typename duration::period period;\nprivate:\n    duration __d_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point() : __d_(duration::zero()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit time_point(const duration& __d) : __d_(__d) {}\n\n    // conversions\n    template <class _Duration2>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    time_point(const time_point<clock, _Duration2>& t,\n        typename enable_if\n        <\n            is_convertible<_Duration2, duration>::value\n        >::type* = 0)\n            : __d_(t.time_since_epoch()) {}\n\n    // observer\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 duration time_since_epoch() const {return __d_;}\n\n    // arithmetic\n\n    _LIBCPP_INLINE_VISIBILITY time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}\n    _LIBCPP_INLINE_VISIBILITY time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}\n\n    // special values\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point min() {return time_point(duration::min());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point max() {return time_point(duration::max());}\n};\n\n} // chrono\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<chrono::time_point<_Clock, _Duration1>,\n                                         chrono::time_point<_Clock, _Duration2> >\n{\n    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;\n};\n\nnamespace chrono {\n\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, _ToDuration>\ntime_point_cast(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>(_VSTD::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));\n}\n\n// time_point ==\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() == __rhs.time_since_epoch();\n}\n\n// time_point !=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__lhs == __rhs);\n}\n\n// time_point <\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() < __rhs.time_since_epoch();\n}\n\n// time_point >\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __rhs < __lhs;\n}\n\n// time_point <=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__rhs < __lhs);\n}\n\n// time_point >=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__lhs < __rhs);\n}\n\n// time_point operator+(time_point x, duration y);\n\ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>\noperator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;\n    return _Tr (__lhs.time_since_epoch() + __rhs);\n}\n\n// time_point operator+(duration x, time_point y);\n\ntemplate <class _Rep1, class _Period1, class _Clock, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>\noperator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __rhs + __lhs;\n}\n\n// time_point operator-(time_point x, duration y);\n\ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>\noperator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __lhs + (-__rhs);\n}\n\n// duration operator-(time_point x, time_point y);\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename common_type<_Duration1, _Duration2>::type\noperator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() - __rhs.time_since_epoch();\n}\n\n//////////////////////////////////////////////////////////\n/////////////////////// clocks ///////////////////////////\n//////////////////////////////////////////////////////////\n\nclass _LIBCPP_TYPE_VIS system_clock\n{\npublic:\n    typedef microseconds                     duration;\n    typedef duration::rep                    rep;\n    typedef duration::period                 period;\n    typedef chrono::time_point<system_clock> time_point;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = false;\n\n    static time_point now() _NOEXCEPT;\n    static time_t     to_time_t  (const time_point& __t) _NOEXCEPT;\n    static time_point from_time_t(time_t __t) _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_HAS_NO_MONOTONIC_CLOCK\nclass _LIBCPP_TYPE_VIS steady_clock\n{\npublic:\n    typedef nanoseconds                                   duration;\n    typedef duration::rep                                 rep;\n    typedef duration::period                              period;\n    typedef chrono::time_point<steady_clock, duration>    time_point;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = true;\n\n    static time_point now() _NOEXCEPT;\n};\n\ntypedef steady_clock high_resolution_clock;\n#else\ntypedef system_clock high_resolution_clock;\n#endif\n\n} // chrono\n\n#if _LIBCPP_STD_VER > 11\n// Suffixes for duration literals [time.duration.literals]\ninline namespace literals\n{ \n  inline namespace chrono_literals\n  {\n\n    constexpr chrono::hours operator\"\" h(unsigned long long __h)\n    {\n        return chrono::hours(static_cast<chrono::hours::rep>(__h));\n    }\n\n    constexpr chrono::duration<long double, ratio<3600,1>> operator\"\" h(long double __h)\n    {\n        return chrono::duration<long double, ratio<3600,1>>(__h);\n    }\n\n\n    constexpr chrono::minutes operator\"\" min(unsigned long long __m)\n    {\n        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));\n    }\n\n    constexpr chrono::duration<long double, ratio<60,1>> operator\"\" min(long double __m)\n    {\n        return chrono::duration<long double, ratio<60,1>> (__m);\n    }\n\n\n    constexpr chrono::seconds operator\"\" s(unsigned long long __s)\n    {\n        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));\n    }\n\n    constexpr chrono::duration<long double> operator\"\" s(long double __s)\n    {\n        return chrono::duration<long double> (__s);\n    }\n\n\n    constexpr chrono::milliseconds operator\"\" ms(unsigned long long __ms)\n    {\n        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));\n    }\n\n    constexpr chrono::duration<long double, milli> operator\"\" ms(long double __ms)\n    {\n        return chrono::duration<long double, milli>(__ms);\n    }\n\n\n    constexpr chrono::microseconds operator\"\" us(unsigned long long __us)\n    {\n        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));\n    }\n\n    constexpr chrono::duration<long double, micro> operator\"\" us(long double __us)\n    {\n        return chrono::duration<long double, micro> (__us);\n    }\n    \n\n    constexpr chrono::nanoseconds operator\"\" ns(unsigned long long __ns)\n    {\n        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));\n    }\n\n    constexpr chrono::duration<long double, nano> operator\"\" ns(long double __ns)\n    {\n        return chrono::duration<long double, nano> (__ns);\n    }\n\n}}\n\nnamespace chrono { // hoist the literals into namespace std::chrono\n   using namespace literals::chrono_literals;\n}\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CHRONO\n","#pragma once\n\nnamespace rx {\n\ntemplate<class Clock = steady_clock, class Error = exception_ptr>\nstruct run_loop {\n    using clock_type = decay_t<Clock>;\n    using error_type = decay_t<Error>;\n    using lock_type = mutex;\n    using guard_type = unique_lock<lock_type>;\n    using observer_type = observer_interface<detail::re_defer_at_t<clock_type>, error_type>;\n    using item_type = observe_at<clock_type, observer_type>;\n    using queue_type = observe_at_queue<clock_type, observer_type>;\n\n    struct guarded_loop {\n        ~guarded_loop() {\n            info(to_string(reinterpret_cast<ptrdiff_t>(this)) + \" - run_loop: guarded_loop destroy\");\n        }\n        lock_type lock;\n        condition_variable wake;\n        queue_type deferred;\n    };\n\n    subscription lifetime;\n    state<guarded_loop> loop;\n    \n    explicit run_loop(subscription l) \n        : lifetime(l)\n        , loop(make_state<guarded_loop>(lifetime)) {\n        auto& guarded = this->loop.get();\n        lifetime.insert([&guarded](){\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(guarded))) + \" - run_loop: stop notify_all\");\n            //guard_type guard(guarded.lock);\n            guarded.wake.notify_all();\n        });\n    }\n    ~run_loop(){\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: destroy\");\n    }\n    \n    bool is_ready(guard_type& guard) const {\n        if (!guard.owns_lock()) { \n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: is_ready caller must own lock!\");\n            abort(); \n        }\n        auto& deferred = loop.get().deferred;\n        return !deferred.empty() && deferred.top().when <= clock_type::now();\n    }\n\n    bool wait(guard_type& guard) const {\n        if (!guard.owns_lock()) { \n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: wait caller must own lock!\");\n            abort(); \n        }\n        auto& deferred = loop.get().deferred;\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: wait\");\n        if (!loop.lifetime.is_stopped()) {\n            if (!deferred.empty()) {\n                info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: wait_until top when\");\n                loop.get().wake.wait_until(guard, deferred.top().when, [&](){\n                    bool r = is_ready(guard) || loop.lifetime.is_stopped();\n                    info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: wait wakeup is_ready - \" + to_string(r));\n                    return r;\n                });\n            } else {\n                info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: wait for notify\");\n                loop.get().wake.wait(guard, [&](){\n                    bool r = !deferred.empty() || loop.lifetime.is_stopped();\n                    info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: wait wakeup is_ready - \" + to_string(r));\n                    return r;\n                });\n            }\n        }\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: wake\");\n        return !loop.lifetime.is_stopped();\n    }\n\n    void call(guard_type& guard, item_type& next) const {\n        if (guard.owns_lock()) { \n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: call caller must not own lock!\");\n            abort(); \n        }\n        info(\"run_loop: call\");\n        auto& deferred = loop.get().deferred;\n        bool complete = true;\n        next.what.next([&](time_point<clock_type> at){\n            unique_lock<guard_type> nestedguard(guard);\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: call self\");\n            if (lifetime.is_stopped() || next.what.lifetime.is_stopped()) return;\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: call push self\");\n            next.when = at;\n            deferred.push(next);\n            complete = false;\n        });\n        if (complete) {\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: call complete\");\n            next.what.complete();\n        }\n    }\n\n    void step(guard_type& guard, typename clock_type::duration d) const {\n        if (!guard.owns_lock()) { \n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: step caller must own lock!\");\n            abort(); \n        }\n        auto& deferred = loop.get().deferred;\n        auto stop = clock_type::now() + d;\n        while (!loop.lifetime.is_stopped() && is_ready(guard) && clock_type::now() < stop) {\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: step\");\n\n            auto next = move(deferred.top());\n            deferred.pop();\n            \n            guard.unlock();\n            call(guard, next);\n            guard.lock();\n        }\n    }\n    \n    void run() const {\n        guard_type guard(loop.get().lock);\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: run\");\n        while (wait(guard)) {\n            step(guard, 3600s);\n        }\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: exit\");\n    }\n\n    struct strand {\n        subscription lifetime;\n        state<guarded_loop> loop;\n        \n        template<class... OON>\n        void operator()(time_point<clock_type> at, observer<OON...> out) const {\n            guard_type guard(loop.get().lock);\n            lifetime.insert(out.lifetime);\n            loop.get().deferred.push(item_type{at, out});\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(loop.get()))) + \" - run_loop: defer_at notify_all\");\n            loop.get().wake.notify_all();\n        }\n    };\n\n    auto make() const {\n        return [loop = this->loop](subscription lifetime) {\n            loop.lifetime.insert(lifetime);\n            return make_strand<clock_type>(lifetime, strand{lifetime, loop}, detail::now<clock_type>{});\n        };\n    }\n};\n\n}","#pragma once\n\nnamespace rx {\n\ntemplate<class Clock, class Observer>\nstruct observe_at;\n\ntemplate<class Clock, class... ON>\nstruct observe_at<Clock, observer<ON...>>\n{\n    using clock_type = decay_t<Clock>;\n    using observer_type = observer<ON...>;\n\n    observe_at(time_point<clock_type> when, observer_type o)\n        : when(when)\n        , what(std::move(o))\n    {\n    }\n    time_point<clock_type> when;\n    observer_type what;\n};\n\n\n// Sorts observe_at items in priority order sorted\n// on value of observe_at.when. Items with equal\n// values for when are sorted in fifo order.\n\ntemplate<class Clock, class Observer>\nclass observe_at_queue;\n\ntemplate<class Clock, class... ON>\nclass observe_at_queue<Clock, observer<ON...>> {\npublic:\n    using clock_type = decay_t<Clock>;\n    using observer_type = observer<ON...>;\n    using item_type = observe_at<clock_type, observer_type>;\n    using elem_type = std::pair<item_type, int64_t>;\n    using container_type = std::vector<elem_type>;\n    using const_reference = const item_type&;\n\nprivate:\n    struct compare_elem\n    {\n        bool operator()(const elem_type& lhs, const elem_type& rhs) const {\n            if (lhs.first.when == rhs.first.when) {\n                return lhs.second > rhs.second;\n            }\n            else {\n                return lhs.first.when > rhs.first.when;\n            }\n        }\n    };\n\n    typedef std::priority_queue<\n        elem_type,\n        container_type,\n        compare_elem\n    > queue_type;\n\n    queue_type q;\n\n    int64_t ordinal;\npublic:\n    const_reference top() const {\n        return q.top().first;\n    }\n\n    void pop() {\n        q.pop();\n    }\n\n    bool empty() const {\n        return q.empty();\n    }\n\n    void push(const item_type& value) {\n        q.push(elem_type(value, ordinal++));\n    }\n\n    void push(item_type&& value) {\n        q.push(elem_type(std::move(value), ordinal++));\n    }\n};\n\n}","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___MUTEX_BASE\n#define _LIBCPP___MUTEX_BASE\n\n#include <__config>\n#include <chrono>\n#include <system_error>\n#include <pthread.h>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_THREADS\n\nclass _LIBCPP_TYPE_VIS mutex\n{\n    pthread_mutex_t __m_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_CONSTEXPR\n     constexpr mutex() _NOEXCEPT : __m_(PTHREAD_MUTEX_INITIALIZER) {}\n#else\n     mutex() _NOEXCEPT {__m_ = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;}\n#endif\n     ~mutex();\n\nprivate:\n    mutex(const mutex&);// = delete;\n    mutex& operator=(const mutex&);// = delete;\n\npublic:\n    void lock();\n    bool try_lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\n    typedef pthread_mutex_t* native_handle_type;\n    _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {return &__m_;}\n};\n\nstruct _LIBCPP_TYPE_VIS defer_lock_t {};\nstruct _LIBCPP_TYPE_VIS try_to_lock_t {};\nstruct _LIBCPP_TYPE_VIS adopt_lock_t {};\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MUTEX)\n\nextern const defer_lock_t  defer_lock;\nextern const try_to_lock_t try_to_lock;\nextern const adopt_lock_t  adopt_lock;\n\n#else\n\nconstexpr defer_lock_t  defer_lock  = defer_lock_t();\nconstexpr try_to_lock_t try_to_lock = try_to_lock_t();\nconstexpr adopt_lock_t  adopt_lock  = adopt_lock_t();\n\n#endif\n\ntemplate <class _Mutex>\nclass _LIBCPP_TYPE_VIS_ONLY lock_guard\n{\npublic:\n    typedef _Mutex mutex_type;\n\nprivate:\n    mutex_type& __m_;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit lock_guard(mutex_type& __m)\n        : __m_(__m) {__m_.lock();}\n    _LIBCPP_INLINE_VISIBILITY\n    lock_guard(mutex_type& __m, adopt_lock_t)\n        : __m_(__m) {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~lock_guard() {__m_.unlock();}\n\nprivate:\n    lock_guard(lock_guard const&);// = delete;\n    lock_guard& operator=(lock_guard const&);// = delete;\n};\n\ntemplate <class _Mutex>\nclass _LIBCPP_TYPE_VIS_ONLY unique_lock\n{\npublic:\n    typedef _Mutex mutex_type;\n\nprivate:\n    mutex_type* __m_;\n    bool __owns_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock() _NOEXCEPT : __m_(nullptr), __owns_(false) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit unique_lock(mutex_type& __m)\n        : __m_(&__m), __owns_(true) {__m_->lock();}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(mutex_type& __m, defer_lock_t) _NOEXCEPT\n        : __m_(&__m), __owns_(false) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(mutex_type& __m, try_to_lock_t)\n        : __m_(&__m), __owns_(__m.try_lock()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(mutex_type& __m, adopt_lock_t)\n        : __m_(&__m), __owns_(true) {}\n    template <class _Clock, class _Duration>\n    _LIBCPP_INLINE_VISIBILITY\n        unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)\n            : __m_(&__m), __owns_(__m.try_lock_until(__t)) {}\n    template <class _Rep, class _Period>\n    _LIBCPP_INLINE_VISIBILITY\n        unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)\n            : __m_(&__m), __owns_(__m.try_lock_for(__d)) {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~unique_lock()\n    {\n        if (__owns_)\n            __m_->unlock();\n    }\n\nprivate:\n    unique_lock(unique_lock const&); // = delete;\n    unique_lock& operator=(unique_lock const&); // = delete;\n\npublic:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock(unique_lock&& __u) _NOEXCEPT\n        : __m_(__u.__m_), __owns_(__u.__owns_)\n        {__u.__m_ = nullptr; __u.__owns_ = false;}\n    _LIBCPP_INLINE_VISIBILITY\n    unique_lock& operator=(unique_lock&& __u) _NOEXCEPT\n        {\n            if (__owns_)\n                __m_->unlock();\n            __m_ = __u.__m_;\n            __owns_ = __u.__owns_;\n            __u.__m_ = nullptr;\n            __u.__owns_ = false;\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void lock();\n    bool try_lock();\n\n    template <class _Rep, class _Period>\n        bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);\n    template <class _Clock, class _Duration>\n        bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);\n\n    void unlock();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unique_lock& __u) _NOEXCEPT\n    {\n        _VSTD::swap(__m_, __u.__m_);\n        _VSTD::swap(__owns_, __u.__owns_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    mutex_type* release() _NOEXCEPT\n    {\n        mutex_type* __m = __m_;\n        __m_ = nullptr;\n        __owns_ = false;\n        return __m;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool owns_lock() const _NOEXCEPT {return __owns_;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT\n        operator bool () const _NOEXCEPT {return __owns_;}\n    _LIBCPP_INLINE_VISIBILITY\n    mutex_type* mutex() const _NOEXCEPT {return __m_;}\n};\n\ntemplate <class _Mutex>\nvoid\nunique_lock<_Mutex>::lock()\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::lock: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::lock: already locked\");\n    __m_->lock();\n    __owns_ = true;\n}\n\ntemplate <class _Mutex>\nbool\nunique_lock<_Mutex>::try_lock()\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::try_lock: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::try_lock: already locked\");\n    __owns_ = __m_->try_lock();\n    return __owns_;\n}\n\ntemplate <class _Mutex>\ntemplate <class _Rep, class _Period>\nbool\nunique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d)\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::try_lock_for: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::try_lock_for: already locked\");\n    __owns_ = __m_->try_lock_for(__d);\n    return __owns_;\n}\n\ntemplate <class _Mutex>\ntemplate <class _Clock, class _Duration>\nbool\nunique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t)\n{\n    if (__m_ == nullptr)\n        __throw_system_error(EPERM, \"unique_lock::try_lock_until: references null mutex\");\n    if (__owns_)\n        __throw_system_error(EDEADLK, \"unique_lock::try_lock_until: already locked\");\n    __owns_ = __m_->try_lock_until(__t);\n    return __owns_;\n}\n\ntemplate <class _Mutex>\nvoid\nunique_lock<_Mutex>::unlock()\n{\n    if (!__owns_)\n        __throw_system_error(EPERM, \"unique_lock::unlock: not locked\");\n    __m_->unlock();\n    __owns_ = false;\n}\n\ntemplate <class _Mutex>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) _NOEXCEPT\n    {__x.swap(__y);}\n\n//enum class cv_status\n_LIBCPP_DECLARE_STRONG_ENUM(cv_status)\n{\n    no_timeout,\n    timeout\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(cv_status)\n\nclass _LIBCPP_TYPE_VIS condition_variable\n{\n    pthread_cond_t __cv_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_CONSTEXPR\n    constexpr condition_variable() : __cv_(PTHREAD_COND_INITIALIZER) {}\n#else\n    condition_variable() {__cv_ = (pthread_cond_t)PTHREAD_COND_INITIALIZER;}\n#endif\n    ~condition_variable();\n\nprivate:\n    condition_variable(const condition_variable&); // = delete;\n    condition_variable& operator=(const condition_variable&); // = delete;\n\npublic:\n    void notify_one() _NOEXCEPT;\n    void notify_all() _NOEXCEPT;\n\n    void wait(unique_lock<mutex>& __lk) _NOEXCEPT;\n    template <class _Predicate>\n        void wait(unique_lock<mutex>& __lk, _Predicate __pred);\n\n    template <class _Clock, class _Duration>\n        cv_status\n        wait_until(unique_lock<mutex>& __lk,\n                   const chrono::time_point<_Clock, _Duration>& __t);\n\n    template <class _Clock, class _Duration, class _Predicate>\n        bool\n        wait_until(unique_lock<mutex>& __lk,\n                   const chrono::time_point<_Clock, _Duration>& __t,\n                   _Predicate __pred);\n\n    template <class _Rep, class _Period>\n        cv_status\n        wait_for(unique_lock<mutex>& __lk,\n                 const chrono::duration<_Rep, _Period>& __d);\n\n    template <class _Rep, class _Period, class _Predicate>\n        bool\n        wait_for(unique_lock<mutex>& __lk,\n                 const chrono::duration<_Rep, _Period>& __d,\n                 _Predicate __pred);\n\n    typedef pthread_cond_t* native_handle_type;\n    _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {return &__cv_;}\n\nprivate:\n    void __do_timed_wait(unique_lock<mutex>& __lk,\n       chrono::time_point<chrono::system_clock, chrono::nanoseconds>) _NOEXCEPT;\n};\n#endif // !_LIBCPP_HAS_NO_THREADS\n\ntemplate <class _To, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    chrono::__is_duration<_To>::value,\n    _To\n>::type\n__ceil(chrono::duration<_Rep, _Period> __d)\n{\n    using namespace chrono;\n    _To __r = duration_cast<_To>(__d);\n    if (__r < __d)\n        ++__r;\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_THREADS\ntemplate <class _Predicate>\nvoid\ncondition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred)\n{\n    while (!__pred())\n        wait(__lk);\n}\n\ntemplate <class _Clock, class _Duration>\ncv_status\ncondition_variable::wait_until(unique_lock<mutex>& __lk,\n                               const chrono::time_point<_Clock, _Duration>& __t)\n{\n    using namespace chrono;\n    wait_for(__lk, __t - _Clock::now());\n    return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;\n}\n\ntemplate <class _Clock, class _Duration, class _Predicate>\nbool\ncondition_variable::wait_until(unique_lock<mutex>& __lk,\n                   const chrono::time_point<_Clock, _Duration>& __t,\n                   _Predicate __pred)\n{\n    while (!__pred())\n    {\n        if (wait_until(__lk, __t) == cv_status::timeout)\n            return __pred();\n    }\n    return true;\n}\n\ntemplate <class _Rep, class _Period>\ncv_status\ncondition_variable::wait_for(unique_lock<mutex>& __lk,\n                             const chrono::duration<_Rep, _Period>& __d)\n{\n    using namespace chrono;\n    if (__d <= __d.zero())\n        return cv_status::timeout;\n    typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;\n    typedef time_point<system_clock, nanoseconds> __sys_tpi;\n    __sys_tpf _Max = __sys_tpi::max();\n    system_clock::time_point __s_now = system_clock::now();\n    steady_clock::time_point __c_now = steady_clock::now();\n    if (_Max - __d > __s_now)\n        __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));\n    else\n        __do_timed_wait(__lk, __sys_tpi::max());\n    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :\n                                                 cv_status::timeout;\n}\n\ntemplate <class _Rep, class _Period, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\ncondition_variable::wait_for(unique_lock<mutex>& __lk,\n                             const chrono::duration<_Rep, _Period>& __d,\n                             _Predicate __pred)\n{\n    return wait_until(__lk, chrono::steady_clock::now() + __d,\n                      _VSTD::move(__pred));\n}\n\n#endif // !_LIBCPP_HAS_NO_THREADS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___MUTEX_BASE\n","// -*- C++ -*-\n//===---------------------------- list ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LIST\n#define _LIBCPP_LIST\n\n/*\n    list synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Alloc = allocator<T> >\nclass list\n{\npublic:\n\n    // types:\n    typedef T value_type;\n    typedef Alloc allocator_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef implementation-defined size_type;\n    typedef implementation-defined difference_type;\n    typedef reverse_iterator<iterator> reverse_iterator;\n    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n\n    list()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit list(const allocator_type& a);\n    explicit list(size_type n);\n    explicit list(size_type n, const allocator_type& a); // C++14\n    list(size_type n, const value_type& value);\n    list(size_type n, const value_type& value, const allocator_type& a);\n    template <class Iter>\n        list(Iter first, Iter last);\n    template <class Iter>\n        list(Iter first, Iter last, const allocator_type& a);\n    list(const list& x);\n    list(const list&, const allocator_type& a);\n    list(list&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    list(list&&, const allocator_type& a);\n    list(initializer_list<value_type>);\n    list(initializer_list<value_type>, const allocator_type& a);\n\n    ~list();\n\n    list& operator=(const list& x);\n    list& operator=(list&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    list& operator=(initializer_list<value_type>);\n    template <class Iter>\n        void assign(Iter first, Iter last);\n    void assign(size_type n, const value_type& t);\n    void assign(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator end() noexcept;\n    const_iterator end() const noexcept;\n    reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    bool empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    template <class... Args>\n        void emplace_front(Args&&... args);\n    void pop_front();\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n    void push_front(const value_type& x);\n    void push_front(value_type&& x);\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class Iter>\n        iterator insert(const_iterator position, Iter first, Iter last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator position, const_iterator last);\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(list&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void clear() noexcept;\n\n    void splice(const_iterator position, list& x);\n    void splice(const_iterator position, list&& x);\n    void splice(const_iterator position, list& x, const_iterator i);\n    void splice(const_iterator position, list&& x, const_iterator i);\n    void splice(const_iterator position, list& x, const_iterator first,\n                                                  const_iterator last);\n    void splice(const_iterator position, list&& x, const_iterator first,\n                                                  const_iterator last);\n\n    void remove(const value_type& value);\n    template <class Pred> void remove_if(Pred pred);\n    void unique();\n    template <class BinaryPredicate>\n        void unique(BinaryPredicate binary_pred);\n    void merge(list& x);\n    void merge(list&& x);\n    template <class Compare>\n        void merge(list& x, Compare comp);\n    template <class Compare>\n        void merge(list&& x, Compare comp);\n    void sort();\n    template <class Compare>\n        void sort(Compare comp);\n    void reverse() noexcept;\n};\n\ntemplate <class T, class Alloc>\n    bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator< (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator!=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator> (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator>=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator<=(const list<T,Alloc>& x, const list<T,Alloc>& y);\n\ntemplate <class T, class Alloc>\n    void swap(list<T,Alloc>& x, list<T,Alloc>& y)\n         noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n\n#include <memory>\n#include <limits>\n#include <initializer_list>\n#include <iterator>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _VoidPtr> struct __list_node;\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node_base\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other pointer;\n#endif\n\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node_base> __base_pointer;\n#else\n        rebind<__list_node_base>::other __base_pointer;\n#endif\n\n    pointer __prev_;\n    pointer __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_node_base() : __prev_(__self()), __next_(__self()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __self()\n    {\n        return static_cast<pointer>(pointer_traits<__base_pointer>::pointer_to(*this));\n    }\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node\n    : public __list_node_base<_Tp, _VoidPtr>\n{\n    _Tp __value_;\n};\n\ntemplate <class _Tp, class _Alloc> class _LIBCPP_TYPE_VIS_ONLY list;\ntemplate <class _Tp, class _Alloc> class __list_imp;\ntemplate <class _Tp, class _VoidPtr> class _LIBCPP_TYPE_VIS_ONLY __list_const_iterator;\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\n    template<class, class> friend class __list_const_iterator;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef value_type&                      reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator(const __list_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator=(const __list_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_iterator& __x, const __list_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_const_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__p);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_const_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator=(const __list_const_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::const_iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _Alloc>\nclass __list_imp\n{\n    __list_imp(const __list_imp&);\n    __list_imp& operator=(const __list_imp&);\nprotected:\n    typedef _Tp                                                     value_type;\n    typedef _Alloc                                                  allocator_type;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n    typedef typename __alloc_traits::size_type                      size_type;\n    typedef typename __alloc_traits::void_pointer                   __void_pointer;\n    typedef __list_iterator<value_type, __void_pointer>             iterator;\n    typedef __list_const_iterator<value_type, __void_pointer>       const_iterator;\n    typedef __list_node_base<value_type, __void_pointer>            __node_base;\n    typedef __list_node<value_type, __void_pointer>                 __node;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node>\n#else\n                rebind_alloc<__node>::other\n#endif\n                                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>                       __node_alloc_traits;\n    typedef typename __node_alloc_traits::pointer                    __node_pointer;\n    typedef typename __node_alloc_traits::pointer                    __node_const_pointer;\n    typedef typename __alloc_traits::pointer                         pointer;\n    typedef typename __alloc_traits::const_pointer                   const_pointer;\n    typedef typename __alloc_traits::difference_type                 difference_type;\n\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node_base>\n#else\n                rebind_alloc<__node_base>::other\n#endif\n                                                                     __node_base_allocator;\n    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;\n\n    __node_base __end_;\n    __compressed_pair<size_type, __node_allocator> __size_alloc_;\n\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& __sz() _NOEXCEPT {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __sz() const _NOEXCEPT\n        {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT\n          {return __size_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __size_alloc_.second();}\n\n    static void __unlink_nodes(__node_pointer __f, __node_pointer __l) _NOEXCEPT;\n\n    __list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value);\n    __list_imp(const allocator_type& __a);\n    ~__list_imp();\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __sz() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__end_.__next_, this);\n#else\n        return iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const  _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(__end_.__next_, this);\n#else\n        return const_iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__node_pointer>(\n                pointer_traits<__node_base_pointer>::pointer_to(__end_)), this);\n#else\n        return iterator(static_cast<__node_pointer>(\n                      pointer_traits<__node_base_pointer>::pointer_to(__end_)));\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))), this);\n#else\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))));\n#endif\n    }\n\n    void swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c)\n        _NOEXCEPT_(\n            !__node_alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, true_type)\n        {\n            if (__node_alloc() != __c.__node_alloc())\n                clear();\n            __node_alloc() = __c.__node_alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {\n            __node_alloc() = _VSTD::move(__c.__node_alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, false_type)\n        _NOEXCEPT\n        {}\n};\n\n// Unlink nodes [__f, __l]\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__list_imp<_Tp, _Alloc>::__unlink_nodes(__node_pointer __f, __node_pointer __l)\n    _NOEXCEPT\n{\n    __f->__prev_->__next_ = __l->__next_;\n    __l->__next_->__prev_ = __f->__prev_;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    : __size_alloc_(0)\n{\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)\n    : __size_alloc_(0, __node_allocator(__a))\n{\n}\n\ntemplate <class _Tp, class _Alloc>\n__list_imp<_Tp, _Alloc>::~__list_imp()\n{\n    clear();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::clear() _NOEXCEPT\n{\n    if (!empty())\n    {\n        __node_allocator& __na = __node_alloc();\n        __node_pointer __f = __end_.__next_;\n        __node_pointer __l = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n        __unlink_nodes(__f, __l->__prev_);\n        __sz() = 0;\n        while (__f != __l)\n        {\n            __node_pointer __n = __f;\n            __f = __f->__next_;\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != __l)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __c.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    using _VSTD::swap;\n    __swap_alloc(__node_alloc(), __c.__node_alloc());\n    swap(__sz(), __c.__sz());\n    swap(__end_, __c.__end_);\n    if (__sz() == 0)\n        __end_.__next_ = __end_.__prev_ = __end_.__self();\n    else\n        __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_.__self();\n    if (__c.__sz() == 0)\n        __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_.__self();\n    else\n        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ = __c.__end_.__self();\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __libcpp_db* __db = __get_db();\n    __c_node* __cn1 = __db->__find_c_and_lock(this);\n    __c_node* __cn2 = __db->__find_c(&__c);\n    std::swap(__cn1->beg_, __cn2->beg_);\n    std::swap(__cn1->end_, __cn2->end_);\n    std::swap(__cn1->cap_, __cn2->cap_);\n    for (__i_node** __p = __cn1->end_; __p != __cn1->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n        {\n            __cn2->__add(*__p);\n            if (--__cn1->end_ != __p)\n                memmove(__p, __p+1, (__cn1->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn1;\n    }\n    for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_)))\n        {\n            __cn1->__add(*__p);\n            if (--__cn2->end_ != __p)\n                memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn2;\n    }\n    __db->unlock();\n#endif\n}\n\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY list\n    : private __list_imp<_Tp, _Alloc>\n{\n    typedef __list_imp<_Tp, _Alloc> base;\n    typedef typename base::__node              __node;\n    typedef typename base::__node_allocator    __node_allocator;\n    typedef typename base::__node_pointer      __node_pointer;\n    typedef typename base::__node_alloc_traits __node_alloc_traits;\n    typedef typename base::__node_base         __node_base;\n    typedef typename base::__node_base_pointer __node_base_pointer;\n\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Alloc                                   allocator_type;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename base::pointer                   pointer;\n    typedef typename base::const_pointer             const_pointer;\n    typedef typename base::size_type                 size_type;\n    typedef typename base::difference_type           difference_type;\n    typedef typename base::iterator                  iterator;\n    typedef typename base::const_iterator            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    list()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    explicit list(const allocator_type& __a) : base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit list(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit list(size_type __n, const allocator_type& __a);\n#endif\n    list(size_type __n, const value_type& __x);\n    list(size_type __n, const value_type& __x, const allocator_type& __a);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n\n    list(const list& __c);\n    list(const list& __c, const allocator_type& __a);\n    list& operator=(const list& __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    list(initializer_list<value_type> __il);\n    list(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    list(list&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value);\n    list(list&& __c, const allocator_type& __a);\n    list& operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    list& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InpIter>\n        void assign(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    allocator_type get_allocator() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT     {return base::__sz();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT         {return base::empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return numeric_limits<difference_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT        {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT          {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return base::end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    reference back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n       void emplace_front(_Args&&... __args);\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n    template <class... _Args>\n        iterator emplace(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    iterator insert(const_iterator __p, value_type&& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void push_front(const value_type& __x);\n    void push_back(const value_type& __x);\n\n    iterator insert(const_iterator __p, const value_type& __x);\n    iterator insert(const_iterator __p, size_type __n, const value_type& __x);\n    template <class _InpIter>\n        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, initializer_list<value_type> __il)\n        {return insert(__p, __il.begin(), __il.end());}\n#endif   // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(list& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {base::swap(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {base::clear();}\n\n    void pop_front();\n    void pop_back();\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n\n    void resize(size_type __n);\n    void resize(size_type __n, const value_type& __x);\n\n    void splice(const_iterator __p, list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}\n#endif\n    void splice(const_iterator __p, list& __c, const_iterator __i);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __i)\n        {splice(__p, __c, __i);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)\n        {splice(__p, __c, __f, __l);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void remove(const value_type& __x);\n    template <class _Pred> void remove_if(_Pred __pred);\n    void unique();\n    template <class _BinaryPred>\n        void unique(_BinaryPred __binary_pred);\n    void merge(list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(list&& __c) {merge(__c);}\n#endif\n    template <class _Comp>\n        void merge(list& __c, _Comp __comp);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Comp>\n    _LIBCPP_INLINE_VISIBILITY\n        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void sort();\n    template <class _Comp>\n        void sort(_Comp __comp);\n\n    void reverse() _NOEXCEPT;\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    static void __link_nodes  (__node_pointer __p, __node_pointer __f, __node_pointer __l);\n    void __link_nodes_at_front(__node_pointer __f, __node_pointer __l);\n    void __link_nodes_at_back (__node_pointer __f, __node_pointer __l);\n    iterator __iterator(size_type __n);\n    template <class _Comp>\n        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);\n\n    void __move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value);\n    void __move_assign(list& __c, false_type);\n};\n\n// Link in nodes [__f, __l] just prior to __p\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes(__node_pointer __p, __node_pointer __f, __node_pointer __l)\n{\n    __p->__prev_->__next_ = __f;\n    __f->__prev_ = __p->__prev_;\n    __p->__prev_ = __l;\n    __l->__next_ = __p;\n}\n\n// Link in nodes [__f, __l] at the front of the list\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes_at_front(__node_pointer __f, __node_pointer __l)\n{\n    __f->__prev_ = base::__end_.__self();\n    __l->__next_ = base::__end_.__next_;\n    __l->__next_->__prev_ = __l;\n    base::__end_.__next_ = __f;\n}\n\n// Link in nodes [__f, __l] at the front of the list\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes_at_back(__node_pointer __f, __node_pointer __l)\n{\n    __l->__next_ = base::__end_.__self();\n    __f->__prev_ = base::__end_.__prev_;\n    __f->__prev_->__next_ = __f;\n    base::__end_.__prev_ = __l;\n}\n\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__iterator(size_type __n)\n{\n    return __n <= base::__sz() / 2 ? _VSTD::next(begin(), __n)\n                                   : _VSTD::prev(end(), base::__sz() - __n);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n#endif\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c)\n    : base(allocator_type(\n           __node_alloc_traits::select_on_container_copy_construction(\n                __c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(const list& __c)\n{\n    if (this != &__c)\n    {\n        base::__copy_assign_alloc(__c);\n        assign(__c.begin(), __c.end());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value)\n    : base(allocator_type(_VSTD::move(__c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    splice(end(), __c);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __c.get_allocator())\n        splice(end(), __c);\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n{\n    __move_assign(__c, integral_constant<bool,\n          __node_alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, false_type)\n{\n    if (base::__node_alloc() != __c.__node_alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n{\n    clear();\n    base::__move_assign_alloc(__c);\n    splice(end(), __c);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nvoid\nlist<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,\n                          typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __f != __l && __i != __e; ++__f, ++__i)\n        *__i = *__f;\n    if (__i == __e)\n        insert(__e, __f, __l);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __n > 0 && __i != __e; --__n, ++__i)\n        *__i = __x;\n    if (__i == __e)\n        insert(__e, __n, __x);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n_Alloc\nlist<_Tp, _Alloc>::get_allocator() const _NOEXCEPT\n{\n    return allocator_type(base::__node_alloc());\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__n > 0)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, range) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__f != __l)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (++__f; __f != __l; ++__f, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_front(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes_at_front(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_back(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes_at_back(__hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::emplace(iterator, args...) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_front()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_front() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_back() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__prev_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __p)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::erase(iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    _LIBCPP_ASSERT(__p != end(),\n        \"list::erase(iterator) called with a non-dereferenceable iterator\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = __p.__ptr_;\n    __node_pointer __r = __n->__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__r, this);\n#else\n    return iterator(__r);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == this,\n        \"list::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (__f != __l)\n    {\n        __node_allocator& __na = base::__node_alloc();\n        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);\n        while (__f != __l)\n        {\n            __node_pointer __n = __f.__ptr_;\n            ++__f;\n            --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __c_node* __c = __get_db()->__find_c_and_lock(this);\n            for (__i_node** __p = __c->end_; __p != __c->beg_; )\n            {\n                --__p;\n                iterator* __i = static_cast<iterator*>((*__p)->__i_);\n                if (__i->__ptr_ == __n)\n                {\n                    (*__p)->__c_ = nullptr;\n                    if (--__c->end_ != __p)\n                        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n            __get_db()->unlock();\n#endif\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__l.__ptr_, this);\n#else\n    return iterator(__l.__ptr_);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes_at_back(__r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c)\n{\n    _LIBCPP_ASSERT(this != &__c,\n                   \"list::splice(iterator, list) called with this == &list\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (!__c.empty())\n    {\n        __node_pointer __f = __c.__end_.__next_;\n        __node_pointer __l = __c.__end_.__prev_;\n        base::__unlink_nodes(__f, __l);\n        __link_nodes(__p.__ptr_, __f, __l);\n        base::__sz() += __c.__sz();\n        __c.__sz() = 0;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__i) == &__c,\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(&__i),\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" derefereceable\");\n#endif\n    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)\n    {\n        __node_pointer __f = __i.__ptr_;\n        base::__unlink_nodes(__f, __f);\n        __link_nodes(__p.__ptr_, __f, __f);\n        --__c.__sz();\n        ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            if (__j->__ptr_ == __f)\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == &__c,\n        \"list::splice(iterator, list, iterator, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    if (this == &__c)\n    {\n        for (const_iterator __i = __f; __i != __l; ++__i)\n            _LIBCPP_ASSERT(__i != __p,\n                           \"list::splice(iterator, list, iterator, iterator)\"\n                           \" called with the first iterator within the range\"\n                           \" of the second and third iterators\");\n    }\n#endif\n    if (__f != __l)\n    {\n        if (this != &__c)\n        {\n            size_type __s = _VSTD::distance(__f, __l);\n            __c.__sz() -= __s;\n            base::__sz() += __s;\n        }\n        __node_pointer __first = __f.__ptr_;\n        --__l;\n        __node_pointer __last = __l.__ptr_;\n        base::__unlink_nodes(__first, __last);\n        __link_nodes(__p.__ptr_, __first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            for (__node_pointer __k = __f.__ptr_;\n                                          __k != __l.__ptr_; __k = __k->__next_)\n            {\n                if (__j->__ptr_ == __k)\n                {\n                    __cn1->__add(*__p);\n                    (*__p)->__c_ = __cn1;\n                    if (--__cn2->end_ != __p)\n                        memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::remove(const value_type& __x)\n{\n    list<_Tp, _Alloc> __deleted_nodes; // collect the nodes we're removing\n    for (const_iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (*__i == __x)\n        {\n            const_iterator __j = _VSTD::next(__i);\n            for (; __j != __e && *__j == __x; ++__j)\n                ;\n            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);\n            __i = __j;\n            if (__i != __e)\n                ++__i;\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Pred>\nvoid\nlist<_Tp, _Alloc>::remove_if(_Pred __pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (__pred(*__i))\n        {\n            iterator __j = _VSTD::next(__i);\n            for (; __j != __e && __pred(*__j); ++__j)\n                ;\n            __i = erase(__i, __j);\n            if (__i != __e)\n                ++__i;\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::unique()\n{\n    unique(__equal_to<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _BinaryPred>\nvoid\nlist<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        iterator __j = _VSTD::next(__i);\n        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)\n            ;\n        if (++__i != __j)\n            __i = erase(__i, __j);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::merge(list& __c)\n{\n    merge(__c, __less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\nvoid\nlist<_Tp, _Alloc>::merge(list& __c, _Comp __comp)\n{\n    if (this != &__c)\n    {\n        iterator __f1 = begin();\n        iterator __e1 = end();\n        iterator __f2 = __c.begin();\n        iterator __e2 = __c.end();\n        while (__f1 != __e1 && __f2 != __e2)\n        {\n            if (__comp(*__f2, *__f1))\n            {\n                size_type __ds = 1;\n                iterator __m2 = _VSTD::next(__f2);\n                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)\n                    ;\n                base::__sz() += __ds;\n                __c.__sz() -= __ds;\n                __node_pointer __f = __f2.__ptr_;\n                __node_pointer __l = __m2.__ptr_->__prev_;\n                __f2 = __m2;\n                base::__unlink_nodes(__f, __l);\n                __m2 = _VSTD::next(__f1);\n                __link_nodes(__f1.__ptr_, __f, __l);\n                __f1 = __m2;\n            }\n            else\n                ++__f1;\n        }\n        splice(__e1, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort()\n{\n    sort(__less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort(_Comp __comp)\n{\n    __sort(begin(), end(), base::__sz(), __comp);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)\n{\n    switch (__n)\n    {\n    case 0:\n    case 1:\n        return __f1;\n    case 2:\n        if (__comp(*--__e2, *__f1))\n        {\n            __node_pointer __f = __e2.__ptr_;\n            base::__unlink_nodes(__f, __f);\n            __link_nodes(__f1.__ptr_, __f, __f);\n            return __e2;\n        }\n        return __f1;\n    }\n    size_type __n2 = __n / 2;\n    iterator __e1 = _VSTD::next(__f1, __n2);\n    iterator  __r = __f1 = __sort(__f1, __e1, __n2, __comp);\n    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);\n    if (__comp(*__f2, *__f1))\n    {\n        iterator __m2 = _VSTD::next(__f2);\n        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n            ;\n        __node_pointer __f = __f2.__ptr_;\n        __node_pointer __l = __m2.__ptr_->__prev_;\n        __r = __f2;\n        __e1 = __f2 = __m2;\n        base::__unlink_nodes(__f, __l);\n        __m2 = _VSTD::next(__f1);\n        __link_nodes(__f1.__ptr_, __f, __l);\n        __f1 = __m2;\n    }\n    else\n        ++__f1;\n    while (__f1 != __e1 && __f2 != __e2)\n    {\n        if (__comp(*__f2, *__f1))\n        {\n            iterator __m2 = _VSTD::next(__f2);\n            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n                ;\n            __node_pointer __f = __f2.__ptr_;\n            __node_pointer __l = __m2.__ptr_->__prev_;\n            if (__e1 == __f2)\n                __e1 = __m2;\n            __f2 = __m2;\n            base::__unlink_nodes(__f, __l);\n            __m2 = _VSTD::next(__f1);\n            __link_nodes(__f1.__ptr_, __f, __l);\n            __f1 = __m2;\n        }\n        else\n            ++__f1;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::reverse() _NOEXCEPT\n{\n    if (base::__sz() > 1)\n    {\n        iterator __e = end();\n        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)\n        {\n            _VSTD::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);\n            __i.__ptr_ = __i.__ptr_->__prev_;\n        }\n        _VSTD::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__invariants() const\n{\n    return size() == _VSTD::distance(begin(), end());\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(this->__end_)));\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__decrementable(const const_iterator* __i) const\n{\n    return !empty() &&  __i->__ptr_ != base::__end_.__next_;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LIST\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n    const char* __type_name;\n#else\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        : __type_name(__n) {}\n#else\n        : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name;}\n#else\n        {return reinterpret_cast<const char*>(__type_name & ~_LIBCPP_NONUNIQUE_RTTI_BIT);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name < __arg.__type_name;}\n#else\n        {if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return __type_name < __arg.__type_name;\n         return __compare_nonunique_names(__arg) < 0;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n#else\n        {if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT)) return __type_name;\n         const char *__ptr = name();\n         size_t __hash = 5381;\n         while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n           __hash = (__hash * 33) ^ __c;\n         return __hash;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name == __arg.__type_name;}\n#else\n        {if (__type_name == __arg.__type_name) return true;\n         if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return false;\n         return __compare_nonunique_names(__arg) == 0;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n#ifdef _LIBCPP_NONUNIQUE_RTTI_BIT\n  private:\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n        {return __builtin_strcmp(name(), __arg.name());}\n#endif\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n","#pragma once \n\n\n///\n/// demonstrate \"async-tuple\"\n///\nnamespace {\n\nusing namespace std::chrono;\nusing namespace rx;\n\nstruct cstr_or_string {\n    void operator()(const char* cstr) const {cout << \"cstr   - \" << cstr << endl;}\n    void operator()(const string& s) const {cout <<  \"string - \" << s << endl;}\n};\n\nconst auto text = [](){\n    info(\"new text\");\n    return make_observable([=](auto scrb){\n        info(\"text bound to subscriber\");\n        return make_starter([=](auto ctx) {\n            info(\"text bound to context\");\n            auto r = scrb.create(ctx);\n            info(\"text started\");\n            r.next(\"hello\");\n            r.next(string(\"world\"));\n            r.complete();\n            return ctx.lifetime;\n        });\n    });\n};\n\n}\n\n#if EMSCRIPTEN\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE intervalsv3(){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n    auto threeeven = copy_if(even) | \n        take(3) |\n        delay(makeStrand, 1s);\n\n    auto l = intervals(makeStrand, steady_clock::now(), 1s) | \n        threeeven |\n        as_interface<long>() |\n        finally([](){cout << \"caller stopped\" << endl;}) |\n        printto(cout) |\n        start<destruction>(subscription{}, destruction{});\n\n    lifetime.insert(l);\n}\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE pushv3(int first, int last){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n    auto l = async_ints(makeStrand, first, last) | \n        copy_if(even) | \n        printto(cout) |\n        start<destruction>(subscription{}, destruction{});\n\n    lifetime.insert(l);\n}\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE lastv3(int first, int last, int defaultValue){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n    auto l = async_ints(makeStrand, first, last) | \n        copy_if(even) | \n        last_or_default(defaultValue) |\n        printto(cout) |\n        start<destruction>(subscription{}, destruction{});\n\n    lifetime.insert(l);\n}\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE takev3(int first, int last, int count){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n    auto l = async_ints(makeStrand, first, last) | \n        copy_if(even) | \n        take(count) |\n        printto(cout) |\n        start<destruction>(subscription{}, destruction{});\n\n    lifetime.insert(l);\n}\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE errorv3(int first, int last, int count){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n    auto l = async_ints(makeStrand, first, last) | \n        copy_if(always_throw) | \n        take(count) |\n        printto(cout) |\n        start<destruction>(subscription{}, destruction{});\n\n    lifetime.insert(l);\n}\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE delayv3(int producems, int delayms, int count){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n    const auto printproduced = [](auto& output){\n        return make_lifter([&output](auto scbr){\n            return make_subscriber([=, &output](auto ctx){\n                auto r = scbr.create(ctx);\n                auto start = ctx.now();\n                return make_observer(r, r.lifetime, [=, &output](auto& r, auto v){\n                    defer(ctx, make_observer(subscription{}, [=, &output](auto& ){\n                        output << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << duration_cast<milliseconds>(ctx.now() - start).count()/1000.0 << \"s - \" << v << \" produced\" << endl;\n                    }));\n                    r.next(v);\n                });\n            });\n        });\n    };\n\n    auto l = intervals(makeStrand, steady_clock::now() + milliseconds(producems), milliseconds(producems)) | \n        printproduced(cout) |\n        delay(makeStrand, milliseconds(delayms)) |\n        take(count) |\n        printto(cout) |\n        start<destruction>(subscription{}, destruction{});\n\n    lifetime.insert(l);\n}\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE testdelayv3(int producems, int delayms, int count){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n    auto start = steady_clock::now();\n\n    rx::test_loop<> loop;\n    rx::recorded<int> on;\n\n    const auto out = [=](auto& output, auto ctx, std::string w){\n        auto start = on.origin();\n        defer(ctx, make_observer(subscription{}, [=, &output](auto& ){\n            output << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << duration_cast<milliseconds>(ctx.now() - start).count()/1000.0 << \"s - \" << w << endl;\n        }));\n    };\n\n    const auto printout = [=](auto& output, std::string w){\n        return make_lifter([=, &output](auto scbr){\n            return make_subscriber([=, &output](auto ctx){\n                auto r = scbr.create(ctx);\n                return make_observer(r, r.lifetime, [=, &output](auto& r, auto v){\n                    out(output, ctx, to_string(v) + \" \" + w);\n                    r.next(v);\n                });\n            });\n        });\n    };\n\n    auto gap = milliseconds(producems);\n    auto delayby = milliseconds(delayms);\n\n    auto tr = on.hot({\n            on.next(on.origin() + gap * 1, 0),\n            on.next(on.origin() + gap * 2, 1),\n            on.next(on.origin() + gap * 3, 2),\n            on.next(on.origin() + gap * 4, 3),\n            on.next(on.origin() + gap * 5, 4)\n        }) | \n        printout(cout, \"produced\") |\n        on.record(\"produced\") |\n        delay(loop.make(), delayby) |\n        take(count) |\n        printout(cout, \"\") |\n        on.record(\"emitted\") |\n        on.test(loop, on.lifespan(on.origin() + 200ms, on.origin() + 6000ms));\n\n    loop.run();\n\n    auto finish = steady_clock::now();\n\n    cout << \"Elapsed: \" << fixed << setprecision(1) << setw(4) << float_seconds{finish - start}.count() << endl; \n\n    {\n        auto expected = on.expected({\n            on.next(on.origin() + gap * 1 + delayby, 0),\n            on.next(on.origin() + gap * 2 + delayby, 1),\n            on.next(on.origin() + gap * 3 + delayby, 2),\n            on.complete(on.origin() + gap * 3 + delayby)\n        });\n        if (tr.get().marbles[\"emitted\"] == expected) {\n            cout << \"SUCCEEDED\" << endl; \n        } else {\n            cout << \"FAILED\" << endl; \n            cout << \"Actual:\" << endl; \n            cout << tr.get().marbles[\"emitted\"] << endl;\n            cout << \"Expected:\" << endl; \n            cout << expected << endl;\n        }\n    }\n\n    {\n        auto expected = on.lifespan(on.origin() + 200ms, on.origin() + 4500ms);\n        if (tr.get().lifespan == expected) {\n            cout << \"SUCCEEDED\" << endl; \n        } else {\n            cout << \"FAILED\" << endl; \n            cout << \"Actual:\" << endl; \n            cout << tr.get().lifespan << endl;\n            cout << \"Expected:\" << endl; \n            cout << expected << endl;\n        }\n    }\n}\n\n#endif\n\n#if !EMSCRIPTEN\n\nvoid designcontext(int first, int last){\n\nusing namespace std::chrono;\n\nusing namespace rx;\nusing rx::copy_if;\nusing rx::transform;\nusing rx::merge;\n\n// silence compiler\n[](int, int) {} (first, last);\n\n//auto makeStrand = rx::detail::make_immediate<>{};\n\nauto strand = makeStrand(subscription{});\n\nstrand.now();\n\n#if !RX_SKIP_TESTS\n{\n    int producems = 1000;\n    int delayms = 1500;\n    int count = 3;\n\n    auto start = steady_clock::now();\n\n    rx::test_loop<> loop;\n    rx::recorded<int> on;\n\n    const auto out = [=](auto& output, auto ctx, std::string w){\n        auto start = on.origin();\n        defer(ctx, make_observer(subscription{}, [=, &output](auto& ){\n            output << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << duration_cast<milliseconds>(ctx.now() - start).count()/1000.0 << \"s - \" << w << endl;\n        }));\n    };\n\n    const auto printout = [=](auto& output, std::string w){\n        return make_lifter([=, &output](auto scbr){\n            return make_subscriber([=, &output](auto ctx){\n                auto r = scbr.create(ctx);\n                return make_observer(r, r.lifetime, [=, &output](auto& r, auto v){\n                    out(output, ctx, to_string(v) + \" \" + w);\n                    r.next(v);\n                });\n            });\n        });\n    };\n\n    auto gap = milliseconds(producems);\n    auto delayby = milliseconds(delayms);\n\n    auto tr = on.hot({\n            on.next(on.origin() + gap * 1, 0),\n            on.next(on.origin() + gap * 2, 1),\n            on.next(on.origin() + gap * 3, 2),\n            on.next(on.origin() + gap * 4, 3),\n            on.next(on.origin() + gap * 5, 4)\n        }) | \n        printout(cout, \"produced\") |\n        on.record(\"produced\") |\n        delay(loop.make(), delayby) |\n        take(count) |\n        printout(cout, \"emitted\") |\n        on.record(\"emitted\") |\n        on.test(loop, on.lifespan(on.origin() + 200ms, on.origin() + 6000ms));\n\n    loop.run();\n\n    auto finish = steady_clock::now();\n\n    cout << \"Elapsed: \" << fixed << setprecision(1) << setw(4) << float_seconds{finish - start}.count() << endl; \n\n    {\n        auto expected = on.expected({\n            on.next(on.origin() + gap * 1 + delayby, 0),\n            on.next(on.origin() + gap * 2 + delayby, 1),\n            on.next(on.origin() + gap * 3 + delayby, 2),\n            on.complete(on.origin() + gap * 3 + delayby)\n        });\n        if (tr.get().marbles[\"emitted\"] == expected) {\n            cout << \"SUCCEEDED\" << endl; \n        } else {\n            cout << \"FAILED\" << endl; \n            cout << \"Actual:\" << endl; \n            cout << tr.get().marbles[\"emitted\"] << endl;\n            cout << \"Expected:\" << endl; \n            cout << expected << endl;\n        }\n    }\n\n    {\n        auto expected = on.lifespan(on.origin() + 200ms, on.origin() + 4500ms);\n        if (tr.get().lifespan == expected) {\n            cout << \"SUCCEEDED\" << endl; \n        } else {\n            cout << \"FAILED\" << endl; \n            cout << \"Actual:\" << endl; \n            cout << tr.get().lifespan << endl;\n            cout << \"Expected:\" << endl; \n            cout << expected << endl;\n        }\n    }\n\n}\n#endif\n\n#if !RX_SKIP_TESTS\n{\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer(strand, make_observer(defer_lifetime, [](auto& ){\n        cout << this_thread::get_id() << \" - deferred immediate strand\" << endl;\n    }));\n}\n\n{\n    auto ctx = copy_context(subscription{}, makeStrand, start<shared_ptr<destruction>>(make_shared<destruction>()));\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer(ctx, make_observer(defer_lifetime, [](auto& ){\n        cout << this_thread::get_id() << \" - deferred immediate context\" << endl;\n    }));\n}\n\nauto sharedmakestrand = make_shared_make_strand(makeStrand);\n\n{\n    auto sharedstrand = sharedmakestrand(subscription{});\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer(sharedstrand, make_observer(defer_lifetime, [](auto& ){\n        cout << this_thread::get_id() << \" - deferred shared-immediate strand\" << endl;\n    }));\n}\n\n{\n    auto ctx = copy_context(subscription{}, sharedmakestrand, start<shared_ptr<destruction>>(make_shared<destruction>()));\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer(ctx, make_observer(defer_lifetime, [](auto& ){\n        cout << this_thread::get_id() << \" - deferred shared-immediate context\" << endl;\n    }));\n}\n\n{\n cout << \"compile-time polymorphism (canary)\" << endl;\n    auto lifetime = ints(1, 3) | \n        transform_merge(sharedmakestrand,\n            [=](int){\n                return ints(1, 10);\n            }) |\n            printto(cout) |\n            start();\n}\n#endif\n\n{\n cout << \"compile-time polymorphism (multi-typed values)\" << endl;\n    text() |\n        make_subscriber([](auto ctx) {return make_observer(ctx.lifetime, cstr_or_string{});}) |\n        start();\n}\n\n#if !RX_SKIP_THREAD\n\nauto makeThread = make_shared_make_strand(make_new_thread<>{});\n\nauto thread = makeThread(subscription{});\n\n#if !RX_SKIP_TESTS\n{\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer(thread, make_observer(defer_lifetime, [](auto& ){\n        cout << this_thread::get_id() << \" - deferred thread strand\" << endl;\n    })).join();\n}\nthis_thread::sleep_for(1s);\ncout << endl;\n#endif\n\n#if !RX_SKIP_TESTS\n{\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer_periodic(thread, thread.now(), 1s, make_observer(defer_lifetime, [=](long c){\n        cout << this_thread::get_id() << \" - deferred thread strand periodic - \" << c << endl;\n        if (c > 2) {\n            defer_lifetime.stop();\n        }\n    })).join();\n}\nthis_thread::sleep_for(2s);\ncout << endl;\n#endif\n\n#if !RX_SKIP_TESTS\n{\n    auto c = make_context<steady_clock>(subscription{}, makeThread);\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer_periodic(c, c.now(), 1s, make_observer(defer_lifetime, [=](long c){\n        cout << this_thread::get_id() << \" - deferred thread context periodic - \" << c << endl;\n        if (c > 2) {\n            defer_lifetime.stop();\n        }\n    })).join();\n}\nthis_thread::sleep_for(2s);\ncout << endl;\n#endif\n\n#if !RX_SKIP_TESTS\n{\n    auto f = make_context<steady_clock>(subscription{}, makeThread);\n    auto c = copy_context(subscription{}, makeThread, f);\n    auto defer_lifetime = subscription{};\n    make_state<shared_ptr<destruction>>(defer_lifetime, make_shared<destruction>());\n    defer_periodic(c, c.now(), 1s, make_observer(defer_lifetime, [=](long c){\n        cout << this_thread::get_id() << \" - deferred thread copied context periodic - \" << c << endl;\n        if (c > 2) {\n            defer_lifetime.stop();\n        }\n    })).join();\n}\nthis_thread::sleep_for(2s);\ncout << endl;\n#endif\n\n#if !RX_SKIP_TESTS\n{\n cout << \"intervals\" << endl;\n    auto threeeven = copy_if(even) | \n        take(3) |\n        delay(makeThread, 1s);\n\n    intervals(makeThread, steady_clock::now() + 1s, 1s) | \n        threeeven |\n        as_interface<long>() |\n        finally([](){cout << \"caller stopped\" << endl;}) |\n        printto(cout) |\n        start<shared_ptr<destruction>>(subscription{}, make_shared<destruction>()) |\n        join();\n}\nthis_thread::sleep_for(2s);\ncout << endl;\n#endif\n\n#if !RX_SKIP_TESTS\n{\n output(\"merged multi-thread intervals\");\n\n    intervals(make_new_thread<>{}, steady_clock::now(), 20ms) | \n        take(thread::hardware_concurrency()) |\n        transform_merge(make_new_thread<>{}, [](long c){\n            output(\"thread started\");\n            return intervals(make_new_thread<>{}, steady_clock::now(), 1ms) |\n                take(5001) |\n                transform([=](long n){\n                    auto r = (c * 10000) + n;\n                    return r;\n                }) |\n                as_interface<long>() |\n                last_or_default(42) |\n                finally([](){output(\"thread stopped\");});\n        }) |\n        as_interface<long>() |\n        finally([](){output(\"caller stopped\");}) |\n        as_interface<long>() |\n        printto(cout) |\n        start<shared_ptr<destruction>>(subscription{}, make_shared<destruction>()) |\n        join();\n}\nthis_thread::sleep_for(2s);\ncout << endl;\n#endif\n\n#endif \n\n#if !RX_INFO && !RX_SKIP_TESTS\n\n{\n cout << \"compile-time polymorphism\" << endl;\n    auto lastofeven = copy_if(even) | \n        take(100000000) |\n        last_or_default(42);\n\n auto t0 = high_resolution_clock::now();\n    auto lifetime = ints(0, 2) | \n        transform_merge(rx::detail::make_immediate<>{},\n            [=](int){\n                return ints(first, last * 100) |\n                    lastofeven;\n            }) |\n            printto(cout) |\n            start();\n\n auto t1 = high_resolution_clock::now();\n auto d = duration_cast<milliseconds>(t1-t0).count() * 1.0;\n auto sc = ((last * 100) - first) * 3;\n cout << d / sc << \" ms per value\\n\"; \n auto s = d / 1000.0;\n cout << sc / s << \" values per second\\n\"; \n}\n\n{\n cout << \"interface polymorphism\" << endl;\n    auto lastofeven = copy_if(even) | \n        as_interface<int>() |\n        take(100000000) |\n        as_interface<int>() |\n        last_or_default(42) |\n        as_interface<int>();\n        \n auto t0 = high_resolution_clock::now();\n    auto lifetime = ints(0, 2) | \n        as_interface<int>() |\n        transform_merge(rx::detail::make_immediate<>{},\n            [=](int){\n                return ints(first, last * 100) |\n                    as_interface<int>() |\n                    lastofeven |\n                    as_interface<int>();\n            }) |\n            as_interface<int>() |\n            printto(cout) |\n            as_interface<>() |\n            start();\n\n auto t1 = high_resolution_clock::now();\n auto d = duration_cast<milliseconds>(t1-t0).count() * 1.0;\n auto sc = ((last * 100) - first) * 3;\n cout << d / sc << \" ms per value\\n\"; \n auto s = d / 1000.0;\n cout << sc / s << \" values per second\\n\"; \n}\n\n#if !RX_SKIP_THREAD\n\n{\n cout << \"new thread\" << endl;\n    auto lastofeven = copy_if(even) | \n        take(100000000) |\n        last_or_default(42);\n\n auto t0 = high_resolution_clock::now();\n    ints(0, 2) | \n        observe_on(make_new_thread<>{}) |\n        transform_merge(make_new_thread<>{}, [=](int){\n            return ints(first, last * 100) |\n                observe_on(make_new_thread<>{}) |\n                lastofeven;\n        }) |\n        as_interface<long>() |\n        printto(cout) |\n        start() |\n        join();\n\n auto t1 = high_resolution_clock::now();\n auto d = duration_cast<milliseconds>(t1-t0).count() * 1.0;\n auto sc = ((last * 100) - first) * 3;\n cout << d / sc << \" ms per value\\n\"; \n auto s = d / 1000.0;\n cout << sc / s << \" values per second\\n\"; \n}\n\n#endif\n\n{\n cout << \"for\" << endl;\n auto t0 = high_resolution_clock::now();\n    for(auto i = first; i < last; ++i) {\n        auto lifetime = ints(0, 0) |\n            transform([](int i) {\n                return to_string(i);\n            }) |\n            transform([](const string& s) {\n                int i = '0' - s[0];\n                return i;\n            }) |\n        make_subscriber() |\n        start();\n\n    }\n\n auto t1 = high_resolution_clock::now();\n auto d = duration_cast<milliseconds>(t1-t0).count() * 1.0;\n auto sc = last - first;\n cout << d / sc << \" ms per subscription\\n\"; \n auto s = d / 1000.0;\n cout << sc / s << \" subscriptions per second\\n\"; \n}\n\n{\n cout << \"transform | merge\" << endl;\n auto t0 = high_resolution_clock::now();\n\n    auto lifetime = ints(first, last) | \n        transform([=](int){\n            return ints(0, 0) |\n                transform([](int i) {\n                    return to_string(i);\n                }) |\n                transform([](const string& s) {\n                    int i = '0' - s[0];\n                    return i;\n                });\n        }) |\n        merge(rx::detail::make_immediate<>{}) |\n        make_subscriber() |\n        start();\n\n auto t1 = high_resolution_clock::now();\n auto d = duration_cast<milliseconds>(t1-t0).count() * 1.0;\n auto sc = last - first;\n cout << d / sc << \" ms per subscription\\n\"; \n auto s = d / 1000.0;\n cout << sc / s << \" subscriptions per second\\n\"; \n}\n\n{\n cout << \"transform_merge\" << endl;\n auto t0 = high_resolution_clock::now();\n\n    auto lifetime = ints(first, last) | \n        transform_merge(rx::detail::make_immediate<>{}, \n            [=](int){\n                return ints(0, 0) |\n                    transform([](int i) {\n                        return to_string(i);\n                    }) |\n                    transform([](const string& s) {\n                        int i = '0' - s[0];\n                        return i;\n                    });\n            }) |\n            make_subscriber() |\n            start();\n\n auto t1 = high_resolution_clock::now();\n auto d = duration_cast<milliseconds>(t1-t0).count() * 1.0;\n auto sc = last - first;\n cout << d / sc << \" ms per subscription\\n\"; \n auto s = d / 1000.0;\n cout << sc / s << \" subscriptions per second\\n\"; \n}\n\n#if !RX_SKIP_THREAD\n\n{\n cout << \"transform_merge new_thread\" << endl;\n auto t0 = high_resolution_clock::now();\n\n    ints(first, last) | \n        transform_merge(make_new_thread<>{}, \n            [=](int){\n                return ints(0, 0) |\n                    transform([](int i) {\n                        return to_string(i);\n                    }) |\n                    transform([](const string& s) {\n                        int i = '0' - s[0];\n                        return i;\n                    });\n            }) |\n        as_interface<int>() |\n        make_subscriber() |\n        start() |\n        join();\n\n auto t1 = high_resolution_clock::now();\n auto d = duration_cast<milliseconds>(t1-t0).count() * 1.0;\n auto sc = last - first;\n cout << d / sc << \" ms per subscription\\n\"; \n auto s = d / 1000.0;\n cout << sc / s << \" subscriptions per second\\n\"; \n}\nthis_thread::sleep_for(1s);\ncout << endl;\n\n#endif\n\n#endif\n}\n#endif","#pragma once\n\nnamespace rx {\n\ninline string what(exception_ptr ep) {\n    try {rethrow_exception(ep);}\n    catch (const exception& ex) {\n        return ex.what();\n    }\n    return string();\n}\n\nstruct virtual_clock\n{\n    using rep = std::int64_t;\n    using period = std::milli;\n    using duration = std::chrono::duration<rep, period>;\n    using time_point = std::chrono::time_point<virtual_clock>;\n\n    static bool is_steady() {\n        return false;\n    }\n    time_point now() const {\n        return rightnow;\n    }\n    void now(time_point at) {\n        rightnow = at;\n    }\n    time_point rightnow;\n};\n\nstruct lifetime_record\n{\n    time_point<virtual_clock> start;\n    time_point<virtual_clock> stop;\n};\n\nbool operator==(const lifetime_record& l, const lifetime_record& r){\n    return l.start == r.start && l.stop == r.stop;\n}\n\nbool operator!=(const lifetime_record& l, const lifetime_record& r){\n    return !(l == r);\n}\n\ntemplate<class... OSN>\nbasic_ostream<OSN...>& operator<<(basic_ostream<OSN...>& os, const lifetime_record& l){\n    os << \"{\" << (l.start - time_point<virtual_clock>{}).count() << \", \" << (l.stop - time_point<virtual_clock>{}).count() << \"}\";\n    return os;\n}\n\ntemplate<class T, class E>\nstruct marble_record\n{\n    using clock_type = virtual_clock;\n    using error_type = decay_t<E>;\n    using time_point = typename clock_type::time_point;\n    using duration = typename clock_type::duration;\n    using observer_type = observer_interface<T, error_type>;\n    using emitter_type = function<void(observer_type o)>;\n\n    time_point at;\n    emitter_type emitter;\n\n    template<class Strand>\n    void defer(time_point origin, Strand& s, observer_type r) {\n        auto emit = emitter;\n        auto lifted = make_observer(\n            subscription{}, \n            [=](auto& ) mutable {\n                emit(r);\n            });\n        defer_at(s, origin + (at - time_point{}), lifted);\n    }\n};\n\ntemplate<class T, class E>\nbool operator==(const marble_record<T, E>& l, const marble_record<T, E>& r){\n    if (l.at != r.at) return false;\n    bool result = false;\n    l.emitter(make_observer(subscription{}, \n        [&](auto vl){\n            r.emitter(make_observer(subscription{}, [&](auto vr){\n                result = vl == vr;\n            }, detail::ignore{}));\n        },\n        [&](auto el){\n            r.emitter(make_observer(subscription{}, detail::ignore{}, [&](auto er){\n                result = what(el) == what(er);\n            }));\n        },\n        [&](){\n            r.emitter(make_observer(subscription{}, detail::ignore{}, detail::ignore{}, [&](){\n                result = true;\n            }));\n        }));\n    return result;\n}\n\ntemplate<class T, class E>\nbool operator!=(const marble_record<T, E>& l, const marble_record<T, E>& r){\n    return !(l == r);\n}\n\ntemplate<class T, class E, class... OSN>\nbasic_ostream<OSN...>& operator<<(basic_ostream<OSN...>& os, const marble_record<T, E>& m){\n    auto countms = (m.at - time_point<virtual_clock>{}).count();\n    m.emitter(make_observer(subscription{}, \n        [&](auto v){\n            os << \"next@\" << countms << \"{\" << v << \"}\";\n        },\n        [&](auto e){\n            os << \"error@\" << countms << \"{\" << what(e) << \"}\";\n        },\n        [&](){\n            os << \"complete@\" << countms << \"{}\";\n        }));\n    return os;\n}\n\ntemplate<class T, class E>\nbool operator==(const std::vector<marble_record<T, E>>& l, const std::vector<marble_record<T, E>>& r){\n    return l.size() == r.size() && std::equal(l.begin(), l.end(), r.begin());\n}\n\ntemplate<class T, class E>\nbool operator!=(const std::vector<marble_record<T, E>>& l, const std::vector<marble_record<T, E>>& r){\n    return !(l == r);\n}\n\ntemplate<class T, class E, class... OSN>\nbasic_ostream<OSN...>& operator<<(basic_ostream<OSN...>& os, const std::vector<marble_record<T, E>>& mv){\n    os << \"[\";\n    for(auto& m : mv) {\n        os << m << \", \";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<class Error = exception_ptr>\nstruct test_loop;\n\ntemplate<class T, class Error = exception_ptr>\nstruct recorded\n{\n    using clock_type = virtual_clock;\n    using error_type = decay_t<Error>;\n    using time_point = typename clock_type::time_point;\n    using duration = typename clock_type::duration;\n    using observer_type = observer_interface<T, error_type>;\n    using marble_record = rx::marble_record<T, Error>;\n\n    time_point origin() const {\n        return time_point{};\n    }\n\n    lifetime_record lifespan(time_point start = time_point{} + duration{200}, time_point stop = time_point{} + duration{1000}) const {\n        return lifetime_record{start, stop};\n    }\n\n    marble_record next(time_point at, T v) const {\n        return marble_record{at, [v](observer_type o){\n            o.next(v);\n        }};\n    }\n    marble_record error(time_point at, error_type e) const {\n        return marble_record{at, [e](observer_type o){\n            o.error(e);\n        }};\n    }\n    marble_record complete(time_point at) const {\n        return marble_record{at, [](observer_type o){\n            o.complete();\n        }};\n    }\n\n    std::vector<marble_record> expected(std::vector<marble_record> marbles) const {\n        return marbles;\n    }\n\n    auto hot(std::vector<marble_record> marbles) const {\n        info(\"new hot\");\n        return make_observable([=](auto scrb){\n            info(\"hot bound to subscriber\");\n            return make_starter([=](auto ctx) {\n                info(\"hot bound to context\");\n                auto r = scrb.create(ctx);\n                for(auto m : marbles){\n                    m.defer(ctx.get().origin, ctx, r);\n                }\n                info(\"hot started\");\n                return ctx.lifetime;\n            });\n        });\n    };\n\n    auto cold(std::vector<marble_record> marbles) const {\n        info(\"new cold\");\n        return make_observable([=](auto scrb){\n            info(\"cold bound to subscriber\");\n            return make_starter([=](auto ctx) {\n                info(\"cold bound to context\");\n                auto r = scrb.create(ctx);\n                auto origin = ctx.now();\n                for(auto m : marbles){\n                    m.defer(origin, ctx, r);\n                }\n                info(\"cold started\");\n                return ctx.lifetime;\n            });\n        });\n    };\n\n    struct test_result\n    {\n        time_point origin;\n        mutable lifetime_record lifespan;\n        mutable map<string, vector<marble_record>> marbles;\n    };\n\n    auto record(string key) const {\n        info(\"new record\");\n        return make_lifter([=](auto scbr){\n            info(\"record bound to subscriber\");\n            return make_subscriber([=](auto ctx){\n                info(\"record bound to context lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n                auto marbles = addressof(ctx.get().marbles[key]);\n                auto r = scbr.create(ctx);\n                info(\"record observer lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(r.lifetime.store.get())));\n                return make_observer(r, r.lifetime, \n                [=](auto& r, auto v) {\n                    marbles->push_back(marble_record{ctx.now(), [v](observer_type o){\n                        o.next(v);\n                    }});\n                    r.next(v);\n                },\n                [=](auto& r, error_type e){\n                    marbles->push_back(marble_record{ctx.now(), [e](observer_type o){\n                        o.error(e);\n                    }});\n                    r.error(e);\n                },\n                [=](auto& r){\n                    marbles->push_back(marble_record{ctx.now(), [](observer_type o){\n                        o.complete();\n                    }});\n                    r.complete();\n                });\n            });\n        });\n    };\n\n    template<class... TN>\n    auto test(test_loop<TN...>& tl, lifetime_record l = lifetime_record{}) {\n        return make_terminator([=](auto source){\n\n            auto test = source.bind(\n                make_subscriber([=](auto ctx){\n                    info(\"run bound to context lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n                    return make_observer(ctx.lifetime, detail::ignore{});\n                })\n            );\n\n            auto ctx = make_context<test_result, virtual_clock>(subscription{}, tl.make());\n\n            ctx.get().origin = ctx.now();\n            ctx.get().lifespan.start = ctx.now();\n            ctx.lifetime.insert([=](){\n                ctx.get().lifespan.stop = ctx.now();\n                info(\"run stopped \" + to_string((ctx.get().lifespan.start - time_point{}).count()) + \n                    \"-\" + to_string((ctx.get().lifespan.stop - time_point{}).count()));\n            });\n\n            auto liftedStart = make_observer(\n                subscription{}, \n                [=](auto& ) mutable {\n                    ctx.get().lifespan.start = ctx.now();\n                    test.start(ctx);\n                });\n            defer_at(ctx, ctx.get().origin + (l.start - time_point{}), liftedStart);\n            \n            auto liftedStop = make_observer(\n                subscription{}, \n                [=](auto& ) mutable {\n                    ctx.lifetime.stop();\n                });\n            defer_at(ctx, ctx.get().origin + (l.stop - time_point{}), liftedStop);\n\n            return ctx;\n        });\n    }\n\n};\n\ntemplate<class Error>\nstruct test_loop {\n    using clock_type = virtual_clock;\n    using error_type = decay_t<Error>;\n    using observer_type = observer_interface<detail::re_defer_at_t<clock_type>, error_type>;\n    using item_type = observe_at<clock_type, observer_type>;\n    using queue_type = observe_at_queue<clock_type, observer_type>;\n\n    struct state_type {\n        ~state_type() {\n            info(to_string(reinterpret_cast<ptrdiff_t>(this)) + \" - test_loop: state_type destroy\");\n        }\n        virtual_clock clock;\n        queue_type deferred;\n    };\n\n    subscription lifetime;\n    state<state_type> state;\n    \n    explicit test_loop(subscription l = subscription{}, clock_type c = clock_type{}) \n        : lifetime(l)\n        , state(make_state<state_type>(lifetime, state_type{c, queue_type{}})) {\n    }\n    ~test_loop(){\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: destroy\");\n    }\n\n    void call(item_type& next) const {\n        info(\"test_loop: call\");\n\n        state.get().clock.now(next.when);\n\n        auto& deferred = state.get().deferred;\n        bool complete = true;\n        next.what.next([&](time_point<clock_type> at){\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: call self\");\n            if (lifetime.is_stopped() || next.what.lifetime.is_stopped()) return;\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: call push self\");\n            next.when = at;\n            deferred.push(next);\n            complete = false;\n        });\n        if (complete) {\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: call complete\");\n            next.what.complete();\n        }\n    }\n\n    void step(typename clock_type::duration d) const {\n        auto& deferred = state.get().deferred;\n        auto stop = state.get().clock.now() + d;\n        while (!state.lifetime.is_stopped() && !deferred.empty() && state.get().clock.now() < stop) {\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: step\");\n\n            auto next = move(deferred.top());\n            deferred.pop();\n            \n            call(next);\n        }\n    }\n    \n    void run() const {\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: run\");\n        while (!state.get().deferred.empty()) {\n            step(3600s);\n            break;\n        }\n        info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: exit\");\n    }\n\n    struct strand {\n        subscription lifetime;\n        rx::state<state_type> state;\n        \n        template<class... OON>\n        void operator()(time_point<clock_type> at, observer<OON...> out) const {\n            lifetime.insert(out.lifetime);\n            state.get().deferred.push(item_type{at, out});\n            info(to_string(reinterpret_cast<ptrdiff_t>(addressof(state.get()))) + \" - test_loop: defer_at notify_all\");\n        }\n    };\n    struct now\n    {\n        rx::state<state_type> state;\n        time_point_t<virtual_clock> operator()() const {\n            return state.get().clock.now();\n        }\n    };\n\n    auto make() const {\n        return [state = this->state](subscription lifetime) {\n            state.lifetime.insert(lifetime);\n            return make_strand<clock_type>(lifetime, strand{lifetime, state}, now{state});\n        };\n    }\n};\n\n}","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n    void __annotate_contiguous_container\n    (const void *__beg, const void *__end, const void *__old_mid, const void *__new_mid) const\n    {\n#ifndef _LIBCPP_HAS_NO_ASAN\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n#endif\n    }\n\n    void __annotate_new(size_type __current_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n    void __annotate_delete() const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __n(__n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__v.size() + __n);\n      }\n      bool __commit;\n      size_type __n;\n      const vector &__v;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}\n      inline void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        __annotator.__done();\n        ++this->__end_;\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typename iterator_traits<_ForwardIterator>::difference_type __new_size = _VSTD::distance(__first, __last);\n    if (static_cast<size_type>(__new_size) <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (static_cast<size_type>(__new_size) > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last);\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__new_size)));\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                _VSTD::advance(__m, this->__end_ - __p);\n                __construct_at_end(__m, __last);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __base::__swap_alloc(this->__alloc(), __x.__alloc());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__storage_type>\n#else\n                rebind_alloc<__storage_type>::other\n#endif\n                                                     __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a);\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __storage_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator&, __storage_allocator&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_alloc(this->__alloc(), __x.__alloc());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","#pragma once\n\nnamespace rx {\n\n/// \\brief chain operator overload for\n/// Subscriber = Lifter | Subscriber\n/// \\param lifter\n/// \\param subscriber\n/// \\returns subscriber\ntemplate<class... LN, class... SN>\nauto operator|(lifter<LN...> l, subscriber<SN...> scbr) {\n    return l.lift(scbr);\n}\n\n/// \\brief chain operator overload for\n/// Lifter = Lifter | Lifter\n/// \\param lifter\n/// \\param lifter\n/// \\returns Lifter\ntemplate<class... LLN, class... LRN>\nauto operator|(lifter<LLN...> lhs, lifter<LRN...> rhs) {\n    return make_lifter([lhs = move(lhs), rhs = move(rhs)](auto scbr){\n        lhs.lift(rhs.lift(scbr));\n    });\n}\n\nnamespace detail {\n\ntemplate<typename O, typename L>\nstruct o_l\n{\n    mutable O o;\n    mutable L l;\n    template<typename SCRB>\n    auto operator()(SCRB scrb) const -> decltype(o.bind(l.lift(scrb))) {\n        return o.bind(l.lift(scrb));\n    }\n};\n\n}\n\n/// \\brief chain operator overload for\n/// Observable = Observable | Lifter\n/// \\param observable\n/// \\param lifter\n/// \\returns observable\ntemplate<class... ON, class... LN>\nauto operator|(observable<ON...> s, lifter<LN...> l) {\n    return make_observable(detail::o_l<observable<ON...>, lifter<LN...>>{s, l});\n}\n\n\n/// \\brief chain operator overload for\n/// Starter = Observable | Subscriber\n/// \\param observable\n/// \\param subscriber\n/// \\returns starter\ntemplate<class... ON, class... SN>\nauto operator|(observable<ON...> s, subscriber<SN...> scbr) {\n    return s.bind(scbr);\n}\n\n/// \\brief chain operator overload for\n/// subscription = Starter | Context\n/// \\param starter\n/// \\param context\n/// \\returns subscription\ntemplate<class... SN, class... CN>\nsubscription operator|(starter<SN...> s, context<CN...> ctx) {\n    return s.start(ctx);\n}\n\n/// \\brief chain operator overload for\n/// Adaptor = Adaptor | Adaptor\n/// \\param adaptor\n/// \\param adaptor\n/// \\returns adaptor\ntemplate<class... ALN, class... ARN>\nauto operator|(adaptor<ALN...> lhs, adaptor<ARN...> rhs) {\n    return make_adaptor([=](auto source){\n        return rhs.adapt(lhs.adapt(source));\n    });\n}\n\n/// \\brief chain operator overload for\n/// Adaptor = Adaptor | Lifter\n/// \\param adaptor\n/// \\param lifter\n/// \\returns adaptor\ntemplate<class... AN, class... LN>\nauto operator|(adaptor<AN...> a, lifter<LN...> l) {\n    return make_adaptor([=](auto source){\n        auto s = a.adapt(source);\n        return make_observable([=](auto scrb){\n            return s.bind(l.lift(scrb));\n        });\n    });\n}\n\nnamespace detail {\n\ntemplate<typename L, typename S>\nstruct l_s\n{\n    mutable L l;\n    mutable S source;\n    template<typename SCRB>\n    auto operator()(SCRB scrb) const -> decltype(source.bind(l.lift(scrb))) {\n        return source.bind(l.lift(scrb));\n    }\n};\n\ntemplate<typename L, typename A>\nstruct l_a\n{\n    mutable L l;\n    mutable A a;\n    template<typename S>\n    auto operator()(S source) const -> decltype(a.adapt(make_observable(l_s<L, S>{l, source}))) {\n        return a.adapt(make_observable(l_s<L, S>{l, source}));\n    }\n};\n\n}\n\n/// \\brief chain operator overload for\n/// Adaptor = Lifter | Adaptor\n/// \\param lifter\n/// \\param adaptor\n/// \\returns adaptor\ntemplate<class... LN, class... AN>\nauto operator|(lifter<LN...> l, adaptor<AN...> a) {\n    return make_adaptor(detail::l_a<lifter<LN...>, adaptor<AN...>>{l, a});\n}\n\n/// \\brief chain operator overload for\n/// Observable = Observable | Adaptor\n/// \\param observable\n/// \\param adaptor\n/// \\returns observable\ntemplate<class... ON, class... AN>\nauto operator|(observable<ON...> s, adaptor<AN...> a) {\n    return a.adapt(s);\n}\n\n/// \\brief chain operator overload for\n/// Terminator = Adaptor | Subscriber\n/// \\param adaptor\n/// \\param subscriber\n/// \\returns terminator\ntemplate<class... AN, class... SN>\nauto operator|(adaptor<AN...> a, subscriber<SN...> scrb) {\n    return make_terminator([=](auto source){\n        return a.adapt(source).bind(scrb);\n    });\n}\n\n/// \\brief chain operator overload for\n/// starter = Observable | Terminator\n/// \\param observable\n/// \\param terminator\n/// \\returns starter\ntemplate<class... ON, class... TN>\nauto operator|(observable<ON...> s, terminator<TN...> t) {\n    return t.terminate(s);\n}\n \n}","#pragma once\n\nnamespace rx {\n\ntemplate<class Select = defaults>\nstruct observable;\n\nnamespace detail {\n    template<class V, class C, class E>\n    using bind_t = function<starter_interface<C, E>(subscriber_interface<V, C, E>)>;\n}\ntemplate<class V, class C, class E>\nstruct observable<interface<V, C, E>> {\n    detail::bind_t<V, C, E> b;\n    observable(const observable&) = default;\n    template<class Bind>\n    observable(const observable<Bind>& o) \n        : b(o.b) {\n    } \n    starter_interface<C, E> bind(subscriber_interface<V, C, E> s) const {\n        return b(s);\n    }\n    template<class... TN>\n    observable as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class V, class C, class E>\nusing observable_interface = observable<interface<V, C, E>>;\n\ntemplate<class Bind>\nstruct observable {\n    Bind b;\n    /// \\brief \n    /// \\returns starter\n    template<class Subscriber>\n    auto bind(Subscriber&& s) const {\n        static_assert(detail::is_specialization_of<decltype(b(s)), starter>::value, \"observable function must return starter!\");\n        return b(s);\n    }\n    template<class V, class C = steady_clock, class E = exception_ptr>\n    observable_interface<V, C, E> as_interface() const {\n        return {*this};\n    }\n};\n\ntemplate<class Bind>\nobservable<Bind> make_observable(Bind&& b) {\n    return {forward<Bind>(b)};\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_observable = for_specialization_of_t<T, observable>;\n\ntemplate<class T>\nusing not_observable = not_specialization_of_t<T, observable>;\n\n}\n\n}","#pragma once\n\nnamespace rx {\n\n\ntemplate<class Select = defaults>\nstruct terminator;\n\nnamespace detail {\n    template<class V, class C, class E>\n    using terminate_t = function<starter_interface<C, E>(const observable_interface<V, C, E>&)>;\n}\ntemplate<class V, class C, class E>\nstruct terminator<interface<V, C, E>> {\n    detail::terminate_t<V, C, E> t;\n    terminator(const terminator&) = default;\n    template<class Terminate>\n    terminator(const terminator<Terminate>& t) \n        : t(t.t) {\n    }\n    starter_interface<C, E> terminate(const observable_interface<V, C, E>& ovr) const {\n        return t(ovr);\n    }\n    template<class... TN>\n    terminator as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class V, class C, class E>\nusing terminator_interface = terminator<interface<V, C, E>>;\n\ntemplate<class Terminate>\nstruct terminator {\n    Terminate t;\n    /// \\brief returns starter\n    template<class... ON>\n    auto terminate(observable<ON...> o) const {\n        //static_assert(detail::is_specialization_of<decltype(t(o)), starter>::value, \"terminator function must return starter!\");\n        return t(o);\n    }\n    template<class V, class C = steady_clock, class E = exception_ptr>\n    terminator_interface<V, C, E> as_interface() const {\n        return {*this};\n    }\n};\n\ntemplate<class Terminate>\nterminator<Terminate> make_terminator(Terminate&& t) {\n    return {forward<Terminate>(t)};\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_terminator = for_specialization_of_t<T, terminator>;\n\ntemplate<class T>\nusing not_terminator = not_specialization_of_t<T, terminator>;\n\n}\n\n}","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    void swap(basic_ostream& __rhs);\n\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&));\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type __pos);\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)\n{\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type,traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;\n    typedef typename traits::pos_type pos_type;\n    typedef typename traits::off_type off_type;\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_TYPE_VIS failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    typedef iostate      io_state;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    typedef openmode     open_mode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n    typedef seekdir seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__sun__)   || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!_VSTD::has_facet<_Facet>(__other))\n        throw runtime_error(\"locale::combine: locale missing facet\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#ifdef __GLIBC__\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_WIN32)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__) || defined(__ANDROID__)\n#ifdef __APPLE__\n    typedef __uint32_t mask;\n#elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n#elif defined(__EMSCRIPTEN__) ||  defined(__NetBSD__)\n    typedef unsigned short mask;\n#elif defined(__ANDROID__)\n    typedef unsigned char mask;\n#endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n# if defined(__ANDROID__)\n    static const mask xdigit = _CTYPE_X | _CTYPE_D;\n# else\n    static const mask xdigit = _CTYPE_X;\n# endif\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#else  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__ || __EMSCRIPTEN__ || __sun__\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TYPE_VIS_ONLY codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class charT> class _LIBCPP_TYPE_VIS_ONLY numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value\n#if __has_feature(is_final)\n                                                        && !__is_final(_Compare)\n#endif\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#if __cplusplus >= 201103L\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(_Args&& ...__args)\n        : __cc(std::forward<_Args>(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const __value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type&& __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__value_type() {__cc.~value_type();}\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type() {}\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0)\n        : __cc(__a0) {}\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0, const _A1& __a1)\n        : __cc(__a0, __a1) {}\n};\n\n#endif\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_const_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(\n            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)\n                _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        pair<iterator, bool>\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif\n    __node_holder __construct_node_with_key(const key_type& __k);\n\n    __node_base_pointer&\n        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);\n    __node_base_const_pointer\n        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;\n};\n\n// Find place to insert if __k doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k)\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_const_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_const_pointer __parent;\n    __node_base_const_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_const_pointer>(__child)->__value_.__cc.second;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\npair<typename map<_Key, _Tp, _Compare, _Allocator>::iterator, bool>\nmap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __tree_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::iterator\nmap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                   _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_unique(__p.__i_, __h.get());\n    if (__r.__i_.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                                    __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        iterator\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                   {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                        _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multimap;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY set;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multiset;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Allocator> class __map_node_destructor;\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(false)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_end_node\n             <\n                typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__tree_node_base<_VoidPtr> >\n#else\n                     rebind<__tree_node_base<_VoidPtr> >::other\n#endif\n             >\n{\n    __tree_node_base(const __tree_node_base&);\n    __tree_node_base& operator=(const __tree_node_base&);\npublic:\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__tree_node_base>\n#else\n            rebind<__tree_node_base>::other\n#endif\n                                                pointer;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const __tree_node_base>\n#else\n            rebind<const __tree_node_base>::other\n#endif\n                                                const_pointer;\n    typedef __tree_end_node<pointer> base;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_node_base() _NOEXCEPT\n        : __right_(), __parent_(), __is_black_(false) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef __tree_node_base<_VoidPtr> base;\n    typedef _Tp value_type;\n\n    value_type __value_;\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tree_node(_Args&& ...__args)\n            : __value_(_VSTD::forward<_Args>(__args)...) {}\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node(const value_type& __v)\n            : __value_(__v) {}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n};\n\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_iterator\n{\n    typedef _NodePtr                                              __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename __node_base::pointer                         __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag iterator_category;\n    typedef _Tp                        value_type;\n    typedef _DiffType                  difference_type;\n    typedef value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n};\n\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator\n{\n    typedef _ConstNodePtr                                         __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node_base>\n#else\n            rebind<__node_base>::other\n#endif\n                                                                  __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef _DiffType                        difference_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef typename remove_const<__node>::type  __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                 __non_const_node_pointer;\n    typedef __tree_iterator<value_type, __non_const_node_pointer, difference_type>\n                                                 __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef typename __alloc_traits::void_pointer  __void_pointer;\n\n    typedef __tree_node<value_type, __void_pointer> __node;\n    typedef __tree_node_base<__void_pointer>        __node_base;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef typename __node_base::pointer            __node_base_pointer;\n    typedef typename __node_base::pointer            __node_base_const_pointer;\nprivate:\n    typedef typename __node_base::base __end_node_t;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_ptr;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_const_ptr;\n\n    __node_pointer                                          __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>\n               (\n                   pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_const_pointer>\n               (\n                   pointer_traits<__end_node_const_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first()))\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() _NOEXCEPT\n        {return static_cast<__node_pointer>      (__end_node()->__left_);}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_const_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value));\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        pair<iterator, bool>\n        __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n        iterator\n        __emplace_hint_unique(const_iterator __p, _Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Vp>\n        pair<iterator, bool> __insert_unique(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_unique(const_iterator __p, _Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(const_iterator __p, _Vp&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    pair<iterator, bool> __insert_unique(const value_type& __v);\n    iterator __insert_unique(const_iterator __p, const value_type& __v);\n    iterator __insert_multi(const value_type& __v);\n    iterator __insert_multi(const_iterator __p, const value_type& __v);\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const value_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        __node_holder __construct_node(const value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _VSTD::move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _VSTD::addressof(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n    _NOEXCEPT_(\n        __is_nothrow_swappable<value_compare>::value &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value))\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_alloc(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const value_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    iterator __r = __node_insert_unique(__p, __h.get());\n    if (__r.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::destroy(__na, const_cast<value_type*>(_VSTD::addressof(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_const_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility>\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _VSTD::move(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return __first1;  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return __first1;\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __first1;\n    _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return __last1;\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return __first1;\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return __first1;\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __n, __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            swap(*__first, *__last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __min_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *__min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __max_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *__max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result ( *__first, *__first );\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n    \n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(__prev, *__first)) {\n            if (__comp(__prev, __result.first))    __result.first  = __prev;\n            if (__comp(__result.second, *__first)) __result.second = *__first;\n            }\n        else {\n            if (__comp(*__first, __result.first)) __result.first  = *__first;\n            if (__comp(__result.second, __prev))  __result.second = __prev;\n            }\n                \n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __merge<_Compare>(move_iterator<value_type*>(__buff),\n                          move_iterator<value_type*>(__p),\n                          move_iterator<_BidirectionalIterator>(__middle),\n                          move_iterator<_BidirectionalIterator>(__last),\n                          __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),\n                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),\n                _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n        {\n            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);\n            return;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _Tp>\nstruct __inplace_merge_switch\n{\n    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_left(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_right(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","#pragma once\n\nnamespace rx {\n\nconst auto printto = [](auto& output){\n    info(\"new printto\");\n    return make_subscriber([&](auto ctx) {\n        ::info(\"printto bound to context lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n        auto values = make_state<int>(ctx.lifetime, 0);\n        ::info(\"printto observer lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n        auto start = ctx.now();\n        return make_observer(\n            ctx.lifetime,\n            [=, &output](auto v) {\n                ++values.get();\n                defer(ctx, make_observer(subscription{}, [=, &output](auto& ){\n                    output << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << duration_cast<milliseconds>(ctx.now() - start).count()/1000.0 << \"s - \" << v << endl;\n                }));\n            },\n            [=, &output](exception_ptr ep){\n                defer(ctx, make_observer(subscription{}, [=, &output](auto& ){\n                    output << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << duration_cast<milliseconds>(ctx.now() - start).count()/1000.0 << \"s - \" << what(ep) << endl;\n                }));\n            },\n            [=, &output](){\n                defer(ctx, make_observer(subscription{}, [=, &output](auto& ){\n                    output << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << duration_cast<milliseconds>(ctx.now() - start).count()/1000.0 << \"s - \" << values.get() << \" values received - done!\" << endl;\n                }));\n            });\n    });\n};\n\n}","// -*- C++ -*-\n//===--------------------------- thread -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_THREAD\n#define _LIBCPP_THREAD\n\n/*\n\n    thread synopsis\n\n#define __STDCPP_THREADS__ __cplusplus\n\nnamespace std\n{\n\nclass thread\n{\npublic:\n    class id;\n    typedef pthread_t native_handle_type;\n\n    thread() noexcept;\n    template <class F, class ...Args> explicit thread(F&& f, Args&&... args);\n    ~thread();\n\n    thread(const thread&) = delete;\n    thread(thread&& t) noexcept;\n\n    thread& operator=(const thread&) = delete;\n    thread& operator=(thread&& t) noexcept;\n\n    void swap(thread& t) noexcept;\n\n    bool joinable() const noexcept;\n    void join();\n    void detach();\n    id get_id() const noexcept;\n    native_handle_type native_handle();\n\n    static unsigned hardware_concurrency() noexcept;\n};\n\nvoid swap(thread& x, thread& y) noexcept;\n\nclass thread::id\n{\npublic:\n    id() noexcept;\n};\n\nbool operator==(thread::id x, thread::id y) noexcept;\nbool operator!=(thread::id x, thread::id y) noexcept;\nbool operator< (thread::id x, thread::id y) noexcept;\nbool operator<=(thread::id x, thread::id y) noexcept;\nbool operator> (thread::id x, thread::id y) noexcept;\nbool operator>=(thread::id x, thread::id y) noexcept;\n\ntemplate<class charT, class traits>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& out, thread::id id);\n\nnamespace this_thread\n{\n\nthread::id get_id() noexcept;\n\nvoid yield() noexcept;\n\ntemplate <class Clock, class Duration>\nvoid sleep_until(const chrono::time_point<Clock, Duration>& abs_time);\n\ntemplate <class Rep, class Period>\nvoid sleep_for(const chrono::duration<Rep, Period>& rel_time);\n\n}  // this_thread\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <functional>\n#include <memory>\n#include <system_error>\n#include <chrono>\n#include <__mutex_base>\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n#include <tuple>\n#endif\n#include <pthread.h>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#define __STDCPP_THREADS__ __cplusplus\n\n#ifdef _LIBCPP_HAS_NO_THREADS\n#error <thread> is not supported on this single threaded system\n#else // !_LIBCPP_HAS_NO_THREADS\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp>\nclass __thread_specific_ptr\n{\n    pthread_key_t __key_;\n\n    __thread_specific_ptr(const __thread_specific_ptr&);\n    __thread_specific_ptr& operator=(const __thread_specific_ptr&);\n\n    static void __at_thread_exit(void*);\npublic:\n    typedef _Tp* pointer;\n\n    __thread_specific_ptr();\n    ~__thread_specific_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer get() const {return static_cast<_Tp*>(pthread_getspecific(__key_));}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator*() const {return *get();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return get();}\n    pointer release();\n    void reset(pointer __p = nullptr);\n};\n\ntemplate <class _Tp>\nvoid\n__thread_specific_ptr<_Tp>::__at_thread_exit(void* __p)\n{\n    delete static_cast<pointer>(__p);\n}\n\ntemplate <class _Tp>\n__thread_specific_ptr<_Tp>::__thread_specific_ptr()\n{\n    int __ec = pthread_key_create(&__key_, &__thread_specific_ptr::__at_thread_exit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__ec)\n        throw system_error(error_code(__ec, system_category()),\n                           \"__thread_specific_ptr construction failed\");\n#endif\n}\n\ntemplate <class _Tp>\n__thread_specific_ptr<_Tp>::~__thread_specific_ptr()\n{\n    pthread_key_delete(__key_);\n}\n\ntemplate <class _Tp>\ntypename __thread_specific_ptr<_Tp>::pointer\n__thread_specific_ptr<_Tp>::release()\n{\n    pointer __p = get();\n    pthread_setspecific(__key_, 0);\n    return __p;\n}\n\ntemplate <class _Tp>\nvoid\n__thread_specific_ptr<_Tp>::reset(pointer __p)\n{\n    pointer __p_old = get();\n    pthread_setspecific(__key_, __p);\n    delete __p_old;\n}\n\nclass _LIBCPP_TYPE_VIS thread;\nclass _LIBCPP_TYPE_VIS __thread_id;\n\nnamespace this_thread\n{\n\n_LIBCPP_INLINE_VISIBILITY __thread_id get_id() _NOEXCEPT;\n\n}  // this_thread\n\ntemplate<> struct _LIBCPP_TYPE_VIS_ONLY hash<__thread_id>;\n\nclass _LIBCPP_TYPE_VIS_ONLY __thread_id\n{\n    // FIXME: pthread_t is a pointer on Darwin but a long on Linux.\n    // NULL is the no-thread value on Darwin.  Someone needs to check\n    // on other platforms.  We assume 0 works everywhere for now.\n    pthread_t __id_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __thread_id() _NOEXCEPT : __id_(0) {}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(__thread_id __x, __thread_id __y) _NOEXCEPT\n        {return __x.__id_ == __y.__id_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(__thread_id __x, __thread_id __y) _NOEXCEPT\n        {return !(__x == __y);}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator< (__thread_id __x, __thread_id __y) _NOEXCEPT\n        {return __x.__id_ < __y.__id_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator<=(__thread_id __x, __thread_id __y) _NOEXCEPT\n        {return !(__y < __x);}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator> (__thread_id __x, __thread_id __y) _NOEXCEPT\n        {return   __y < __x ;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator>=(__thread_id __x, __thread_id __y) _NOEXCEPT\n        {return !(__x < __y);}\n\n    template<class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, __thread_id __id)\n        {return __os << __id.__id_;}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    __thread_id(pthread_t __id) : __id_(__id) {}\n\n    friend __thread_id this_thread::get_id() _NOEXCEPT;\n    friend class _LIBCPP_TYPE_VIS thread;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<__thread_id>;\n};\n\ntemplate<>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<__thread_id>\n    : public unary_function<__thread_id, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(__thread_id __v) const\n    {\n        return hash<pthread_t>()(__v.__id_);\n    }\n};\n\nnamespace this_thread\n{\n\ninline _LIBCPP_INLINE_VISIBILITY\n__thread_id\nget_id() _NOEXCEPT\n{\n    return pthread_self();\n}\n\n}  // this_thread\n\nclass _LIBCPP_TYPE_VIS thread\n{\n    pthread_t __t_;\n\n    thread(const thread&);\n    thread& operator=(const thread&);\npublic:\n    typedef __thread_id id;\n    typedef pthread_t native_handle_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    thread() _NOEXCEPT : __t_(0) {}\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Fp, class ..._Args,\n              class = typename enable_if\n              <\n                   !is_same<typename decay<_Fp>::type, thread>::value\n              >::type\n             >\n        explicit thread(_Fp&& __f, _Args&&... __args);\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Fp> explicit thread(_Fp __f);\n#endif\n    ~thread();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    thread(thread&& __t) _NOEXCEPT : __t_(__t.__t_) {__t.__t_ = 0;}\n    thread& operator=(thread&& __t) _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(thread& __t) _NOEXCEPT {_VSTD::swap(__t_, __t.__t_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool joinable() const _NOEXCEPT {return __t_ != 0;}\n    void join();\n    void detach();\n    _LIBCPP_INLINE_VISIBILITY\n    id get_id() const _NOEXCEPT {return __t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    native_handle_type native_handle() _NOEXCEPT {return __t_;}\n\n    static unsigned hardware_concurrency() _NOEXCEPT;\n};\n\nclass __assoc_sub_state;\n\nclass _LIBCPP_HIDDEN __thread_struct_imp;\n\nclass _LIBCPP_TYPE_VIS __thread_struct\n{\n    __thread_struct_imp* __p_;\n\n    __thread_struct(const __thread_struct&);\n    __thread_struct& operator=(const __thread_struct&);\npublic:\n    __thread_struct();\n    ~__thread_struct();\n\n    void notify_all_at_thread_exit(condition_variable*, mutex*);\n    void __make_ready_at_thread_exit(__assoc_sub_state*);\n};\n\n_LIBCPP_FUNC_VIS __thread_specific_ptr<__thread_struct>& __thread_local_data();\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fp, class ..._Args, size_t ..._Indices>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__thread_execute(tuple<_Fp, _Args...>& __t, __tuple_indices<_Indices...>)\n{\n    __invoke(_VSTD::move(_VSTD::get<0>(__t)), _VSTD::move(_VSTD::get<_Indices>(__t))...);\n}\n\ntemplate <class _Fp>\nvoid*\n__thread_proxy(void* __vp)\n{\n    __thread_local_data().reset(new __thread_struct);\n    std::unique_ptr<_Fp> __p(static_cast<_Fp*>(__vp));\n    typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;\n    __thread_execute(*__p, _Index());\n    return nullptr;\n}\n\ntemplate <class _Fp, class ..._Args,\n          class\n         >\nthread::thread(_Fp&& __f, _Args&&... __args)\n{\n    typedef tuple<typename decay<_Fp>::type, typename decay<_Args>::type...> _Gp;\n    _VSTD::unique_ptr<_Gp> __p(new _Gp(__decay_copy(_VSTD::forward<_Fp>(__f)),\n                                __decay_copy(_VSTD::forward<_Args>(__args))...));\n    int __ec = pthread_create(&__t_, 0, &__thread_proxy<_Gp>, __p.get());\n    if (__ec == 0)\n        __p.release();\n    else\n        __throw_system_error(__ec, \"thread constructor failed\");\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fp>\nvoid*\n__thread_proxy(void* __vp)\n{\n    __thread_local_data().reset(new __thread_struct);\n    std::unique_ptr<_Fp> __p(static_cast<_Fp*>(__vp));\n    (*__p)();\n    return nullptr;\n}\n\ntemplate <class _Fp>\nthread::thread(_Fp __f)\n{\n    std::unique_ptr<_Fp> __p(new _Fp(__f));\n    int __ec = pthread_create(&__t_, 0, &__thread_proxy<_Fp>, __p.get());\n    if (__ec == 0)\n        __p.release();\n    else\n        __throw_system_error(__ec, \"thread constructor failed\");\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ninline _LIBCPP_INLINE_VISIBILITY\nthread&\nthread::operator=(thread&& __t) _NOEXCEPT\n{\n    if (__t_ != 0)\n        terminate();\n    __t_ = __t.__t_;\n    __t.__t_ = 0;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(thread& __x, thread& __y) _NOEXCEPT {__x.swap(__y);}\n\nnamespace this_thread\n{\n\n_LIBCPP_FUNC_VIS void sleep_for(const chrono::nanoseconds& ns);\n\ntemplate <class _Rep, class _Period>\nvoid\nsleep_for(const chrono::duration<_Rep, _Period>& __d)\n{\n    using namespace chrono;\n    if (__d > duration<_Rep, _Period>::zero())\n    {\n        _LIBCPP_CONSTEXPR duration<long double> _Max = nanoseconds::max();\n        nanoseconds __ns;\n        if (__d < _Max)\n        {\n            __ns = duration_cast<nanoseconds>(__d);\n            if (__ns < __d)\n                ++__ns;\n        }\n        else\n            __ns = nanoseconds::max();\n        sleep_for(__ns);\n    }\n}\n\ntemplate <class _Clock, class _Duration>\nvoid\nsleep_until(const chrono::time_point<_Clock, _Duration>& __t)\n{\n    using namespace chrono;\n    mutex __mut;\n    condition_variable __cv;\n    unique_lock<mutex> __lk(__mut);\n    while (_Clock::now() < __t)\n        __cv.wait_until(__lk, __t);\n}\n\ntemplate <class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsleep_until(const chrono::time_point<chrono::steady_clock, _Duration>& __t)\n{\n    using namespace chrono;\n    sleep_for(__t - steady_clock::now());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid yield() _NOEXCEPT {sched_yield();}\n\n}  // this_thread\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif // !_LIBCPP_HAS_NO_THREADS\n\n#endif  // _LIBCPP_THREAD\n","// -*- C++ -*-\n//===--------------------------- iomanip ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOMANIP\n#define _LIBCPP_IOMANIP\n\n/*\n    iomanip synopsis\n\nnamespace std {\n\n// types T1, T2, ... are unspecified implementation types\nT1 resetiosflags(ios_base::fmtflags mask);\nT2 setiosflags (ios_base::fmtflags mask);\nT3 setbase(int base);\ntemplate<charT> T4 setfill(charT c);\nT5 setprecision(int n);\nT6 setw(int n);\ntemplate <class moneyT> T7 get_money(moneyT& mon, bool intl = false);\ntemplate <class charT, class moneyT> T8 put_money(const moneyT& mon, bool intl = false);\ntemplate <class charT> T9 get_time(struct tm* tmb, const charT* fmt);\ntemplate <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);\n\ntemplate <class charT>\n  T11 quoted(const charT* s, charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T12 quoted(const basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T13 quoted(basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <istream>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// resetiosflags\n\nclass __iom_t1\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t1& __x)\n    {\n        __is.unsetf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t1& __x)\n    {\n        __os.unsetf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t1\nresetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t1(__mask);\n}\n\n// setiosflags\n\nclass __iom_t2\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t2& __x)\n    {\n        __is.setf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t2& __x)\n    {\n        __os.setf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t2\nsetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t2(__mask);\n}\n\n// setbase\n\nclass __iom_t3\n{\n    int __base_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t3(int __b) : __base_(__b) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t3& __x)\n    {\n        __is.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t3& __x)\n    {\n        __os.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t3\nsetbase(int __base)\n{\n    return __iom_t3(__base);\n}\n\n// setfill\n\ntemplate<class _CharT>\nclass __iom_t4\n{\n    _CharT __fill_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t4(_CharT __c) : __fill_(__c) {}\n\n    template <class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t4& __x)\n    {\n        __os.fill(__x.__fill_);\n        return __os;\n    }\n};\n\ntemplate<class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t4<_CharT>\nsetfill(_CharT __c)\n{\n    return __iom_t4<_CharT>(__c);\n}\n\n// setprecision\n\nclass __iom_t5\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t5(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t5& __x)\n    {\n        __is.precision(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t5& __x)\n    {\n        __os.precision(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t5\nsetprecision(int __n)\n{\n    return __iom_t5(__n);\n}\n\n// setw\n\nclass __iom_t6\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t6(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t6& __x)\n    {\n        __is.width(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t6& __x)\n    {\n        __os.width(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t6\nsetw(int __n)\n{\n    return __iom_t6(__n);\n}\n\n// get_money\n\ntemplate <class _MoneyT> class __iom_t7;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t7\n{\n    _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t7(_MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef money_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __mf = use_facet<_Fp>(__is.getloc());\n            __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t7<_MoneyT>\nget_money(_MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t7<_MoneyT>(__mon, __intl);\n}\n\n// put_money\n\ntemplate <class _MoneyT> class __iom_t8;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t8\n{\n    const _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t8(const _MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef money_put<_CharT, _Op> _Fp;\n            const _Fp& __mf = use_facet<_Fp>(__os.getloc());\n            if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t8<_MoneyT>\nput_money(const _MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t8<_MoneyT>(__mon, __intl);\n}\n\n// get_time\n\ntemplate <class _CharT> class __iom_t9;\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t9\n{\n    tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t9(tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_istream<_Cp, _Traits>&\n    operator>>(basic_istream<_Cp, _Traits>& __is, const __iom_t9<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef time_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __tf = use_facet<_Fp>(__is.getloc());\n            __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,\n                     __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t9<_CharT>\nget_time(tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t9<_CharT>(__tm, __fmt);\n}\n\n// put_time\n\ntemplate <class _CharT> class __iom_t10;\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t10\n{\n    const tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t10(const tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_ostream<_Cp, _Traits>&\n    operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef time_put<_CharT, _Op> _Fp;\n            const _Fp& __tf = use_facet<_Fp>(__os.getloc());\n            if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,\n                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t10<_CharT>\nput_time(const tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t10<_CharT>(__tm, __fmt);\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _CharT, class _Traits, class _ForwardIterator>\nstd::basic_ostream<_CharT, _Traits> &\n__quoted_output ( basic_ostream<_CharT, _Traits> &__os, \n        _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape )\n{\n    _VSTD::basic_string<_CharT, _Traits> __str;\n    __str.push_back(__delim);\n    for ( ; __first != __last; ++ __first )\n    {\n        if (_Traits::eq (*__first, __escape) || _Traits::eq (*__first, __delim))\n            __str.push_back(__escape);\n        __str.push_back(*__first);\n    }\n    __str.push_back(__delim);\n    return __put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _String>\nbasic_istream<_CharT, _Traits> &\n__quoted_input ( basic_istream<_CharT, _Traits> &__is, _String & __string, _CharT __delim, _CharT __escape )\n{\n    __string.clear ();\n    _CharT __c;\n    __is >> __c;\n    if ( __is.fail ())\n        return __is;\n\n    if (!_Traits::eq (__c, __delim))    // no delimiter, read the whole string\n    {\n        __is.unget ();\n        __is >> __string;\n        return __is;\n    }\n\n    __save_flags<_CharT, _Traits> sf(__is);\n    noskipws (__is);\n    while (true)\n        {\n        __is >> __c;\n        if ( __is.fail ())\n            break;\n        if (_Traits::eq (__c, __escape))\n        {\n            __is >> __c;\n            if ( __is.fail ())\n                break;\n        }\n        else if (_Traits::eq (__c, __delim))\n            break;\n        __string.push_back ( __c );\n        }\n    return __is;\n}\n\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT>>\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\ntemplate <class _CharT, class _Traits, class _Iter>\nbasic_ostream<_CharT, _Traits>& operator<<(\n         basic_ostream<_CharT, _Traits>& __os, \n         const __quoted_output_proxy<_CharT, _Iter, _Traits> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nstruct __quoted_proxy\n{\n    basic_string<_CharT, _Traits, _Allocator> &__string;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)\n    : __string(__s), __delim(__d), __escape(__e) {}\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>& operator<<(\n        basic_ostream<_CharT, _Traits>& __os, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__string.cbegin (), __proxy.__string.cend (), __proxy.__delim, __proxy.__escape);\n}\n\n//  extractor for non-const basic_string& proxies\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>& operator>>(\n        basic_istream<_CharT, _Traits>& __is, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_input ( __is, __proxy.__string, __proxy.__delim, __proxy.__escape );\n}\n\n\ntemplate <class _CharT>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, const _CharT *>\nquoted ( const _CharT *__s, _CharT __delim = _CharT('\"'), _CharT __escape =_CharT('\\\\'))\n{\n    const _CharT *__end = __s;\n    while ( *__end ) ++__end;\n    return __quoted_output_proxy<_CharT, const _CharT *> ( __s, __end, __delim, __escape );\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>\nquoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_output_proxy<_CharT, \n            typename basic_string <_CharT, _Traits, _Allocator>::const_iterator> \n                    ( __s.cbegin(), __s.cend (), __delim, __escape );\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n__quoted_proxy<_CharT, _Traits, _Allocator>\nquoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOMANIP\n","\n// source ~/source/emsdk_portable/emsdk_env.sh\n\n// em++ -std=c++14 --memory-init-file 0 -s ASSERTIONS=2 -s DEMANGLE_SUPPORT=1 -s DISABLE_EXCEPTION_CATCHING=0 -s NO_EXIT_RUNTIME=1 -s AGGRESSIVE_VARIABLE_ELIMINATION=1 -s EXPORT_NAME=\"'ContextLib'\" -s MODULARIZE=1 -DRX_INFO=0 -DRX_SKIP_TESTS=0 -DRX_SKIP_THREAD=1 -DRX_SLOW=0 -DRX_DEFER_IMMEDIATE=0 -O2 -g4 context.cpp -o context.js\n\n// c++ -std=c++14 -DRX_INFO=0 -DRX_SKIP_TESTS=0 -DRX_SKIP_THREAD=0 -DRX_SLOW=0 -DRX_DEFER_IMMEDIATE=0 -O2 context.cpp -o context\n\n#if EMSCRIPTEN\n#include <emscripten.h>\n#include <emscripten/html5.h>\n#endif\n\n#include <set>\n#include <map>\n#include <list>\n#include <string>\n#include <iostream>\n#include <iomanip>\n#include <exception>\n\n#include <regex>\n#include <random>\n#include <chrono>\n#include <thread>\n#include <sstream>\n#include <future>\n#include <queue>\nusing namespace std;\nusing namespace std::chrono;\nusing namespace std::literals;\n\ninline string what(exception_ptr ep) {\n    try {rethrow_exception(ep);}\n    catch (const exception& ex) {\n        return ex.what();\n    }\n    return string();\n}\n\nnamespace detail {\n\nmutex infolock;\nauto start = steady_clock::now();\n\nvoid info(){\n    cout << endl;\n}\n\ntemplate<class A0, class... AN>\nvoid info(A0 a0, AN... an){\n    cout << a0;\n    info(an...);\n}\n\n}\n\nusing float_seconds = duration<float>;\n\nconst auto info = [](auto... an){\n#if RX_INFO\n    unique_lock<mutex> guard(detail::infolock);\n    cout << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << float_seconds{steady_clock::now() - detail::start}.count() << \"s - \";\n    detail::info(an...);\n#else\n    make_tuple(an...);\n#endif\n};\n\nconst auto output = [](auto... an){\n#if RX_INFO\n    unique_lock<mutex> guard(detail::infolock);\n#endif\n    cout << this_thread::get_id() << \" - \" << fixed << setprecision(1) << setw(4) << float_seconds{steady_clock::now() - detail::start}.count() << \"s - \";\n    detail::info(an...);\n};\n\nauto even = [](auto v){return (v % 2) == 0;};\n\nauto always_throw = [](auto... ){\n    throw runtime_error(\"always throw!\");\n    return true;\n};\nvoid use_to_silence_compiler(){\n    always_throw();\n    even(0);\n}\n\nstruct destruction\n{\n    struct Track \n    {\n        ~Track(){\n            output(\"destructed\");\n        }\n    };\n    shared_ptr<Track> track;\n    destruction() : track(make_shared<Track>()) {}\n};\n\n#include \"rx.h\"\n#include \"rx_test.h\"\n#include \"common.h\"\n#include \"designcontext.h\"\n\n#if EMSCRIPTEN\n\nint EMSCRIPTEN_KEEPALIVE main() {\n\n    emscripten_set_main_loop(tick, -1, false);\n\n    return 0;\n}\n\n#else\n\nint main() {\n    designcontext(0, 100);\n    loop.run();\n\n    return 0;\n}\n\n#endif\n\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#elif defined(_NEWLIB_VERSION)\n// FIXME: replace all the uses of _NEWLIB_VERSION with __NEWLIB__ preceded by an\n// include of <sys/cdefs.h> once https://sourceware.org/ml/newlib-cvs/2014-q3/msg00038.html\n// has had a chance to bake for a bit\n#include <support/newlib/xlocale.h>\n#elif !defined(__ANDROID__)\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n#ifndef _LIBCPP_LOCALE__L_EXTENSIONS\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&uselocale)> __locale_raii;\n#endif\n\n// OSX has nice foo_l() functions that let you turn off use of the global\n// locale.  Linux, not so much.  The following functions avoid the locale when\n// that's possible and otherwise do the wrong thing.  FIXME.\n#if defined(__linux__) || defined(__EMSCRIPTEN__) || defined(_AIX) || \\\n    defined(_NEWLIB_VERSION)\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\ndecltype(MB_CUR_MAX_L(_VSTD::declval<locale_t>()))\ninline _LIBCPP_INLINE_VISIBILITY\n__mb_cur_max_l(locale_t __l)\n{\n  return MB_CUR_MAX_L(__l);\n}\n#else  // _LIBCPP_LOCALE__L_EXTENSIONS\ninline _LIBCPP_ALWAYS_INLINE\ndecltype(MB_CUR_MAX) __mb_cur_max_l(locale_t __l)\n{\n  __locale_raii __current(uselocale(__l), uselocale);\n  return MB_CUR_MAX;\n}\n#endif // _LIBCPP_LOCALE__L_EXTENSIONS\n\ninline _LIBCPP_ALWAYS_INLINE\nwint_t __btowc_l(int __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return btowc_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return btowc(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __wctob_l(wint_t __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wctob_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wctob(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcsnrtombs_l(__dest, __src, __nwc, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcrtomb_l(__s, __wc, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcrtomb(__s, __wc, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsnrtowcs_l(__dest, __src, __nms, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,\n                   mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrtowc_l(__pwc, __s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrtowc(__pwc, __s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbtowc_l(__pwc, __pmb, __max, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbtowc(__pwc, __pmb, __max);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrlen_l(__s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrlen(__s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nlconv *__localeconv_l(locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return localeconv_l(__l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return localeconv();\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,\n                     mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsrtowcs_l(__dest, __src, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsrtowcs(__dest, __src, __len, __ps);\n#endif\n}\n\ninline\nint __snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsnprintf_l(__s, __n, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsnprintf(__s, __n, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __asprintf_l(char **__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vasprintf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vasprintf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsscanf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsscanf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\n#endif  // __linux__\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long double __ld = strtold_l(__a, &__p2, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return static_cast<_Tp>(__ld);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    if (sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n#else\n    if (__sscanf_l(__buf.c_str(), __cloc(), \"%p\", &__v) != 1)\n#endif\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __n = static_cast<size_t>(asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n#else\n        __n = __asprintf_l(&__bb, __cloc(), \"%.0Lf\", __units);\n#endif\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#if defined(_WIN32) || defined(__ANDROID__) || defined(_NEWLIB_VERSION)\n    return -1;\n#else // _WIN32 || __ANDROID__\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#endif // _WIN32 || __ANDROID__\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#if defined(_WIN32) || defined(__ANDROID__) || defined(_NEWLIB_VERSION)\n    return __dflt;\n#else // _WIN32\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#if !defined(_WIN32) && !defined(__ANDROID__) && !defined(_NEWLIB_VERSION)\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // !_WIN32\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TYPE_VIS_ONLY wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__wide_err_string_.empty())\n        throw range_error(\"wstring_convert: from_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__byte_err_string_.empty())\n        throw range_error(\"wstring_convert: to_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TYPE_VIS_ONLY wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    switch (__way)\n    {\n    case ios_base::beg:\n        break;\n    case ios_base::cur:\n        break;\n    case ios_base::end:\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* __s, streamsize __n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type __c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type __c);\n    streamsize sputn(const char_type* __s, streamsize __n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n    void gbump(int __n);\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n    void pbump(int __n);\n    void setp(char_type* __pbeg, char_type* __pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)\n{\n    imbue(__loc);\n    locale __r = __loc_;\n    __loc_ = __loc;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::getloc() const\n{\n    return __loc_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)\n{\n    return setbuf(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,\n                                             ios_base::seekdir __way,\n                                             ios_base::openmode __which)\n{\n    return seekoff(__off, __way, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,\n                                             ios_base::openmode __which)\n{\n    return seekpos(__sp, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_streambuf<_CharT, _Traits>::pubsync()\n{\n    return sync();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::in_avail()\n{\n    if (__ninp_ < __einp_)\n        return static_cast<streamsize>(__einp_ - __ninp_);\n    return showmanyc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::snextc()\n{\n    if (sbumpc() == traits_type::eof())\n        return traits_type::eof();\n    return sgetc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sbumpc()\n{\n    if (__ninp_ == __einp_)\n        return uflow();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sgetc()\n{\n    if (__ninp_ == __einp_)\n        return underflow();\n    return traits_type::to_int_type(*__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)\n{\n    return xsgetn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)\n{\n    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n        return pbackfail(traits_type::to_int_type(__c));\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sungetc()\n{\n    if (__binp_ == __ninp_)\n        return pbackfail();\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputc(char_type __c)\n{\n    if (__nout_ == __eout_)\n        return overflow(traits_type::to_int_type(__c));\n    *__nout_++ = __c;\n    return traits_type::to_int_type(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)\n{\n    return xsputn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::gbump(int __n)\n{\n    __ninp_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,\n                                                          char_type* __gend)\n{\n    __binp_ = __gbeg;\n    __ninp_ = __gnext;\n    __einp_ = __gend;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::pbump(int __n)\n{\n    __nout_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)\n{\n    __bout_ = __nout_ = __pbeg;\n    __eout_ = __pend;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    for (;__i < __n; ++__i, ++__s)\n    {\n        if (__ninp_ < __einp_)\n            *__s = *__ninp_++;\n        else if ((__c = uflow()) != __eof)\n            *__s = traits_type::to_char_type(__c);\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    for (; __i < __n; ++__s, ++__i)\n    {\n        if (__nout_ < __eout_)\n            *__nout_++ = *__s;\n        else if (overflow(traits_type::to_int_type(*__s)) == __eof)\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","#pragma once\n\nnamespace rx {\n\n\ntemplate<class Select = defaults>\nstruct lifter;\n\nnamespace detail {\n    template<class VL, class CL, class EL, class VR, class CR, class ER>\n    using lift_t = function<subscriber_interface<VL, CL, EL>(subscriber_interface<VR, CR, ER>)>;\n}\ntemplate<class VL, class CL, class EL, class VR, class CR, class ER>\nstruct lifter<interface<VL, CL, EL, VR, CR, ER>> {\n    detail::lift_t<VL, CL, EL, VR, CR, ER> l;\n    lifter(const lifter&) = default;\n    template<class Lift>\n    lifter(const lifter<Lift>& l) \n        : l(l.l){\n    }\n    subscriber_interface<VL, CL, EL> lift(subscriber_interface<VR, CR, ER> s) const {\n        return l(s);\n    }\n    template<class... TN>\n    lifter as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class VL, class CL, class EL, class VR, class CR, class ER>\nusing lifter_interface = lifter<interface<VL, CL, EL, VR, CR, ER>>;\n\ntemplate<class Lift>\nstruct lifter {\n    using lift_type = decay_t<Lift>;\n    lift_type l;\n    /// \\brief returns subscriber    \n    template<class... SN>\n    auto lift(subscriber<SN...> s) const {\n        static_assert(detail::is_specialization_of<decltype(l(s)), subscriber>::value, \"lift function must return subscriber!\");\n        return l(s);\n    }\n    template<class VL, class CL = steady_clock, class EL = exception_ptr, class VR = VL, class CR = CL, class ER = EL>\n    lifter_interface<VL, CL, EL, VR, CR, ER> as_interface() const {\n        return {*this};\n    }\n};\n\ntemplate<class Lift>\nlifter<Lift> make_lifter(Lift&& l) {\n    return {forward<Lift>(l)};\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_lifter = for_specialization_of_t<T, lifter>;\n\ntemplate<class T>\nusing not_lifter = not_specialization_of_t<T, lifter>;\n\n}\n\n}","#pragma once\n\nnamespace rx {\n\n\ntemplate<class Select = defaults>\nstruct starter;\n\nnamespace detail {\n    template<class C, class E>\n    using start_t = function<subscription(context_interface<C, E>)>;\n}\ntemplate<class C, class E>\nstruct starter<interface<C, E>> {\n    detail::start_t<C, E> s;\n    starter(const starter&) = default;\n    template<class Start>\n    starter(const starter<Start>& s)\n        : s(s.s) {\n    }\n    subscription start(context_interface<C, E> ctx) const {\n        return s(move(ctx));\n    }\n    template<class... TN>\n    starter as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class C, class E>\nusing starter_interface = starter<interface<C, E>>;\n\ntemplate<class Start>\nstruct starter {\n    Start s;\n    template<class... CN>\n    subscription start(context<CN...> ctx) const {\n        return s(ctx);\n    }\n    template<class C = steady_clock, class E = exception_ptr>\n    starter_interface<C, E> as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class Start>\nstarter<Start> make_starter(Start&& s) {\n    return {forward<Start>(s)};\n}\n\nnamespace detail {\n\ntemplate<class T>\nstruct starter_check : public false_type {};\n\ntemplate<class Select>\nstruct starter_check<starter<Select>> : public true_type {};\n\ntemplate<class T>\nusing for_starter = enable_if_t<starter_check<decay_t<T>>::value>;\n\ntemplate<class T>\nusing not_starter = enable_if_t<!starter_check<decay_t<T>>::value>;\n\n}\n\n}","#pragma once\n\nusing Ticks = rx::run_loop<std::chrono::steady_clock, std::exception_ptr>;\nauto loop = Ticks(rx::subscription{});\nauto makeStrand = loop.make();\n\nvoid tick(){\n    Ticks::guard_type guard(loop.loop.get().lock);\n    loop.step(guard, 10ms);\n}\n\nrx::subscription lifetime{};\n\n#if EMSCRIPTEN\n\nextern\"C\" void EMSCRIPTEN_KEEPALIVE reset() {\n    lifetime.stop();\n    lifetime = rx::subscription{};\n    //loop = Ticks(rx::subscription{});\n    //makeStrand = loop.make();\n    detail::start = steady_clock::now();\n}\n\n#endif\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;\n    typedef integral_constant<bool, false> false_type;\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n}  // std\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\ntypedef integral_constant<bool, true>  true_type;\ntypedef integral_constant<bool, false> false_type;\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(long);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\nnamespace __libcpp_is_member_function_pointer_imp {\n    template <typename _Tp>\n    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);\n\n    template <typename>\n    std::__two __test(...);\n};\n    \ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(nullptr)) == 1> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename remove_reference<_Tp>::type* type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n// is_final\n\n#if _LIBCPP_STD_VER > 11 && __has_feature(is_final)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY \nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n// is_convertible\n\n#if __has_feature(is_convertible_to)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> char  __test(_Tp);\ntemplate <class _Tp> __two __test(...);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> _Tp&& __source();\n#else\ntemplate <class _Tp> typename remove_reference<_Tp>::type& __source();\n#endif\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n#else\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[_Len];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[_Len];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote\n{\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\n    typedef typename __promote<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n    static const bool __does_not_throw = _NOEXCEPT_OR_FALSE(static_cast<type>(declval<_A1>()));\n};\n\n#ifdef _LIBCPP_STORE_AS_OPTIMIZATION\n\n// __transform\n\ntemplate <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};\ntemplate <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};\ntemplate <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};\ntemplate <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};\ntemplate <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};\n\n#endif  // _LIBCPP_STORE_AS_OPTIMIZATION\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class V = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp&& __t();\n    static _Up&& __u();\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp __t();\n    static _Up __u();\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\npublic:\n    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class ..._Tp> struct common_type;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n{\nprivate:\n    static _Tp&& __t();\n    static _Up&& __u();\n    static bool __f();\npublic:\n    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n{\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n// is_destructible\n\n//\tif it's a reference, return true\n//\tif it's a function, return false\n//\tif it's   void,     return false\n//\tif it's an array of unknown bound, return false\n//\tOtherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n\ttemplate <typename _Tp1>\n\tstatic char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n\ttemplate <typename _Tp1>\n\tstatic __two __test (...);\n\t\n\tstatic const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<true, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<false, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\n#endif\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\ntemplate <class ..._Args>\nauto\n__invoke(__any, _Args&& ...__args)\n    -> __nat;\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f);\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));\n\n// __invokable\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable_imp\n    : private __check_complete<_Fp>\n{\n    typedef decltype(\n            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)\n                    ) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable\n    : public integral_constant<bool,\n          __invokable_imp<_Fp, _Args...>::value>\n{\n};\n\n// __invoke_of\n\ntemplate <bool _Invokable, class _Fp, class ..._Args>\nstruct __invoke_of_imp  // false\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of_imp<true, _Fp, _Args...>\n{\n    typedef typename __invokable_imp<_Fp, _Args...>::type type;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp>\nstruct __swappable\n{\n    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable<_Tp>::value>\n{\n};\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp>\nstruct __is_nothrow_swappable_imp\n    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),\n                                                   _VSTD::declval<_Tp&>()))>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable_imp<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public false_type\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_imp\n{\n    template <class>\n        static auto __test(__any) -> false_type;\n    template <class _Up>\n        static auto __test(_Up* __u)\n            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;\n\n    static const bool value = decltype(__test<_Tp>(nullptr))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","#pragma once\n\nnamespace rx {\n\ninline context<> start(subscription lifetime = subscription{}) {\n    info(\"start default lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(lifetime.store.get())));\n    return make_context(lifetime);\n}\n\ntemplate<class Payload, class... AN>\nauto start(AN&&... an) {\n    subscription lifetime;\n    info(\"start payload lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(lifetime.store.get())));\n    return make_context<Payload>(lifetime, forward<AN>(an)...);\n}\n\ntemplate<class Payload, class... ArgN>\nauto start(subscription lifetime, ArgN&&... an) {\n    info(\"start lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(lifetime.store.get())) + \" & payload\");\n    return make_context<Payload>(lifetime, forward<ArgN>(an)...);\n}\n\ntemplate<class Payload, class Clock, class... AN>\nauto start(AN&&... an) {\n    subscription lifetime;\n    info(\"start clock & payload lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(lifetime.store.get())));\n    return make_context<Payload, Clock>(subscription{}, forward<AN>(an)...);\n}\n\ntemplate<class Payload, class Clock, class... AN>\nauto start(subscription lifetime, AN&&... an) {\n    info(\"start lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(lifetime.store.get())) + \" & clock & payload\");\n    return make_context<Payload, Clock>(lifetime, forward<AN>(an)...);\n}\n\ntemplate<class Payload, class MakeStrand, class Clock>\nauto start(const context<Payload, MakeStrand, Clock>& o) {\n    info(\"start copy lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(o.lifetime.store.get())));\n    return o;\n}\n\ntemplate<class... CN>\nauto start(subscription lifetime, const context<CN...>& o) {\n    info(\"start copy with new lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(lifetime.store.get())) + \" old lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(lifetime.store.get())));\n    return copy_context(lifetime, o);\n}\n\n}","// -*- C++ -*-\n//===---------------------------- set -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SET\n#define _LIBCPP_SET\n\n/*\n\n    set synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass set\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    set()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit set(const value_compare& comp);\n    set(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last,\n            const value_compare& comp = value_compare());\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const value_compare& comp,\n            const allocator_type& a);\n    set(const set& s);\n    set(set&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit set(const allocator_type& a);\n    set(const set& s, const allocator_type& a);\n    set(set&& s, const allocator_type& a);\n    set(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    set(initializer_list<value_type> il, const value_compare& comp,\n        const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    set(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~set();\n\n    set& operator=(const set& s);\n    set& operator=(set&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    set& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator,bool> insert(const value_type& v);\n    pair<iterator,bool> insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(set& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass multiset\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    multiset()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multiset(const value_compare& comp);\n    multiset(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp = value_compare());\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp, const allocator_type& a);\n    multiset(const multiset& s);\n    multiset(multiset&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multiset(const allocator_type& a);\n    multiset(const multiset& s, const allocator_type& a);\n    multiset(multiset&& s, const allocator_type& a);\n    multiset(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    multiset(initializer_list<value_type> il, const value_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    multiset(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~multiset();\n\n    multiset& operator=(const multiset& s);\n    multiset& operator=(multiset&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multiset& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multiset& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <functional>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY set\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                 key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    set()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l,\n            const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,\n            const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : set(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s)\n        : __tree_(__s.__tree_)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(const set& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const allocator_type& __a)\n        : __tree_(__a) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    set(set&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    set(initializer_list<value_type> __il, const allocator_type& __a)\n        : set(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_unique(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(const value_type& __v)\n        {return __tree_.__insert_unique(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(value_type&& __v)\n        {return __tree_.__insert_unique(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_unique(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_unique(__p, _VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_unique(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(set& __s) _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nset<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\n// specialized algorithms:\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(set<_Key, _Compare, _Allocator>& __x,\n     set<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY multiset\n{\npublic:\n    // types:\n    typedef _Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                                allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    multiset()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(value_compare()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : multiset(__f, __l, key_compare(), __a) {}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s)\n        : __tree_(__s.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(const multiset& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const allocator_type& __a)\n        : __tree_(__a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    multiset(multiset&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multiset(initializer_list<value_type> __il, const allocator_type& __a)\n        : multiset(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v)\n        {return __tree_.__insert_multi(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_multi(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multiset& __s)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k)                  {return __tree_.__count_multi(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nmultiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multiset<_Key, _Compare, _Allocator>& __x,\n     multiset<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SET\n","#pragma once\n\nnamespace rx {\n\nconst auto ints = [](auto first, auto last){\n    info(\"new ints\");\n    return make_observable([=](auto scrb){\n        info(\"ints bound to subscriber\");\n        return make_starter([=](auto ctx) {\n            info(\"ints bound to context\");\n            auto r = scrb.create(ctx);\n            info(\"ints started\");\n            for(auto i = first;!r.lifetime.is_stopped(); ++i){\n                r.next(i);\n                if (i == last) break;\n            }\n            r.complete();\n            return ctx.lifetime;\n        });\n    });\n};\n\nconst auto async_ints = [](auto makeStrand, auto first, auto last){\n    info(\"new async_ints\");\n    return make_observable([=](auto scrb){\n        info(\"async_ints bound to subscriber\");\n        return make_starter([=](auto ctx) {\n            info(\"async_ints bound to context\");\n            subscription lifetime;\n            ctx.lifetime.insert(lifetime);\n            auto outcontext = copy_context(ctx.lifetime, makeStrand, ctx);\n            auto r = scrb.create(outcontext);\n            auto state = make_state<decltype(first)>(ctx.lifetime, first);\n            auto lifted = make_observer(\n                r,\n                lifetime, \n                [=](const auto& r, auto& self) mutable {\n                    auto& s = state.get();\n                    r.next(s);\n                    if (++s == last) {\n                        r.complete();\n                    }\n                    self(outcontext.now());\n                }, detail::pass{}, detail::skip{});\n            info(\"async_ints started\");\n            defer(outcontext, lifted);\n            return ctx.lifetime;\n        });\n    });\n};\n\n}","#pragma once\n\nnamespace rx {\n\n\ntemplate<class Select = defaults, class... TN>\nstruct strand;\n\nnamespace detail {\n    struct shared_strand_construct_t {};\n\n    template<class C>\n    using re_defer_at_t = function<void(time_point_t<C>)>;\n\n    template<class C, class E>\n    struct abstract_strand\n    {\n        virtual ~abstract_strand(){}\n        virtual time_point_t<C> now() const = 0;\n        virtual void defer_at(time_point_t<C>, observer_interface<re_defer_at_t<C>, E>) const = 0;\n    };\n\n    template<class C, class E, class Execute, class Now>\n    struct basic_strand : public abstract_strand<C, E> {\n        using clock_type = decay_t<C>;\n        using errorvalue_type = decay_t<E>;\n        basic_strand(const strand<Execute, Now, C>& o)\n            : d(o){\n        }\n        strand<Execute, Now, C> d;\n        virtual clock_time_point_t<basic_strand> now() const {\n            return d.now();\n        }\n        virtual void defer_at(clock_time_point_t<basic_strand> at, observer_interface<re_defer_at_t<C>, E> out) const {\n            d.defer_at(at, out);\n        }\n    };\n\n    template<class Clock>\n    struct immediate {\n        subscription lifetime;\n        template<class... ON>\n        void operator()(time_point_t<Clock> at, observer<ON...> out) const {\n            auto next = at;\n            bool stop = false;\n            info(\"immediate::defer_at\");\n            while (!stop && !lifetime.is_stopped() && !out.lifetime.is_stopped()) {\n                info(\"immediate::defer_at sleep_until\");\n                this_thread::sleep_until(next);\n                stop = true;\n                info(\"immediate::defer_at next\");\n                out.next([&](typename Clock::time_point at){\n                    info(\"immediate::defer_at self\");\n                    stop = false;\n                    next = at;\n                });\n            }\n            info(\"immediate::defer_at complete\");\n            out.complete();\n        }\n    };\n\n    template<class Clock>\n    struct now {\n        time_point_t<Clock> operator()() const {\n            return Clock::now();\n        }\n    };\n}\n\ntemplate<class C, class E>\nstruct strand<interface<C, E>> {\n    using clock_type = decay_t<C>;\n    using errorvalue_type = decay_t<E>;\n    strand(const strand& o) = default;\n    template<class Execute, class Now>\n    strand(const strand<Execute, Now, C>& o)\n        : lifetime(o.lifetime)\n        , d(make_shared<detail::basic_strand<C, E, Execute, Now>>(o)) {\n    }\n    subscription lifetime;\n    shared_ptr<detail::abstract_strand<clock_type, errorvalue_type>> d;\n    time_point_t<clock_type> now() const {\n        return d->now();\n    }\n    void defer_at(time_point_t<clock_type> at, observer_interface<detail::re_defer_at_t<C>, E> out) const {\n        d->defer_at(at, out);\n    }\n    template<class... TN>\n    strand as_interface() const {\n        return {*this};\n    }\n};\ntemplate<class C, class E>\nusing strand_interface = strand<interface<C, E>>;\n\ntemplate<class Execute, class Now, class Clock>\nstruct strand<Execute, Now, Clock> {\n    using clock_type = decay_t<Clock>;\n    subscription lifetime;\n    Execute e;\n    Now n;\n    time_point_t<clock_type> now() const {\n        return n();\n    }\n    template<class... ON>\n    void defer_at(time_point_t<clock_type> at, observer<ON...> out) const {\n        e(at, out);\n    }\n    template<class E = exception_ptr>\n    strand_interface<Clock, E> as_interface() const {\n        using strand_t = detail::basic_strand<Clock, E, Execute, Now>;\n        return {lifetime, make_shared<strand_t>(*this)};\n    }\n};\n\ntemplate<class Clock = steady_clock, class Execute = detail::immediate<Clock>, class Now = detail::now<Clock>>\nauto make_strand(subscription lifetime, Execute&& e = Execute{}, Now&& n = Now{}) {\n    return strand<decay_t<Execute>, decay_t<Now>, Clock>{\n        lifetime,\n        forward<Execute>(e), \n        forward<Now>(n)\n    };\n}\n\ntemplate<class Strand>\nstruct shared_strand {\n    using strand_type = decay_t<Strand>;\n    template<class F>\n    explicit shared_strand(F&& f, detail::shared_strand_construct_t&&) : st(forward<F>(f)) {}\n    strand_type st;\n    ~shared_strand() {\n        info(\"shared_strand: destroy stop\");\n        st.lifetime.stop();\n    }\n};\n\ntemplate<class Strand>\nstruct shared_strand_maker {\n    using strand_type = decay_t<Strand>;\n    shared_ptr<shared_strand<strand_type>> ss;\n    auto operator()(subscription lifetime) const {\n        ss->st.lifetime.insert(lifetime);\n        return make_strand<clock_t<strand_type>>(lifetime, \n            [ss = this->ss, lifetime](auto at, auto o){\n                lifetime.insert(o.lifetime);\n                ss->st.defer_at(at, o);\n            },\n            [ss = this->ss](){return ss->st.now();});\n    }\n};\n\n\ntemplate<class Strand>\nauto make_shared_strand_maker(Strand&& s) -> shared_strand_maker<decay_t<Strand>> {\n    using strand_type = decay_t<Strand>;\n    return shared_strand_maker<strand_type>{make_shared<shared_strand<strand_type>>(forward<Strand>(s), detail::shared_strand_construct_t{})};\n}\n\ntemplate<class MakeStrand>\nauto make_shared_make_strand(MakeStrand make) {\n    auto strand = make(subscription{});\n    return make_shared_strand_maker(strand);\n}\n\nnamespace detail {\n\ntemplate<class T>\nusing for_strand = for_specialization_of_t<T, strand>;\n\ntemplate<class T>\nusing not_strand = not_specialization_of_t<T, strand>;\n\n}\n\ntemplate<class... SN, class... ON>\nsubscription defer(strand<SN...> s, observer<ON...> out) {\n    s.defer_at(s.now(), out);\n    return out.lifetime;\n}\ntemplate<class... SN, class... ON>\nsubscription defer_at(strand<SN...> s, clock_time_point_t<strand<SN...>> at, observer<ON...> out) {\n    s.defer_at(at, out);\n    return out.lifetime;\n}\ntemplate<class... SN, class... ON>\nsubscription defer_after(strand<SN...> s, clock_duration_t<strand<SN...>> delay, observer<ON...> out) {\n    s.defer_at(s.now() + delay, out);\n    return out.lifetime;\n}\ntemplate<class... SN, class... ON>\nsubscription defer_periodic(strand<SN...> s, clock_time_point_t<strand<SN...>> initial, clock_duration_t<strand<SN...>> period, observer<ON...> out) {\n    auto lifetime = subscription{};\n    auto state = make_state<pair<long, clock_time_point_t<strand<SN...>>>>(lifetime, make_pair(0, initial));\n    s.defer_at(initial, make_observer(\n        out,\n        out.lifetime, \n        [state, period](const observer<ON...>& out, auto& self) mutable {\n            auto& s = state.get();\n            out.next(s.first++);\n            s.second += period;\n            self(s.second);\n        }, detail::pass{}, detail::skip{}));\n    return out.lifetime;\n}\n\n}","#pragma once\n\nnamespace rx {\n\nconst auto last_or_default = [](auto def){\n        info(\"new last_or_default\");\n    return make_lifter([=](auto scbr){\n        info(\"last_or_default bound to subscriber\");\n        return make_subscriber([=](auto ctx){\n            info(\"last_or_default bound to context lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n            auto r = scbr.create(ctx);\n            auto last = make_state<std::decay_t<decltype(def)>>(ctx.lifetime, def);\n            info(\"last_or_default observer lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(r.lifetime.store.get())));\n            return make_observer(r, r.lifetime,\n                [last](auto& , auto v){\n                    last.get() = v;\n                },\n                detail::skip{},\n                [last](auto& r){\n                    r.next(last.get());\n                    r.complete();\n                });\n        });\n    });\n};\n\n}","#pragma once\n\nnamespace rx {\n\nconst auto finally = [](auto f){\n    info(\"new finally\");\n    return make_lifter([=](auto scbr){\n        info(\"finally bound to subscriber\");\n        return make_subscriber([=](auto ctx){\n            info(\"finally bound to context lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(ctx.lifetime.store.get())));\n            auto r = scbr.create(ctx);\n            r.lifetime.insert(f);\n            info(\"finally observer lifetime - \" + to_string(reinterpret_cast<ptrdiff_t>(r.lifetime.store.get())));\n            return make_observer(r, r.lifetime);\n        });\n    });\n};\n\n}","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","// -*- C++ -*-\n//===--------------------------- queue ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_QUEUE\n#define _LIBCPP_QUEUE\n\n/*\n    queue synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Container = deque<T>>\nclass queue\n{\npublic:\n    typedef Container                                container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n\npublic:\n    queue() = default;\n    ~queue() = default;\n\n    queue(const queue& q) = default;\n    queue(queue&& q) = default;\n\n    queue& operator=(const queue& q) = default;\n    queue& operator=(queue&& q) = default;\n\n    explicit queue(const container_type& c);\n    explicit queue(container_type&& c)\n    template <class Alloc>\n        explicit queue(const Alloc& a);\n    template <class Alloc>\n        queue(const container_type& c, const Alloc& a);\n    template <class Alloc>\n        queue(container_type&& c, const Alloc& a);\n    template <class Alloc>\n        queue(const queue& q, const Alloc& a);\n    template <class Alloc>\n        queue(queue&& q, const Alloc& a);\n\n    bool      empty() const;\n    size_type size() const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push(const value_type& v);\n    void push(value_type&& v);\n    template <class... Args> void emplace(Args&&... args);\n    void pop();\n\n    void swap(queue& q) noexcept(noexcept(swap(c, q.c)));\n};\n\ntemplate <class T, class Container>\n  bool operator==(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator< (const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator!=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator> (const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator>=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator<=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  void swap(queue<T, Container>& x, queue<T, Container>& y)\n  noexcept(noexcept(x.swap(y)));\n\ntemplate <class T, class Container = vector<T>,\n          class Compare = less<typename Container::value_type>>\nclass priority_queue\n{\npublic:\n    typedef Container                                container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n    Compare comp;\n\npublic:\n    priority_queue() = default;\n    ~priority_queue() = default;\n\n    priority_queue(const priority_queue& q) = default;\n    priority_queue(priority_queue&& q) = default;\n\n    priority_queue& operator=(const priority_queue& q) = default;\n    priority_queue& operator=(priority_queue&& q) = default;\n\n    explicit priority_queue(const Compare& comp);\n    priority_queue(const Compare& comp, const container_type& c);\n    explicit priority_queue(const Compare& comp, container_type&& c);\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp = Compare());\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp, const container_type& c);\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp, container_type&& c);\n    template <class Alloc>\n        explicit priority_queue(const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, const container_type& c,\n                       const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, container_type&& c,\n                       const Alloc& a);\n    template <class Alloc>\n        priority_queue(const priority_queue& q, const Alloc& a);\n    template <class Alloc>\n        priority_queue(priority_queue&& q, const Alloc& a);\n\n    bool            empty() const;\n    size_type       size() const;\n    const_reference top() const;\n\n    void push(const value_type& v);\n    void push(value_type&& v);\n    template <class... Args> void emplace(Args&&... args);\n    void pop();\n\n    void swap(priority_queue& q)\n        noexcept(noexcept(swap(c, q.c)) && noexcept(swap(comp.q.comp)));\n};\n\ntemplate <class T, class Container, class Compare>\n  void swap(priority_queue<T, Container, Compare>& x,\n            priority_queue<T, Container, Compare>& y)\n            noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <deque>\n#include <vector>\n#include <functional>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Container> class _LIBCPP_TYPE_VIS_ONLY queue;\n\ntemplate <class _Tp, class _Container>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);\n\ntemplate <class _Tp, class _Container>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);\n\ntemplate <class _Tp, class _Container = deque<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY queue\n{\npublic:\n    typedef _Container                               container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    queue()\n        _NOEXCEPT_(is_nothrow_default_constructible<container_type>::value)\n        : c() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    queue(const queue& __q) : c(__q.c) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    queue(queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_constructible<container_type>::value)\n        : c(_VSTD::move(__q.c)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    queue& operator=(const queue& __q) {c = __q.c; return *this;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    queue& operator=(queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_assignable<container_type>::value)\n        {c = _VSTD::move(__q.c); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit queue(const container_type& __c)  : c(__c) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit queue(container_type&& __c) : c(_VSTD::move(__c)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(const queue& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__q.c, __a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(const container_type& __c, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__c, __a) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(container_type&& __c, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(_VSTD::move(__c), __a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(queue&& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(_VSTD::move(__q.c), __a) {}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const {return c.empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const  {return c.size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference       front()       {return c.front();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const {return c.front();}\n    _LIBCPP_INLINE_VISIBILITY\n    reference       back()        {return c.back();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const  {return c.back();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void push(const value_type& __v) {c.push_back(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void push(value_type&& __v)      {c.push_back(_VSTD::move(__v));}\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void emplace(_Args&&... __args)\n            {c.emplace_back(_VSTD::forward<_Args>(__args)...);}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop() {c.pop_front();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value)\n    {\n        using _VSTD::swap;\n        swap(c, __q.c);\n    }\n\n    template <class _T1, class _C1>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator==(const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);\n\n    template <class _T1, class _C1>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator< (const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);\n};\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __x.c == __y.c;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __x.c < __y.c;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(queue<_Tp, _Container>& __x, queue<_Tp, _Container>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, class _Container, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<queue<_Tp, _Container>, _Alloc>\n    : public uses_allocator<_Container, _Alloc>\n{\n};\n\ntemplate <class _Tp, class _Container = vector<_Tp>,\n          class _Compare = less<typename _Container::value_type> >\nclass _LIBCPP_TYPE_VIS_ONLY priority_queue\n{\npublic:\n    typedef _Container                               container_type;\n    typedef _Compare                                 value_compare;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n    value_compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue()\n        _NOEXCEPT_(is_nothrow_default_constructible<container_type>::value &&\n                   is_nothrow_default_constructible<value_compare>::value)\n        : c(), comp() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue(const priority_queue& __q) : c(__q.c), comp(__q.comp) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue(priority_queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_constructible<container_type>::value &&\n                   is_nothrow_move_constructible<value_compare>::value)\n        : c(_VSTD::move(__q.c)), comp(_VSTD::move(__q.comp)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue& operator=(const priority_queue& __q)\n        {c = __q.c; comp = __q.comp; return *this;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue& operator=(priority_queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_assignable<container_type>::value &&\n                   is_nothrow_move_assignable<value_compare>::value)\n        {c = _VSTD::move(__q.c); comp = _VSTD::move(__q.comp); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit priority_queue(const value_compare& __comp)\n        : c(), comp(__comp) {}\n    priority_queue(const value_compare& __comp, const container_type& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    explicit priority_queue(const value_compare& __comp, container_type&& __c);\n#endif\n    template <class _InputIter>\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp = value_compare());\n    template <class _InputIter>\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp, const container_type& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIter>\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp, container_type&& __c);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        explicit priority_queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(const value_compare& __comp, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(const value_compare& __comp, const container_type& __c,\n                       const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(const priority_queue& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        priority_queue(const value_compare& __comp, container_type&& __c,\n                       const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(priority_queue&& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool            empty() const {return c.empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type       size() const  {return c.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference top() const   {return c.front();}\n\n    void push(const value_type& __v);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void push(value_type&& __v);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args> void emplace(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop();\n\n    void swap(priority_queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value &&\n                   __is_nothrow_swappable<value_compare>::value);\n};\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const _Compare& __comp,\n                                                          const container_type& __c)\n    : c(__c),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          container_type&& __c)\n    : c(_VSTD::move(__c)),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp)\n    : c(__f, __l),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp,\n                                                          const container_type& __c)\n    : c(__c),\n      comp(__comp)\n{\n    c.insert(c.end(), __f, __l);\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp,\n                                                          container_type&& __c)\n    : c(_VSTD::move(__c)),\n      comp(__comp)\n{\n    c.insert(c.end(), __f, __l);\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__a)\n{\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__a),\n      comp(__comp)\n{\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          const container_type& __c,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__c, __a),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const priority_queue& __q,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__q.c, __a),\n      comp(__q.comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          container_type&& __c,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(_VSTD::move(__c), __a),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(priority_queue&& __q,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(_VSTD::move(__q.c), __a),\n      comp(_VSTD::move(__q.comp))\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::push(const value_type& __v)\n{\n    c.push_back(__v);\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::push(value_type&& __v)\n{\n    c.push_back(_VSTD::move(__v));\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::emplace(_Args&&... __args)\n{\n    c.emplace_back(_VSTD::forward<_Args>(__args)...);\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::pop()\n{\n    _VSTD::pop_heap(c.begin(), c.end(), comp);\n    c.pop_back();\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::swap(priority_queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value &&\n                   __is_nothrow_swappable<value_compare>::value)\n{\n    using _VSTD::swap;\n    swap(c, __q.c);\n    swap(comp, __q.comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(priority_queue<_Tp, _Container, _Compare>& __x,\n     priority_queue<_Tp, _Container, _Compare>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, class _Container, class _Compare, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<priority_queue<_Tp, _Container, _Compare>, _Alloc>\n    : public uses_allocator<_Container, _Alloc>\n{\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_QUEUE\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    explicit __split_buffer(__alloc_rr& __a);\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__alloc_rr>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr&, __alloc_rr&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_alloc(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n"]}